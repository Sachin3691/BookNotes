NodeJS online documentation=Erxin

# reference 
- 12.18.2
https://nodejs.org/dist/latest-v12.x/docs/api/

- check javascript new features 
$ node --v8-options | grep "in progress"

- The current behaviour of the --harmony flag on Node.js is to enable staged features only

- check v8 version 
$ node -p process.versions.v8

- contribution doc 
https://github.com/nodejs/node/blob/master/CONTRIBUTING.md


# About these document 
- have three statbility levels 
0, deprecated 
1, experimenetal 
2, stable


# Usage examples 
- usages 
$ node [options] [V8 options] [script.js | -e "script" | - ] [arguments]


# APIs 

## Assertion testing 
- Assert 

https://nodejs.org/dist/latest-v12.x/docs/api/assert.html

- functions 

Strict assertion mode
Legacy assertion mode

Class: assert.AssertionError
    new assert.AssertionError(options)
assert(value[, message])

assert.deepEqual(actual, expected[, message])
    Comparison details

assert.deepStrictEqual(actual, expected[, message])
    Comparison details
assert.doesNotMatch(string, regexp[, message])
assert.doesNotReject(asyncFn[, error][, message])
assert.doesNotThrow(fn[, error][, message])
assert.equal(actual, expected[, message])
assert.fail([message])
assert.fail(actual, expected[, message[, operator[, stackStartFn]]])
assert.ifError(value)
assert.match(string, regexp[, message])
assert.notDeepEqual(actual, expected[, message])
assert.notDeepStrictEqual(actual, expected[, message])
assert.notEqual(actual, expected[, message])
assert.notStrictEqual(actual, expected[, message])
assert.ok(value[, message])
assert.rejects(asyncFn[, error][, message])
assert.strictEqual(actual, expected[, message])
assert.throws(fn[, error][, message])


# Async hooks 
- async_hooks, The async_hooks module provides an API to track asynchronous resources. It can be accessed using

const async_hooks = require('async_hooks');

https://nodejs.org/dist/latest-v12.x/docs/api/async_hooks.html

This callback may be called multiple times, for example, the 'connection' event in net.createServer(), or just a single time like in fs.open(). A resource can also be closed before the callback is called. AsyncHook does not explicitly distinguish between these different cases 

If Workers are used, each thread has an independent async_hooks interface, and each thread will use a new set of async IDs.

- functions 

    Async hooks
        Terminology

        Public API

            Overview

                async_hooks.createHook(callbacks)
                    Error handling
                    Printing in AsyncHooks callbacks

            Class: AsyncHook
                asyncHook.enable()
                asyncHook.disable()

                Hook callbacks

                    init(asyncId, type, triggerAsyncId, resource)
                        type
                        triggerAsyncId
                        resource
                        Asynchronous context example
                    before(asyncId)
                    after(asyncId)
                    destroy(asyncId)
                    promiseResolve(asyncId)
                async_hooks.executionAsyncResource()
                async_hooks.executionAsyncId()
                async_hooks.triggerAsyncId()
        Promise execution tracking

        JavaScript embedder API

            Class: AsyncResource
                new AsyncResource(type[, options])
                asyncResource.runInAsyncScope(fn[, thisArg, ...args])
                asyncResource.emitDestroy()
                asyncResource.asyncId()
                asyncResource.triggerAsyncId()
            Using AsyncResource for a Worker thread pool
            Integrating AsyncResource with EventEmitter

        Class: AsyncLocalStorage
            new AsyncLocalStorage()
            asyncLocalStorage.disable()
            asyncLocalStorage.getStore()
            asyncLocalStorage.enterWith(store)
            asyncLocalStorage.run(store, callback[, ...args])
            asyncLocalStorage.exit(callback[, ...args])
            Usage with async/await
            Troubleshooting


# Buffer 
- Buffer 

In Node.js, Buffer objects are used to represent binary data in the form of a sequence of bytes. Many Node.js APIs, for example streams and file system operations, support Buffers, as interactions with the operating system or other processes generally always happen in terms of binary data
    
Instances of Buffer, and instances of Uint8Array in general, are similar to arrays of integers from 0 to 255, but correspond to fixed-sized blocks of memory and cannot contain any other values.
    
https://nodejs.org/dist/latest-v12.x/docs/api/buffer.html

```
require('buffer').Buffer;

// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10,
// filled with bytes which all have the value `1`.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using fill(), write(), or other functions that fill the Buffer's
// contents.
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing the bytes [1, 2, 3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
// are all truncated using `(value & 255)` to fit into the range 0–255.
const buf5 = Buffer.from([257, 257.5, -255, '1']);

// Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':
// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
// [116, 195, 169, 115, 116] (in decimal notation)
const buf6 = Buffer.from('tést');

// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf7 = Buffer.from('tést', 'latin1');

```

- functions 
    Buffer
        Buffers and character encodings
        Buffers and TypedArrays
        Buffers and iteration

        Class: Buffer
            Class Method: Buffer.alloc(size[, fill[, encoding]])
            Class Method: Buffer.allocUnsafe(size)
            Class Method: Buffer.allocUnsafeSlow(size)
            Class Method: Buffer.byteLength(string[, encoding])
            Class Method: Buffer.compare(buf1, buf2)
            Class Method: Buffer.concat(list[, totalLength])
            Class Method: Buffer.from(array)
            Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])
            Class Method: Buffer.from(buffer)
            Class Method: Buffer.from(object[, offsetOrEncoding[, length]])
            Class Method: Buffer.from(string[, encoding])
            Class Method: Buffer.isBuffer(obj)
            Class Method: Buffer.isEncoding(encoding)
            Class Property: Buffer.poolSize
            buf[index]
            buf.buffer
            buf.byteOffset
            buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])
            buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])
            buf.entries()
            buf.equals(otherBuffer)
            buf.fill(value[, offset[, end]][, encoding])
            buf.includes(value[, byteOffset][, encoding])
            buf.indexOf(value[, byteOffset][, encoding])
            buf.keys()
            buf.lastIndexOf(value[, byteOffset][, encoding])
            buf.length
            buf.parent
            buf.readBigInt64BE([offset])
            buf.readBigInt64LE([offset])
            buf.readBigUInt64BE([offset])
            buf.readBigUInt64LE([offset])
            buf.readDoubleBE([offset])
            buf.readDoubleLE([offset])
            buf.readFloatBE([offset])
            buf.readFloatLE([offset])
            buf.readInt8([offset])
            buf.readInt16BE([offset])
            buf.readInt16LE([offset])
            buf.readInt32BE([offset])
            buf.readInt32LE([offset])
            buf.readIntBE(offset, byteLength)
            buf.readIntLE(offset, byteLength)
            buf.readUInt8([offset])
            buf.readUInt16BE([offset])
            buf.readUInt16LE([offset])
            buf.readUInt32BE([offset])
            buf.readUInt32LE([offset])
            buf.readUIntBE(offset, byteLength)
            buf.readUIntLE(offset, byteLength)
            buf.subarray([start[, end]])
            buf.slice([start[, end]])
            buf.swap16()
            buf.swap32()
            buf.swap64()
            buf.toJSON()
            buf.toString([encoding[, start[, end]]])
            buf.values()
            buf.write(string[, offset[, length]][, encoding])
            buf.writeBigInt64BE(value[, offset])
            buf.writeBigInt64LE(value[, offset])
            buf.writeBigUInt64BE(value[, offset])
            buf.writeBigUInt64LE(value[, offset])
            buf.writeDoubleBE(value[, offset])
            buf.writeDoubleLE(value[, offset])
            buf.writeFloatBE(value[, offset])
            buf.writeFloatLE(value[, offset])
            buf.writeInt8(value[, offset])
            buf.writeInt16BE(value[, offset])
            buf.writeInt16LE(value[, offset])
            buf.writeInt32BE(value[, offset])
            buf.writeInt32LE(value[, offset])
            buf.writeIntBE(value, offset, byteLength)
            buf.writeIntLE(value, offset, byteLength)
            buf.writeUInt8(value[, offset])
            buf.writeUInt16BE(value[, offset])
            buf.writeUInt16LE(value[, offset])
            buf.writeUInt32BE(value[, offset])
            buf.writeUInt32LE(value[, offset])
            buf.writeUIntBE(value, offset, byteLength)
            buf.writeUIntLE(value, offset, byteLength)
            new Buffer(array)
            new Buffer(arrayBuffer[, byteOffset[, length]])
            new Buffer(buffer)
            new Buffer(size)
            new Buffer(string[, encoding])
        buffer.INSPECT_MAX_BYTES
        buffer.kMaxLength
        buffer.transcode(source, fromEnc, toEnc)

        Class: SlowBuffer
            new SlowBuffer(size)

        Buffer constants
            buffer.constants.MAX_LENGTH
            buffer.constants.MAX_STRING_LENGTH

        Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()
            The --zero-fill-buffers command line option
            What makes Buffer.allocUnsafe() and Buffer.allocUnsafeSlow() "unsafe"?

- binary-to-text encoding, Converting a Buffer into a string is typically referred to as encoding, and converting a string into a Buffer as decoding

utf8
utf16le 
latin1 
base64
hex 
ascii
latin1binary
ucs2, alias of utf16e

```
Buffer.from('1ag', 'hex');
// Prints <Buffer 1a>, data truncated when first non-hexadecimal value
// ('g') encountered.

Buffer.from('1a7g', 'hex');
// Prints <Buffer 1a>, data truncated when data ends in single digit ('7').

Buffer.from('1634', 'hex');
// Prints <Buffer 16 34>, all data represented.
```

# C++ addons 
- C++ addons,  shared objects written in C++. The require() function can load Addons as ordinary Node.js modules. Addons provide an interface between JavaScript and C/C++ libraries

N-API, nan, or direct use of internal V8, libuv and Node.js libraries. 

https://nodejs.org/dist/latest-v12.x/docs/api/addons.html

- N-API, doc 
https://nodejs.org/dist/latest-v12.x/docs/api/n-api.html

- contents 
    C++ addons

        Hello world

            Context-aware addons
                Worker support
            Building
            Linking to libraries included with Node.js
            Loading addons using require()
        Native abstractions for Node.js
        N-API

        Addon examples
            Function arguments
            Callbacks
            Object factory
            Function factory
            Wrapping C++ objects
            Factory of wrapped objects
            Passing wrapped objects around

- components and APIs 
V8: the C++ library Node.js uses to provide the JavaScript implementation. 

libuv: The C library that implements the Node.js event loop, its worker threads and all of the asynchronous behaviors of the platform.

Internal Node.js libraries. Node.js itself exports C++ APIs that Addons can use, the most important of which is the node::ObjectWrap class

Node.js includes other statically linked libraries including OpenSSL. These other libraries are located in the deps/ directory in the Node.js source tree.

- Hello world example 

    + addon written in C++ which equal to javascript code 
    
```
module.exports.hello = () => 'world';
```

    + steps to create C++ addon 
    
        1.  create file hello.cc 
        ```
        // hello.cc
        #include <node.h>

        namespace demo {

        using v8::FunctionCallbackInfo;
        using v8::Isolate;
        using v8::Local;
        using v8::NewStringType;
        using v8::Object;
        using v8::String;
        using v8::Value;

        void Method(const FunctionCallbackInfo<Value>& args) {
          Isolate* isolate = args.GetIsolate();
          args.GetReturnValue().Set(String::NewFromUtf8(
              isolate, "world", NewStringType::kNormal).ToLocalChecked());
        }

        void Initialize(Local<Object> exports) {
          NODE_SET_METHOD(exports, "hello", Method);
        }

        NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)  //no semi-colon 

        }  // namespace demo

        ```

        all node addons must export an initialization function with the pattern 
        
        ```
        void Initialize(Local<Object> exports);
        NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
        ```

- content-aware addons, sometime the addon need to be loaded multiple times in multiple contexts 

example the Electron runtime runs multiple instances of Node.js in a single process. Each instance will have its own require() cache, and thus each instance will need a native addon to behave correctly when loaded via require().

can be constructed by using the macro NODE_MODULE_INITIALIZER

```
using namespace v8;

extern "C" NODE_MODULE_EXPORT void
NODE_MODULE_INITIALIZER(Local<Object> exports,
                        Local<Value> module,
                        Local<Context> context) {
  /* Perform addon initialization steps here. */
}
```

    + The choice to build a context-aware addon carries with it the responsibility of carefully managing global static data. Since the addon may be loaded multiple times, potentially even from different threads, any global static data stored in the addon must be properly protected, and must not contain any persistent references to JavaScript objects. 
    
        1. define a class will hold per-addon-instance data 
        
        static void DeleteInstance(void* data) {
          // Cast `data` to an instance of the class and delete it.
        }

        2. Heap-allocate an instance of this class in the addon initializer.
        
        3. Call node::AddEnvironmentCleanupHook(), passing it the above-created instance and a pointer to DeleteInstance(). Ensure the environment is torn down 

        4. Store the instance of the class in a v8::External, and
        
        Pass the v8::External to all methods exposed to JavaScript by passing it to v8::FunctionTemplate::New() or v8::Function::New() which creates the native-backed JavaScript functions. The third parameter of v8::FunctionTemplate::New() or v8::Function::New() accepts the v8::External and makes it available in the native callback using the v8::FunctionCallbackInfo::Data() method.

        5. example 
        
```
#include <node.h>

using namespace v8;

class AddonData {
 public:
  explicit AddonData(Isolate* isolate):
      call_count(0) {
    // Ensure this per-addon-instance data is deleted at environment cleanup.
    node::AddEnvironmentCleanupHook(isolate, DeleteInstance, this);
  }

  // Per-addon data.
  int call_count;

  static void DeleteInstance(void* data) {
    delete static_cast<AddonData*>(data);
  }
};

static void Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  // Retrieve the per-addon-instance data.
  AddonData* data =
      reinterpret_cast<AddonData*>(info.Data().As<External>()->Value());
  data->call_count++;
  info.GetReturnValue().Set((double)data->call_count);
}

// Initialize this addon to be context-aware.
NODE_MODULE_INIT(/* exports, module, context */) {
  Isolate* isolate = context->GetIsolate();

  // Create a new instance of `AddonData` for this instance of the addon and
  // tie its life cycle to that of the Node.js environment.
  AddonData* data = new AddonData(isolate);

  // Wrap the data in a `v8::External` so we can pass it to the method we
  // expose.
  Local<External> external = External::New(isolate, data);

  // Expose the method `Method` to JavaScript, and make sure it receives the
  // per-addon-instance data we created above by passing `external` as the
  // third parameter to the `FunctionTemplate` constructor.
  exports->Set(context,
               String::NewFromUtf8(isolate, "method", NewStringType::kNormal)
                  .ToLocalChecked(),
               FunctionTemplate::New(isolate, Method, external)
                  ->GetFunction(context).ToLocalChecked()).FromJust();
}
```

- worker support
    + in order to be loaded from multiple node.js environment requires 
    
    Be an N-API addon, or
    Be declared as context-aware using NODE_MODULE_INIT() as described above

    + In order to support Worker threads, addons need to clean up any resources they may have allocated when such a thread exists.

```
void AddEnvironmentCleanupHook(v8::Isolate* isolate,
                               void (*fun)(void* arg),
                               void* arg);
```
    + example 
```
// addon.cc
#include <assert.h>
#include <stdlib.h>
#include <node.h>

using node::AddEnvironmentCleanupHook;
using v8::HandleScope;
using v8::Isolate;
using v8::Local;
using v8::Object;

// Note: In a real-world application, do not rely on static/global data.
static char cookie[] = "yum yum";
static int cleanup_cb1_called = 0;
static int cleanup_cb2_called = 0;

static void cleanup_cb1(void* arg) {
  Isolate* isolate = static_cast<Isolate*>(arg);
  HandleScope scope(isolate);
  Local<Object> obj = Object::New(isolate);
  assert(!obj.IsEmpty());  // assert VM is still alive
  assert(obj->IsObject());
  cleanup_cb1_called++;
}

static void cleanup_cb2(void* arg) {
  assert(arg == static_cast<void*>(cookie));
  cleanup_cb2_called++;
}

static void sanity_check(void*) {
  assert(cleanup_cb1_called == 1);
  assert(cleanup_cb2_called == 1);
}

// Initialize this addon to be context-aware.
NODE_MODULE_INIT(/* exports, module, context */) {
  Isolate* isolate = context->GetIsolate();

  AddEnvironmentCleanupHook(isolate, sanity_check, nullptr);
  AddEnvironmentCleanupHook(isolate, cleanup_cb2, cookie);
  AddEnvironmentCleanupHook(isolate, cleanup_cb1, isolate);
}
```

load the addon 

```
// test.js
require('./build/Release/addon');
```

- building 
    + create a file called binding.gyp in the top-level of the project describing the build configuration of the module using a JSON-like format. use node-gyp to compile nodejs addons 
    
    https://github.com/nodejs/node-gyp
    
    node-gyp is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js.
    
```
{
  "targets": [
    {
      "target_name": "addon",
      "sources": [ "hello.cc" ]
    }
  ]
}
```
    
//TODO


# C/C++ addons with N-API 

# Child process
- Child process, The child_process module provides the ability to spawn child processes in a manner that is similar, but not identical, to popen(3). This capability is primarily provided by the child_process.spawn()

```
const { spawn } = require('child_process');
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

ls.on('close', (code) => {
  console.log(`child process exited with code ${code}`);
});
```

By default, pipes for stdin, stdout, and stderr are established between the parent Node.js process and the spawned child. These pipes have limited (and platform-specific) capacity.  If child process write to stdout. the child process will block waiting for the pipe buffer to accept more data. This is identical to the behavior of pipes in the shell. Use the { stdio: 'ignore' } option if the output will not be consumed

https://nodejs.org/dist/latest-v12.x/docs/api/child_process.html
- functions 

    Child process

        Asynchronous process creation
            Spawning .bat and .cmd files on Windows
            child_process.exec(command[, options][, callback])
            child_process.execFile(file[, args][, options][, callback])
            child_process.fork(modulePath[, args][, options])

            child_process.spawn(command[, args][, options])
                options.detached
                options.stdio

        Synchronous process creation
            child_process.execFileSync(file[, args][, options])
            child_process.execSync(command[, options])
            child_process.spawnSync(command[, args][, options])

        Class: ChildProcess
            Event: 'close'
            Event: 'disconnect'
            Event: 'error'
            Event: 'exit'
            Event: 'message'
            subprocess.channel
            subprocess.connected
            subprocess.disconnect()
            subprocess.exitCode
            subprocess.kill([signal])
            subprocess.killed
            subprocess.pid
            subprocess.ref()

            subprocess.send(message[, sendHandle[, options]][, callback])
                Example: sending a server object
                Example: sending a socket object
            subprocess.signalCode
            subprocess.spawnargs
            subprocess.spawnfile
            subprocess.stderr
            subprocess.stdin
            subprocess.stdio
            subprocess.stdout
            subprocess.unref()
        maxBuffer and Unicode
        Shell requirements
        Default Windows shell
        Advanced serialization


# Cluster 
- Cluster, A single instance of Node.js runs in a single thread. To take advantage of multi-core systems, the user will sometimes want to launch a cluster of Node.js processes 

create child process that all share server ports 
```
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);

  // Fork workers.
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`worker ${worker.process.pid} died`);
  });
} else {
  // Workers can share any TCP connection
  // In this case it is an HTTP server
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);

  console.log(`Worker ${process.pid} started`);
}
```

https://nodejs.org/dist/latest-v12.x/docs/api/cluster.html

On Windows, it is not yet possible to set up a named pipe server in a worker.

The worker processes are spawned using the child_process.fork() method, so that they can communicate with the parent via IPC and pass server handles back and forth

- functions 

    Cluster
        How it works

        Class: Worker
            Event: 'disconnect'
            Event: 'error'
            Event: 'exit'
            Event: 'listening'
            Event: 'message'
            Event: 'online'
            worker.disconnect()
            worker.exitedAfterDisconnect
            worker.id
            worker.isConnected()
            worker.isDead()
            worker.kill([signal])
            worker.process
            worker.send(message[, sendHandle[, options]][, callback])
        Event: 'disconnect'
        Event: 'exit'
        Event: 'fork'
        Event: 'listening'
        Event: 'message'
        Event: 'online'
        Event: 'setup'
        cluster.disconnect([callback])
        cluster.fork([env])
        cluster.isMaster
        cluster.isWorker
        cluster.schedulingPolicy
        cluster.settings
        cluster.setupMaster([settings])
        cluster.worker
        cluster.workers


# Command line options 
- command line options, To view this documentation as a manual page in a terminal, run man node.

```
$ node [options] [V8 options] [script.js | -e "script" | -] [--] [arguments]

//more doc on debugger sections for inspect 
$ node inspect [script.js | -e "script" | <host>:<port>] …

$ node --v8-options
```

https://nodejs.org/dist/latest-v12.x/docs/api/cli.html

- options 

    Command line options
        Synopsis

        Options
            -
            --
            --abort-on-uncaught-exception
            --completion-bash
            --cpu-prof
            --cpu-prof-dir
            --cpu-prof-interval
            --cpu-prof-name
            --disable-proto=mode
            --disallow-code-generation-from-strings
            --enable-fips
            --enable-source-maps
            --experimental-import-meta-resolve
            --experimental-json-modules
            --experimental-loader=module
            --experimental-modules
            --experimental-policy
            --experimental-repl-await
            --experimental-specifier-resolution=mode
            --experimental-vm-modules
            --experimental-wasi-unstable-preview1
            --experimental-wasm-modules
            --force-context-aware
            --force-fips
            --frozen-intrinsics
            --heapsnapshot-signal=signal
            --heap-prof
            --heap-prof-dir
            --heap-prof-interval
            --heap-prof-name
            --http-parser=library
            --http-server-default-timeout=milliseconds
            --icu-data-dir=file
            --input-type=type
            --inspect-brk[=[host:]port]
            --inspect-port=[host:]port

            --inspect[=[host:]port]
                Warning: binding inspector to a public IP:port combination is insecure
            --inspect-publish-uid=stderr,http
            --insecure-http-parser
            --jitless
            --max-http-header-size=size
            --napi-modules
            --no-deprecation
            --no-force-async-hooks-checks
            --no-warnings
            --openssl-config=file
            --pending-deprecation
            --policy-integrity=sri
            --preserve-symlinks
            --preserve-symlinks-main
            --prof
            --prof-process
            --redirect-warnings=file
            --report-compact
            --report-directory=directory
            --report-filename=filename
            --report-on-fatalerror
            --report-on-signal
            --report-signal=signal
            --report-uncaught-exception
            --throw-deprecation
            --title=title
            --tls-cipher-list=list
            --tls-keylog=file
            --tls-max-v1.2
            --tls-max-v1.3
            --tls-min-v1.0
            --tls-min-v1.1
            --tls-min-v1.2
            --tls-min-v1.3
            --trace-deprecation
            --trace-event-categories
            --trace-event-file-pattern
            --trace-events-enabled
            --trace-exit
            --trace-sigint
            --trace-sync-io
            --trace-tls
            --trace-uncaught
            --trace-warnings
            --track-heap-objects
            --unhandled-rejections=mode
            --use-bundled-ca, --use-openssl-ca
            --use-largepages=mode
            --v8-options
            --v8-pool-size=num
            --zero-fill-buffers
            -c, --check
            -e, --eval "script"
            -h, --help
            -i, --interactive
            -p, --print "script"
            -r, --require module
            -v, --version

        Environment variables
            NODE_DEBUG=module[,…]
            NODE_DEBUG_NATIVE=module[,…]
            NODE_DISABLE_COLORS=1
            NODE_EXTRA_CA_CERTS=file
            NODE_ICU_DATA=file
            NODE_NO_WARNINGS=1
            NODE_OPTIONS=options...
            NODE_PATH=path[:…]
            NODE_PENDING_DEPRECATION=1
            NODE_PENDING_PIPE_INSTANCES=instances
            NODE_PRESERVE_SYMLINKS=1
            NODE_REDIRECT_WARNINGS=file
            NODE_REPL_HISTORY=file
            NODE_REPL_EXTERNAL_MODULE=file
            NODE_TLS_REJECT_UNAUTHORIZED=value

            NODE_V8_COVERAGE=dir
                Coverage output
                Source map cache
            OPENSSL_CONF=file
            SSL_CERT_DIR=dir
            SSL_CERT_FILE=file
            UV_THREADPOOL_SIZE=size

        Useful V8 options
            --max-old-space-size=SIZE (in megabytes)


# Console 
- console, The console module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.

- functions 

    Console

        Class: Console
            new Console(stdout[, stderr][, ignoreErrors])
            new Console(options)
            console.assert(value[, ...message])
            console.clear()
            console.count([label])
            console.countReset([label])
            console.debug(data[, ...args])
            console.dir(obj[, options])
            console.dirxml(...data)
            console.error([data][, ...args])
            console.group([...label])
            console.groupCollapsed()
            console.groupEnd()
            console.info([data][, ...args])
            console.log([data][, ...args])
            console.table(tabularData[, properties])
            console.time([label])
            console.timeEnd([label])
            console.timeLog([label][, ...data])
            console.trace([message][, ...args])
            console.warn([data][, ...args])

        Inspector only methods
            console.profile([label])
            console.profileEnd([label])
            console.timeStamp([label])


# Crypto 
- Crypto, The crypto module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify functions

```
const crypto = require('crypto');

const secret = 'abcdefg';
const hash = crypto.createHmac('sha256', secret)
                   .update('I love cupcakes')
                   .digest('hex');
console.log(hash);
// Prints:
//   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e

```

https://nodejs.org/dist/latest-v12.x/docs/api/crypto.html
- function 

Crypto

    Determining if crypto support is unavailable

    Class: Certificate
        Certificate.exportChallenge(spkac)
        Certificate.exportPublicKey(spkac[, encoding])
        Certificate.verifySpkac(spkac)

        Legacy API
            new crypto.Certificate()
            certificate.exportChallenge(spkac)
            certificate.exportPublicKey(spkac)
            certificate.verifySpkac(spkac)

    Class: Cipher
        cipher.final([outputEncoding])
        cipher.setAAD(buffer[, options])
        cipher.getAuthTag()
        cipher.setAutoPadding([autoPadding])
        cipher.update(data[, inputEncoding][, outputEncoding])

    Class: Decipher
        decipher.final([outputEncoding])
        decipher.setAAD(buffer[, options])
        decipher.setAuthTag(buffer)
        decipher.setAutoPadding([autoPadding])
        decipher.update(data[, inputEncoding][, outputEncoding])

    Class: DiffieHellman
        diffieHellman.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])
        diffieHellman.generateKeys([encoding])
        diffieHellman.getGenerator([encoding])
        diffieHellman.getPrime([encoding])
        diffieHellman.getPrivateKey([encoding])
        diffieHellman.getPublicKey([encoding])
        diffieHellman.setPrivateKey(privateKey[, encoding])
        diffieHellman.setPublicKey(publicKey[, encoding])
        diffieHellman.verifyError
    Class: DiffieHellmanGroup

    Class: ECDH
        Class Method: ECDH.convertKey(key, curve[, inputEncoding[, outputEncoding[, format]]])
        ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])
        ecdh.generateKeys([encoding[, format]])
        ecdh.getPrivateKey([encoding])
        ecdh.getPublicKey([encoding][, format])
        ecdh.setPrivateKey(privateKey[, encoding])
        ecdh.setPublicKey(publicKey[, encoding])

    Class: Hash
        hash.copy([options])
        hash.digest([encoding])
        hash.update(data[, inputEncoding])

    Class: Hmac
        hmac.digest([encoding])
        hmac.update(data[, inputEncoding])

    Class: KeyObject
        keyObject.asymmetricKeyType
        keyObject.export([options])
        keyObject.symmetricKeySize
        keyObject.type

    Class: Sign
        sign.sign(privateKey[, outputEncoding])
        sign.update(data[, inputEncoding])

    Class: Verify
        verify.update(data[, inputEncoding])
        verify.verify(object, signature[, signatureEncoding])

    crypto module methods and properties
        crypto.constants
        crypto.DEFAULT_ENCODING
        crypto.fips
        crypto.createCipher(algorithm, password[, options])
        crypto.createCipheriv(algorithm, key, iv[, options])
        crypto.createDecipher(algorithm, password[, options])
        crypto.createDecipheriv(algorithm, key, iv[, options])
        crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])
        crypto.createDiffieHellman(primeLength[, generator])
        crypto.createDiffieHellmanGroup(name)
        crypto.createECDH(curveName)
        crypto.createHash(algorithm[, options])
        crypto.createHmac(algorithm, key[, options])
        crypto.createPrivateKey(key)
        crypto.createPublicKey(key)
        crypto.createSecretKey(key)
        crypto.createSign(algorithm[, options])
        crypto.createVerify(algorithm[, options])
        crypto.diffieHellman(options)
        crypto.generateKeyPair(type, options, callback)
        crypto.generateKeyPairSync(type, options)
        crypto.getCiphers()
        crypto.getCurves()
        crypto.getDiffieHellman(groupName)
        crypto.getFips()
        crypto.getHashes()
        crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)
        crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)
        crypto.privateDecrypt(privateKey, buffer)
        crypto.privateEncrypt(privateKey, buffer)
        crypto.publicDecrypt(key, buffer)
        crypto.publicEncrypt(key, buffer)
        crypto.randomBytes(size[, callback])
        crypto.randomFillSync(buffer[, offset][, size])
        crypto.randomFill(buffer[, offset][, size], callback)
        crypto.scrypt(password, salt, keylen[, options], callback)
        crypto.scryptSync(password, salt, keylen[, options])
        crypto.setEngine(engine[, flags])
        crypto.setFips(bool)
        crypto.sign(algorithm, data, key)
        crypto.timingSafeEqual(a, b)
        crypto.verify(algorithm, data, key, signature)

- Crypto constants 
OpenSSL options 
OpenSSL engine constants 
Other OpenSSL constants 
Node.js crypto constants 

- Certificate, SPKAC is a Certificate Signing Request mechanism originally implemented by Netscape and was specified formally as part of HTML5's keygen element.

most common usage output generated by HTML5 <keygen> element, use https://www.openssl.org/docs/man1.1.0/apps/openssl-spkac.html OpenSSL's SPKAC implementation 

```
const { Certificate } = require('crypto');
const spkac = getSpkacSomehow();
const challenge = Certificate.exportChallenge(spkac);
console.log(challenge.toString('utf8'));
// Prints: the challenge as a UTF8 string

```

- Cipher, Instances of the Cipher class are used to encrypt data. The class can be used in one of two ways

    + As a stream that is both readable and writable, where plain unencrypted data is written to produce encrypted data on the readable side
    
    + Using the cipher.update() and cipher.final() methods to produce the encrypted data

```
const crypto = require('crypto');

const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';
// Key length is dependent on the algorithm. In this case for aes192, it is
// 24 bytes (192 bits).
// Use async `crypto.scrypt()` instead.
const key = crypto.scryptSync(password, 'salt', 24);
// Use `crypto.randomBytes()` to generate a random iv instead of the static iv
// shown here.
const iv = Buffer.alloc(16, 0); // Initialization vector.

const cipher = crypto.createCipheriv(algorithm, key, iv);

let encrypted = '';
cipher.on('readable', () => {
  let chunk;
  while (null !== (chunk = cipher.read())) {
    encrypted += chunk.toString('hex');
  }
});
cipher.on('end', () => {
  console.log(encrypted);
  // Prints: e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa
});

cipher.write('some clear text data');
cipher.end();
```
- Decipher, Instances of the Decipher class are used to decrypt data. 
    + As a stream that is both readable and writable, where plain encrypted data is written to produce unencrypted data on the readable side
    
    + Using the decipher.update() and decipher.final() methods to produce the unencrypted data

```
const crypto = require('crypto');

const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';
// Key length is dependent on the algorithm. In this case for aes192, it is
// 24 bytes (192 bits).
// Use the async `crypto.scrypt()` instead.
const key = crypto.scryptSync(password, 'salt', 24);
// The IV is usually passed along with the ciphertext.
const iv = Buffer.alloc(16, 0); // Initialization vector.

const decipher = crypto.createDecipheriv(algorithm, key, iv);

let decrypted = '';
decipher.on('readable', () => {
  while (null !== (chunk = decipher.read())) {
    decrypted += chunk.toString('utf8');
  }
});
decipher.on('end', () => {
  console.log(decrypted);
  // Prints: some clear text data
});

// Encrypted with same algorithm, key and iv.
const encrypted =
  'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';
decipher.write(encrypted, 'hex');
decipher.end();
```

- DiffieHellman, is a utility for creating Diffie-Hellman key exchanges.

```
const crypto = require('crypto');
const assert = require('assert');

// Generate Alice's keys...
const alice = crypto.createDiffieHellman(2048);
const aliceKey = alice.generateKeys();

// Generate Bob's keys...
const bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());
const bobKey = bob.generateKeys();

// Exchange and generate the secret...
const aliceSecret = alice.computeSecret(bobKey);
const bobSecret = bob.computeSecret(aliceKey);

// OK
assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));
```
 
- ECDH class is a utility for creating Elliptic Curve Diffie-Hellman (ECDH) key exchanges.

- Hash class is a utility for creating hash digests of data. It can be used in one of two ways:

    + As a stream that is both readable and writable, where data is written to produce a computed hash digest on the readable side
    
    + Using the hash.update() and hash.digest() methods to produce the computed hash
    
use hash objects as streams
```
const crypto = require('crypto');
const hash = crypto.createHash('sha256');

hash.on('readable', () => {
  // Only one element is going to be produced by the
  // hash stream.
  const data = hash.read();
  if (data) {
    console.log(data.toString('hex'));
    // Prints:
    //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
  }
});

hash.write('some data to hash');
hash.end();
```

using hash and piped streams 
```
const crypto = require('crypto');
const fs = require('fs');
const hash = crypto.createHash('sha256');

const input = fs.createReadStream('test.js');
input.pipe(hash).pipe(process.stdout);
```
    
using hash.update(), hash.digest() methods 
```
const crypto = require('crypto');
const hash = crypto.createHash('sha256');

hash.update('some data to hash');
console.log(hash.digest('hex'));
// Prints:
//   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50

```

- Hmac class is a utility for creating cryptographic HMAC digests
    + As a stream that is both readable and writable
    + Using the hmac.update() and hmac.digest() methods to produce the computed HMAC diges
    
```
const crypto = require('crypto');
const hmac = crypto.createHmac('sha256', 'a secret');

hmac.on('readable', () => {
  // Only one element is going to be produced by the
  // hash stream.
  const data = hmac.read();
  if (data) {
    console.log(data.toString('hex'));
    // Prints:
    //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
  }
});

hmac.write('some data to hash');
hmac.end();
```
    
```
const crypto = require('crypto');
const fs = require('fs');
const hmac = crypto.createHmac('sha256', 'a secret');

const input = fs.createReadStream('test.js');
input.pipe(hmac).pipe(process.stdout);
```

```
const crypto = require('crypto');
const hmac = crypto.createHmac('sha256', 'a secret');

hmac.update('some data to hash');
console.log(hmac.digest('hex'));
// Prints:
//   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
 
```

- KeyObject, Node.js uses a KeyObject class to represent a symmetric or asymmetric key, and each kind of key exposes different functions. 

- Sign, The Sign class is a utility for generating signatures. It can be used in one of two ways

Use as stream 
```
const crypto = require('crypto');

const { privateKey, publicKey } = crypto.generateKeyPairSync('ec', {
  namedCurve: 'sect239k1'
});

const sign = crypto.createSign('SHA256');
sign.write('some data to sign');
sign.end();
const signature = sign.sign(privateKey, 'hex');

const verify = crypto.createVerify('SHA256');
verify.write('some data to sign');
verify.end();
console.log(verify.verify(publicKey, signature, 'hex'));
// Prints: true

```

```
const crypto = require('crypto');

const { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
});

const sign = crypto.createSign('SHA256');
sign.update('some data to sign');
sign.end();
const signature = sign.sign(privateKey);

const verify = crypto.createVerify('SHA256');
verify.update('some data to sign');
verify.end();
console.log(verify.verify(publicKey, signature));
// Prints: true

```

- Verify class is a utility for verifying signatures. It can be used in one of two ways


# Debugger 
- Debugger, Node.js includes an out-of-process debugging utility accessible via a V8 Inspector

```
$ node inspect myscript.js
< Debugger listening on ws://127.0.0.1:9229/80e7a814-7cd3-49fb-921a-2e02228cd5ba
< For help, see: https://nodejs.org/en/docs/inspector
< Debugger attached.
Break on start in myscript.js:1
> 1 (function (exports, require, module, __filename, __dirname) { global.x = 5;
  2 setTimeout(() => {
  3   console.log('world');
debug>

```

https://nodejs.org/dist/latest-v12.x/docs/api/debugger.html

- function 

    Debugger
        Watchers

        Command reference
            Stepping
            Breakpoints
            Information
            Execution control
            Various

        Advanced usage
            V8 inspector integration for Node.js



# Deprecated APIs 

# DNS 
- DNS, The dns module enables name resolution. For example, use it to look up IP addresses of host names.
```
const dns = require('dns');

dns.lookup('example.org', (err, address, family) => {
  console.log('address: %j family: IPv%s', address, family);
});
// address: "93.184.216.34" family: IPv4

```

https://nodejs.org/dist/latest-v12.x/docs/api/dns.html
- function 

    DNS

        Class: dns.Resolver
            Resolver([options])
            resolver.cancel()
        dns.getServers()

        dns.lookup(hostname[, options], callback)
            Supported getaddrinfo flags
        dns.lookupService(address, port, callback)
        dns.resolve(hostname[, rrtype], callback)
        dns.resolve4(hostname[, options], callback)
        dns.resolve6(hostname[, options], callback)
        dns.resolveAny(hostname, callback)
        dns.resolveCname(hostname, callback)
        dns.resolveMx(hostname, callback)
        dns.resolveNaptr(hostname, callback)
        dns.resolveNs(hostname, callback)
        dns.resolvePtr(hostname, callback)
        dns.resolveSoa(hostname, callback)
        dns.resolveSrv(hostname, callback)
        dns.resolveTxt(hostname, callback)
        dns.reverse(ip, callback)
        dns.setServers(servers)

        DNS promises API
            Class: dnsPromises.Resolver
            dnsPromises.getServers()
            dnsPromises.lookup(hostname[, options])
            dnsPromises.lookupService(address, port)
            dnsPromises.resolve(hostname[, rrtype])
            dnsPromises.resolve4(hostname[, options])
            dnsPromises.resolve6(hostname[, options])
            dnsPromises.resolveAny(hostname)
            dnsPromises.resolveCname(hostname)
            dnsPromises.resolveMx(hostname)
            dnsPromises.resolveNaptr(hostname)
            dnsPromises.resolveNs(hostname)
            dnsPromises.resolvePtr(hostname)
            dnsPromises.resolveSoa(hostname)
            dnsPromises.resolveSrv(hostname)
            dnsPromises.resolveTxt(hostname)
            dnsPromises.reverse(ip)
            dnsPromises.setServers(servers)
        Error codes

        Implementation considerations
            dns.lookup()
            dns.resolve(), dns.resolve*() and dns.reverse()


# Domain (deprecated) 


# ECMAScript modules 
- ECMAScript, ECMAScript modules are the official standard format to package JavaScript code for reuse

ES module exports a function 
```
// addTwo.mjs
function addTwo(num) {
  return num + 2;
}

export { addTwo };
```

import the module 
```
// app.mjs
import { addTwo } from './addTwo.mjs';

// Prints: 6
console.log(addTwo(4));
```

// package.json, the module type ES module is enable by default 
{
  "type": "module"
}

https://nodejs.org/dist/latest-v12.x/docs/api/esm.html

- function 

    ECMAScript modules
        Introduction

        Enabling
            package.json "type" field
            Package scope and file extensions
            --input-type flag

        Packages

            Package entry points
                Main entry point export
                Subpath exports
                Package exports fallbacks
                Exports sugar
                Conditional exports
                Nested conditions
                Self-referencing a package using its name

            Dual CommonJS/ES module packages
                Dual package hazard

                Writing dual packages while avoiding or minimizing hazards
                    Approach #1: Use an ES module wrapper
                    Approach #2: Isolate state

        import Specifiers

            Terminology
                data: Imports
        import.meta

        Differences between ES modules and CommonJS
            Mandatory file extensions
            No NODE_PATH
            No require, exports, module.exports, __filename, __dirname
            No require.resolve
            No require.extensions
            No require.cache
            URL-based paths

        Interoperability with CommonJS
            require
            import statements
            import() expressions
        CommonJS, JSON, and native modules
        Builtin modules
        Experimental JSON modules
        Experimental Wasm modules

        Experimental loaders

            Hooks
                resolve hook
                getFormat hook
                getSource hook
                transformSource hook
                getGlobalPreloadCode hook
                dynamicInstantiate hook

            Examples
                HTTPS loader
                Transpiler loader

        Resolution algorithm
            Features
            Resolver algorithm
            Customizing ESM specifier resolution algorithm


# Errors 
- Errors, Node.js will generally experience four categories of errors
    1. Standard JavaScript errors such as <EvalError>, <SyntaxError>, <RangeError>, <ReferenceError>, <TypeError>, and <URIError>
    2. System errors triggered by underlying operating system
    3. User-specified errors triggered by application code
    4. AssertionErrors are a special class of error that can be triggered when Node.js 

https://nodejs.org/dist/latest-v12.x/docs/api/errors.html
- functions 
Errors

    Error propagation and interception
        Error-first callbacks

    Class: Error
        new Error(message)
        Error.captureStackTrace(targetObject[, constructorOpt])
        Error.stackTraceLimit
        error.code
        error.message
        error.stack
    Class: AssertionError
    Class: RangeError
    Class: ReferenceError
    Class: SyntaxError

    Class: SystemError
        error.address
        error.code
        error.dest
        error.errno
        error.info
        error.message
        error.path
        error.port
        error.syscall
        Common system errors
    Class: TypeError
    Exceptions vs. errors

    OpenSSL errors
        error.opensslErrorStack
        error.function
        error.library
        error.reason

    Node.js error codes
        ERR_AMBIGUOUS_ARGUMENT
        ERR_ARG_NOT_ITERABLE
        ERR_ASSERTION
        ERR_ASYNC_CALLBACK
        ERR_ASYNC_TYPE
        ...


# Events 
- Events, Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture. emit events are instances of the EventEmitter class

```
const myEmitter = new MyEmitter();
myEmitter.on('event', function(a, b) {
  console.log(a, b, this, this === myEmitter);
  // Prints:
  //   a b MyEmitter {
  //     domain: null,
  //     _events: { event: [Function] },
  //     _eventsCount: 1,
  //     _maxListeners: undefined } true
});
myEmitter.emit('event', 'a', 'b');
```

```
const myEmitter = new MyEmitter();
let m = 0;
myEmitter.once('event', () => {
  console.log(++m);
});
myEmitter.emit('event');
// Prints: 1
myEmitter.emit('event');
// Ignored

```
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error

https://nodejs.org/dist/latest-v12.x/docs/api/events.html
- function 

    Events
        Passing arguments and this to listeners
        Asynchronous vs. synchronous
        Handling events only once
        Error events
        Capture rejections of promises

        Class: EventEmitter
            Event: 'newListener'
            Event: 'removeListener'
            EventEmitter.listenerCount(emitter, eventName)
            EventEmitter.defaultMaxListeners
            EventEmitter.errorMonitor
            emitter.addListener(eventName, listener)
            emitter.emit(eventName[, ...args])
            emitter.eventNames()
            emitter.getMaxListeners()
            emitter.listenerCount(eventName)
            emitter.listeners(eventName)
            emitter.off(eventName, listener)
            emitter.on(eventName, listener)
            emitter.once(eventName, listener)
            emitter.prependListener(eventName, listener)
            emitter.prependOnceListener(eventName, listener)
            emitter.removeAllListeners([eventName])
            emitter.removeListener(eventName, listener)
            emitter.setMaxListeners(n)
            emitter.rawListeners(eventName)
            emitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])
        events.once(emitter, name)
        events.captureRejections
        events.captureRejectionSymbol
        events.on(emitter, eventName)

- capture rejections of promises 
```
const ee1 = new EventEmitter({ captureRejections: true });
ee1.on('something', async (value) => {
  throw new Error('kaboom');
});

ee1.on('error', console.log);

const ee2 = new EventEmitter({ captureRejections: true });
ee2.on('something', async (value) => {
  throw new Error('kaboom');
});

ee2[Symbol.for('nodejs.rejection')] = console.log;
```


# File system 
- File system, interacting with the file system in a manner closely modeled around standard POSIX (Portable Operating System Interface) functions.

https://nodejs.org/dist/latest-v12.x/docs/api/fs.html
- functions
    File system

        File paths
            URL object support
        File descriptors
        Threadpool usage

        Class: fs.Dir
            dir.close()
            dir.close(callback)
            dir.closeSync()
            dir.path
            dir.read()
            dir.read(callback)
            dir.readSync()
            dir[Symbol.asyncIterator]()

        Class: fs.Dirent
            dirent.isBlockDevice()
            dirent.isCharacterDevice()
            dirent.isDirectory()
            dirent.isFIFO()
            dirent.isFile()
            dirent.isSocket()
            dirent.isSymbolicLink()
            dirent.name

        Class: fs.FSWatcher
            Event: 'change'
            Event: 'close'
            Event: 'error'
            watcher.close()

        Class: fs.ReadStream
            Event: 'close'
            Event: 'open'
            Event: 'ready'
            readStream.bytesRead
            readStream.path
            readStream.pending

        Class: fs.Stats
            stats.isBlockDevice()
            stats.isCharacterDevice()
            stats.isDirectory()
            stats.isFIFO()
            stats.isFile()
            stats.isSocket()
            stats.isSymbolicLink()
            stats.dev
            stats.ino
            stats.mode
            stats.nlink
            stats.uid
            stats.gid
            stats.rdev
            stats.size
            stats.blksize
            stats.blocks
            stats.atimeMs
            stats.mtimeMs
            stats.ctimeMs
            stats.birthtimeMs
            stats.atimeNs
            stats.mtimeNs
            stats.ctimeNs
            stats.birthtimeNs
            stats.atime
            stats.mtime
            stats.ctime
            stats.birthtime
            Stat time values

        Class: fs.WriteStream
            Event: 'close'
            Event: 'open'
            Event: 'ready'
            writeStream.bytesWritten
            writeStream.path
            writeStream.pending
        fs.access(path[, mode], callback)
        fs.accessSync(path[, mode])
        fs.appendFile(path, data[, options], callback)
        fs.appendFileSync(path, data[, options])

        fs.chmod(path, mode, callback)
            File modes
        fs.chmodSync(path, mode)
        fs.chown(path, uid, gid, callback)
        fs.chownSync(path, uid, gid)
        fs.close(fd, callback)
        fs.closeSync(fd)
        fs.constants
        fs.copyFile(src, dest[, flags], callback)
        fs.copyFileSync(src, dest[, flags])
        fs.createReadStream(path[, options])
        fs.createWriteStream(path[, options])
        fs.exists(path, callback)
        fs.existsSync(path)
        fs.fchmod(fd, mode, callback)
        fs.fchmodSync(fd, mode)
        fs.fchown(fd, uid, gid, callback)
        fs.fchownSync(fd, uid, gid)
        fs.fdatasync(fd, callback)
        fs.fdatasyncSync(fd)
        fs.fstat(fd[, options], callback)
        fs.fstatSync(fd[, options])
        fs.fsync(fd, callback)
        fs.fsyncSync(fd)
        fs.ftruncate(fd[, len], callback)
        fs.ftruncateSync(fd[, len])
        fs.futimes(fd, atime, mtime, callback)
        fs.futimesSync(fd, atime, mtime)
        fs.lchmod(path, mode, callback)
        fs.lchmodSync(path, mode)
        fs.lchown(path, uid, gid, callback)
        fs.lchownSync(path, uid, gid)
        fs.link(existingPath, newPath, callback)
        fs.linkSync(existingPath, newPath)
        fs.lstat(path[, options], callback)
        fs.lstatSync(path[, options])
        fs.mkdir(path[, options], callback)
        fs.mkdirSync(path[, options])
        fs.mkdtemp(prefix[, options], callback)
        fs.mkdtempSync(prefix[, options])
        fs.open(path[, flags[, mode]], callback)
        fs.opendir(path[, options], callback)
        fs.opendirSync(path[, options])
        fs.openSync(path[, flags, mode])
        fs.read(fd, buffer, offset, length, position, callback)
        fs.read(fd, [options,] callback)
        fs.readdir(path[, options], callback)
        fs.readdirSync(path[, options])

        fs.readFile(path[, options], callback)
            File descriptors
        fs.readFileSync(path[, options])
        fs.readlink(path[, options], callback)
        fs.readlinkSync(path[, options])
        fs.readSync(fd, buffer, offset, length, position)
        fs.readSync(fd, buffer, [options])
        fs.readv(fd, buffers[, position], callback)
        fs.readvSync(fd, buffers[, position])
        fs.realpath(path[, options], callback)
        fs.realpath.native(path[, options], callback)
        fs.realpathSync(path[, options])
        fs.realpathSync.native(path[, options])
        fs.rename(oldPath, newPath, callback)
        fs.renameSync(oldPath, newPath)
        fs.rmdir(path[, options], callback)
        fs.rmdirSync(path[, options])
        fs.stat(path[, options], callback)
        fs.statSync(path[, options])
        fs.symlink(target, path[, type], callback)
        fs.symlinkSync(target, path[, type])
        fs.truncate(path[, len], callback)
        fs.truncateSync(path[, len])
        fs.unlink(path, callback)
        fs.unlinkSync(path)
        fs.unwatchFile(filename[, listener])
        fs.utimes(path, atime, mtime, callback)
        fs.utimesSync(path, atime, mtime)

        fs.watch(filename[, options][, listener])

            Caveats
                Availability
                Inodes
                Filename argument
        fs.watchFile(filename[, options], listener)
        fs.write(fd, buffer[, offset[, length[, position]]], callback)
        fs.write(fd, string[, position[, encoding]], callback)

        fs.writeFile(file, data[, options], callback)
            Using fs.writeFile() with file descriptors
        fs.writeFileSync(file, data[, options])
        fs.writeSync(fd, buffer[, offset[, length[, position]]])
        fs.writeSync(fd, string[, position[, encoding]])
        fs.writev(fd, buffers[, position], callback)
        fs.writevSync(fd, buffers[, position])

        fs Promises API

            Class: FileHandle
                filehandle.appendFile(data, options)
                filehandle.chmod(mode)
                filehandle.chown(uid, gid)
                filehandle.close()
                filehandle.datasync()
                filehandle.fd
                filehandle.read(buffer, offset, length, position)
                filehandle.read(options)
                filehandle.readFile(options)
                filehandle.readv(buffers[, position])
                filehandle.stat([options])
                filehandle.sync()
                filehandle.truncate(len)
                filehandle.utimes(atime, mtime)
                filehandle.write(buffer[, offset[, length[, position]]])
                filehandle.write(string[, position[, encoding]])
                filehandle.writeFile(data, options)
                filehandle.writev(buffers[, position])
            fsPromises.access(path[, mode])
            fsPromises.appendFile(path, data[, options])
            fsPromises.chmod(path, mode)
            fsPromises.chown(path, uid, gid)
            fsPromises.copyFile(src, dest[, flags])
            fsPromises.lchmod(path, mode)
            fsPromises.lchown(path, uid, gid)
            fsPromises.link(existingPath, newPath)
            fsPromises.lstat(path[, options])
            fsPromises.mkdir(path[, options])
            fsPromises.mkdtemp(prefix[, options])
            fsPromises.open(path, flags[, mode])
            fsPromises.opendir(path[, options])
            fsPromises.readdir(path[, options])
            fsPromises.readFile(path[, options])
            fsPromises.readlink(path[, options])
            fsPromises.realpath(path[, options])
            fsPromises.rename(oldPath, newPath)
            fsPromises.rmdir(path[, options])
            fsPromises.stat(path[, options])
            fsPromises.symlink(target, path[, type])
            fsPromises.truncate(path[, len])
            fsPromises.unlink(path)
            fsPromises.utimes(path, atime, mtime)
            fsPromises.writeFile(file, data[, options])

        FS constants
            File access constants
            File copy constants
            File open constants
            File type constants
            File mode constants
        File system flags


# Globals 
- Globals, These objects are available in all modules. The following variables may appear to be global but are not. They exist only in the scope of modules, see the module system documentation

    __dirname
    __filename
    exports
    module
    require()
    
javascript built-in objects 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects

nodejs global objects 
https://nodejs.org/dist/latest-v12.x/docs/api/globals.html
- functions, nodejs global objects 

    Global objects
        Class: Buffer
        __dirname
        __filename
        clearImmediate(immediateObject)
        clearInterval(intervalObject)
        clearTimeout(timeoutObject)
        console
        exports
        global
        module
        process
        queueMicrotask(callback)
        require()
        setImmediate(callback[, ...args])
        setInterval(callback, delay[, ...args])
        setTimeout(callback, delay[, ...args])
        TextDecoder
        TextEncoder
        URL
        URLSearchParams
        WebAssembly
        
- javascript global objects 
    + Value properties

These global properties return a simple value. They have no properties or methods.

    Infinity
    NaN
    undefined
    globalThis

    + Function properties

These global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

    eval()
    uneval() 
    isFinite()
    isNaN()
    parseFloat()
    parseInt()
    encodeURI()
    encodeURIComponent()
    decodeURI()
    decodeURIComponent()
    Deprecated
        escape() 
        unescape() 

    + Fundamental objects

These are the fundamental, basic objects upon which all other objects are based. This includes general objects, booleans, functions, and symbols.

    Object
    Function
    Boolean
    Symbol

    + Error objects

Error objects are a special type of fundamental object. They include the basic Error type, as well as several specialized error types.

    Error
    AggregateError 
    EvalError
    InternalError 
    RangeError
    ReferenceError
    SyntaxError
    TypeError
    URIError

    + Numbers and dates

These are the base objects representing numbers, dates, and mathematical calculations.

    Number
    BigInt
    Math
    Date

    + Text processing

These objects represent strings and support manipulating them.

    String
    RegExp

    + Indexed collections

These objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

    Array
    Int8Array
    Uint8Array
    Uint8ClampedArray
    Int16Array
    Uint16Array
    Int32Array
    Uint32Array
    Float32Array
    Float64Array
    BigInt64Array
    BigUint64Array

    + Keyed collections

These objects represent collections which use keys. The iterable collections (Map and Set) contain elements which are easily iterated in the order of insertion.

    Map
    Set
    WeakMap
    WeakSet

    + Structured data

These objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

    ArrayBuffer
    SharedArrayBuffer 
    Atomics 
    DataView
    JSON

    + Control abstraction objects

Control abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

    Promise
    Generator
    GeneratorFunction
    AsyncFunction

    + Reflection

    Reflect
    Proxy

    + Internationalization

Additions to the ECMAScript core for language-sensitive functionalities.

    Intl
    Intl.Collator
    Intl.DateTimeFormat
    Intl.ListFormat
    Intl.NumberFormat
    Intl.PluralRules
    Intl.RelativeTimeFormat
    Intl.Locale

    + WebAssembly

    WebAssembly
    WebAssembly.Module
    WebAssembly.Instance
    WebAssembly.Memory
    WebAssembly.Table
    WebAssembly.CompileError
    WebAssembly.LinkError
    WebAssembly.RuntimeError

    + Other

    arguments

- global, the top-level scope is the global scope.
- process, have its own section document 
https://nodejs.org/dist/latest-v12.x/docs/api/process.html#process_process


# HTTP 
- HTTP, HTTP server and client one must require('http'). HTTP message headers are represented by an object like this:

{ 'content-length': '123',
  'content-type': 'text/plain',
  'connection': 'keep-alive',
  'host': 'mysite.com',
  'accept': '*/*' }
  
Keys are lowercased. Values are not modified. NodeJS full spectrum of possible HTTP applications, the Node.js HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body.

raw headers as they were received [key, value, key2, value2, ...]

[ 'ConTent-Length', '123456',
  'content-LENGTH', '123',
  'content-type', 'text/plain',
  'CONNECTION', 'keep-alive',
  'Host', 'mysite.com',
  'accepT', '*/*' ]

  
- functions 
    HTTP

        Class: http.Agent
            new Agent([options])
            agent.createConnection(options[, callback])
            agent.keepSocketAlive(socket)
            agent.reuseSocket(socket, request)
            agent.destroy()
            agent.freeSockets
            agent.getName(options)
            agent.maxFreeSockets
            agent.maxSockets
            agent.requests
            agent.sockets

        Class: http.ClientRequest
            Event: 'abort'
            Event: 'connect'
            Event: 'continue'
            Event: 'information'
            Event: 'response'
            Event: 'socket'
            Event: 'timeout'
            Event: 'upgrade'
            request.abort()
            request.aborted
            request.connection
            request.end([data[, encoding]][, callback])
            request.finished
            request.flushHeaders()
            request.getHeader(name)
            request.maxHeadersCount
            request.path
            request.removeHeader(name)
            request.reusedSocket
            request.setHeader(name, value)
            request.setNoDelay([noDelay])
            request.setSocketKeepAlive([enable][, initialDelay])
            request.setTimeout(timeout[, callback])
            request.socket
            request.writableEnded
            request.writableFinished
            request.write(chunk[, encoding][, callback])

        Class: http.Server
            Event: 'checkContinue'
            Event: 'checkExpectation'
            Event: 'clientError'
            Event: 'close'
            Event: 'connect'
            Event: 'connection'
            Event: 'request'
            Event: 'upgrade'
            server.close([callback])
            server.headersTimeout
            server.listen()
            server.listening
            server.maxHeadersCount
            server.setTimeout([msecs][, callback])
            server.timeout
            server.keepAliveTimeout

        Class: http.ServerResponse
            Event: 'close'
            Event: 'finish'
            response.addTrailers(headers)
            response.connection
            response.cork()
            response.end([data[, encoding]][, callback])
            response.finished
            response.flushHeaders()
            response.getHeader(name)
            response.getHeaderNames()
            response.getHeaders()
            response.hasHeader(name)
            response.headersSent
            response.removeHeader(name)
            response.sendDate
            response.setHeader(name, value)
            response.setTimeout(msecs[, callback])
            response.socket
            response.statusCode
            response.statusMessage
            response.uncork()
            response.writableEnded
            response.writableFinished
            response.write(chunk[, encoding][, callback])
            response.writeContinue()
            response.writeHead(statusCode[, statusMessage][, headers])
            response.writeProcessing()

        Class: http.IncomingMessage
            Event: 'aborted'
            Event: 'close'
            message.aborted
            message.complete
            message.destroy([error])
            message.headers
            message.httpVersion
            message.method
            message.rawHeaders
            message.rawTrailers
            message.setTimeout(msecs[, callback])
            message.socket
            message.statusCode
            message.statusMessage
            message.trailers
            message.url
        http.METHODS
        http.STATUS_CODES
        http.createServer([options][, requestListener])
        http.get(options[, callback])
        http.get(url[, options][, callback])
        http.globalAgent
        http.maxHeaderSize
        http.request(options[, callback])
        http.request(url[, options][, callback])

- http.Agent 
//TODO 



# HTTP/2 

# HTTPS

# Inspector 

# Internationalization 

# Modules 

# Net 

# OS 

# Path 

# Performance hooks 

# Policies 

# Process 

# Punycode 

# Query strings 

# Readline 

# REPL 

# Report 

# Stream 

# String decoder 

# Timers 

# TLS/SSL 

# Trace events 

# TTY 

# UDP/datagram 

# URL 

# Utilities 

# V8 

# VM 

# WASI 

# Worker threads 

# Zlib 


