NodeJS online documentation=Erxin

# reference 
- 12.18.2
https://nodejs.org/dist/latest-v12.x/docs/api/

- check javascript new features 
$ node --v8-options | grep "in progress"

- The current behaviour of the --harmony flag on Node.js is to enable staged features only

- check v8 version 
$ node -p process.versions.v8

- contribution doc 
https://github.com/nodejs/node/blob/master/CONTRIBUTING.md


# About these document 
- have three statbility levels 
0, deprecated 
1, experimenetal 
2, stable


# Usage examples 
- usages 
$ node [options] [V8 options] [script.js | -e "script" | - ] [arguments]


# APIs 

## Assertion testing 
- Assert 

https://nodejs.org/dist/latest-v12.x/docs/api/assert.html

- functions 

Strict assertion mode
Legacy assertion mode

Class: assert.AssertionError
    new assert.AssertionError(options)
assert(value[, message])

assert.deepEqual(actual, expected[, message])
    Comparison details

assert.deepStrictEqual(actual, expected[, message])
    Comparison details
assert.doesNotMatch(string, regexp[, message])
assert.doesNotReject(asyncFn[, error][, message])
assert.doesNotThrow(fn[, error][, message])
assert.equal(actual, expected[, message])
assert.fail([message])
assert.fail(actual, expected[, message[, operator[, stackStartFn]]])
assert.ifError(value)
assert.match(string, regexp[, message])
assert.notDeepEqual(actual, expected[, message])
assert.notDeepStrictEqual(actual, expected[, message])
assert.notEqual(actual, expected[, message])
assert.notStrictEqual(actual, expected[, message])
assert.ok(value[, message])
assert.rejects(asyncFn[, error][, message])
assert.strictEqual(actual, expected[, message])
assert.throws(fn[, error][, message])


# Async hooks 
- async_hooks, The async_hooks module provides an API to track asynchronous resources. It can be accessed using

const async_hooks = require('async_hooks');

https://nodejs.org/dist/latest-v12.x/docs/api/async_hooks.html

This callback may be called multiple times, for example, the 'connection' event in net.createServer(), or just a single time like in fs.open(). A resource can also be closed before the callback is called. AsyncHook does not explicitly distinguish between these different cases 

If Workers are used, each thread has an independent async_hooks interface, and each thread will use a new set of async IDs.

- functions 

    Async hooks
        Terminology

        Public API

            Overview

                async_hooks.createHook(callbacks)
                    Error handling
                    Printing in AsyncHooks callbacks

            Class: AsyncHook
                asyncHook.enable()
                asyncHook.disable()

                Hook callbacks

                    init(asyncId, type, triggerAsyncId, resource)
                        type
                        triggerAsyncId
                        resource
                        Asynchronous context example
                    before(asyncId)
                    after(asyncId)
                    destroy(asyncId)
                    promiseResolve(asyncId)
                async_hooks.executionAsyncResource()
                async_hooks.executionAsyncId()
                async_hooks.triggerAsyncId()
        Promise execution tracking

        JavaScript embedder API

            Class: AsyncResource
                new AsyncResource(type[, options])
                asyncResource.runInAsyncScope(fn[, thisArg, ...args])
                asyncResource.emitDestroy()
                asyncResource.asyncId()
                asyncResource.triggerAsyncId()
            Using AsyncResource for a Worker thread pool
            Integrating AsyncResource with EventEmitter

        Class: AsyncLocalStorage
            new AsyncLocalStorage()
            asyncLocalStorage.disable()
            asyncLocalStorage.getStore()
            asyncLocalStorage.enterWith(store)
            asyncLocalStorage.run(store, callback[, ...args])
            asyncLocalStorage.exit(callback[, ...args])
            Usage with async/await
            Troubleshooting


# Buffer 
- Buffer 

In Node.js, Buffer objects are used to represent binary data in the form of a sequence of bytes. Many Node.js APIs, for example streams and file system operations, support Buffers, as interactions with the operating system or other processes generally always happen in terms of binary data
    
Instances of Buffer, and instances of Uint8Array in general, are similar to arrays of integers from 0 to 255, but correspond to fixed-sized blocks of memory and cannot contain any other values.
    
https://nodejs.org/dist/latest-v12.x/docs/api/buffer.html

```
require('buffer').Buffer;

// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10,
// filled with bytes which all have the value `1`.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using fill(), write(), or other functions that fill the Buffer's
// contents.
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing the bytes [1, 2, 3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
// are all truncated using `(value & 255)` to fit into the range 0–255.
const buf5 = Buffer.from([257, 257.5, -255, '1']);

// Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':
// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
// [116, 195, 169, 115, 116] (in decimal notation)
const buf6 = Buffer.from('tést');

// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf7 = Buffer.from('tést', 'latin1');

```

- functions 
    Buffer
        Buffers and character encodings
        Buffers and TypedArrays
        Buffers and iteration

        Class: Buffer
            Class Method: Buffer.alloc(size[, fill[, encoding]])
            Class Method: Buffer.allocUnsafe(size)
            Class Method: Buffer.allocUnsafeSlow(size)
            Class Method: Buffer.byteLength(string[, encoding])
            Class Method: Buffer.compare(buf1, buf2)
            Class Method: Buffer.concat(list[, totalLength])
            Class Method: Buffer.from(array)
            Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])
            Class Method: Buffer.from(buffer)
            Class Method: Buffer.from(object[, offsetOrEncoding[, length]])
            Class Method: Buffer.from(string[, encoding])
            Class Method: Buffer.isBuffer(obj)
            Class Method: Buffer.isEncoding(encoding)
            Class Property: Buffer.poolSize
            buf[index]
            buf.buffer
            buf.byteOffset
            buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])
            buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])
            buf.entries()
            buf.equals(otherBuffer)
            buf.fill(value[, offset[, end]][, encoding])
            buf.includes(value[, byteOffset][, encoding])
            buf.indexOf(value[, byteOffset][, encoding])
            buf.keys()
            buf.lastIndexOf(value[, byteOffset][, encoding])
            buf.length
            buf.parent
            buf.readBigInt64BE([offset])
            buf.readBigInt64LE([offset])
            buf.readBigUInt64BE([offset])
            buf.readBigUInt64LE([offset])
            buf.readDoubleBE([offset])
            buf.readDoubleLE([offset])
            buf.readFloatBE([offset])
            buf.readFloatLE([offset])
            buf.readInt8([offset])
            buf.readInt16BE([offset])
            buf.readInt16LE([offset])
            buf.readInt32BE([offset])
            buf.readInt32LE([offset])
            buf.readIntBE(offset, byteLength)
            buf.readIntLE(offset, byteLength)
            buf.readUInt8([offset])
            buf.readUInt16BE([offset])
            buf.readUInt16LE([offset])
            buf.readUInt32BE([offset])
            buf.readUInt32LE([offset])
            buf.readUIntBE(offset, byteLength)
            buf.readUIntLE(offset, byteLength)
            buf.subarray([start[, end]])
            buf.slice([start[, end]])
            buf.swap16()
            buf.swap32()
            buf.swap64()
            buf.toJSON()
            buf.toString([encoding[, start[, end]]])
            buf.values()
            buf.write(string[, offset[, length]][, encoding])
            buf.writeBigInt64BE(value[, offset])
            buf.writeBigInt64LE(value[, offset])
            buf.writeBigUInt64BE(value[, offset])
            buf.writeBigUInt64LE(value[, offset])
            buf.writeDoubleBE(value[, offset])
            buf.writeDoubleLE(value[, offset])
            buf.writeFloatBE(value[, offset])
            buf.writeFloatLE(value[, offset])
            buf.writeInt8(value[, offset])
            buf.writeInt16BE(value[, offset])
            buf.writeInt16LE(value[, offset])
            buf.writeInt32BE(value[, offset])
            buf.writeInt32LE(value[, offset])
            buf.writeIntBE(value, offset, byteLength)
            buf.writeIntLE(value, offset, byteLength)
            buf.writeUInt8(value[, offset])
            buf.writeUInt16BE(value[, offset])
            buf.writeUInt16LE(value[, offset])
            buf.writeUInt32BE(value[, offset])
            buf.writeUInt32LE(value[, offset])
            buf.writeUIntBE(value, offset, byteLength)
            buf.writeUIntLE(value, offset, byteLength)
            new Buffer(array)
            new Buffer(arrayBuffer[, byteOffset[, length]])
            new Buffer(buffer)
            new Buffer(size)
            new Buffer(string[, encoding])
        buffer.INSPECT_MAX_BYTES
        buffer.kMaxLength
        buffer.transcode(source, fromEnc, toEnc)

        Class: SlowBuffer
            new SlowBuffer(size)

        Buffer constants
            buffer.constants.MAX_LENGTH
            buffer.constants.MAX_STRING_LENGTH

        Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()
            The --zero-fill-buffers command line option
            What makes Buffer.allocUnsafe() and Buffer.allocUnsafeSlow() "unsafe"?

- binary-to-text encoding, Converting a Buffer into a string is typically referred to as encoding, and converting a string into a Buffer as decoding

utf8
utf16le 
latin1 
base64
hex 
ascii
latin1binary
ucs2, alias of utf16e

```
Buffer.from('1ag', 'hex');
// Prints <Buffer 1a>, data truncated when first non-hexadecimal value
// ('g') encountered.

Buffer.from('1a7g', 'hex');
// Prints <Buffer 1a>, data truncated when data ends in single digit ('7').

Buffer.from('1634', 'hex');
// Prints <Buffer 16 34>, all data represented.
```

# C++ addons 
- C++ addons,  shared objects written in C++. The require() function can load Addons as ordinary Node.js modules. Addons provide an interface between JavaScript and C/C++ libraries

N-API, nan, or direct use of internal V8, libuv and Node.js libraries. 

https://nodejs.org/dist/latest-v12.x/docs/api/addons.html

- N-API, doc 
https://nodejs.org/dist/latest-v12.x/docs/api/n-api.html

- contents 
    C++ addons

        Hello world

            Context-aware addons
                Worker support
            Building
            Linking to libraries included with Node.js
            Loading addons using require()
        Native abstractions for Node.js
        N-API

        Addon examples
            Function arguments
            Callbacks
            Object factory
            Function factory
            Wrapping C++ objects
            Factory of wrapped objects
            Passing wrapped objects around

- components and APIs 
V8: the C++ library Node.js uses to provide the JavaScript implementation. 

libuv: The C library that implements the Node.js event loop, its worker threads and all of the asynchronous behaviors of the platform.

Internal Node.js libraries. Node.js itself exports C++ APIs that Addons can use, the most important of which is the node::ObjectWrap class

Node.js includes other statically linked libraries including OpenSSL. These other libraries are located in the deps/ directory in the Node.js source tree.

- Hello world example 

    + addon written in C++ which equal to javascript code 
    
```
module.exports.hello = () => 'world';
```

    + steps to create C++ addon 
    
        1.  create file hello.cc 
        ```
        // hello.cc
        #include <node.h>

        namespace demo {

        using v8::FunctionCallbackInfo;
        using v8::Isolate;
        using v8::Local;
        using v8::NewStringType;
        using v8::Object;
        using v8::String;
        using v8::Value;

        void Method(const FunctionCallbackInfo<Value>& args) {
          Isolate* isolate = args.GetIsolate();
          args.GetReturnValue().Set(String::NewFromUtf8(
              isolate, "world", NewStringType::kNormal).ToLocalChecked());
        }

        void Initialize(Local<Object> exports) {
          NODE_SET_METHOD(exports, "hello", Method);
        }

        NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)  //no semi-colon 

        }  // namespace demo

        ```

        all node addons must export an initialization function with the pattern 
        
        ```
        void Initialize(Local<Object> exports);
        NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
        ```

- content-aware addons, sometime the addon need to be loaded multiple times in multiple contexts 

example the Electron runtime runs multiple instances of Node.js in a single process. Each instance will have its own require() cache, and thus each instance will need a native addon to behave correctly when loaded via require().

can be constructed by using the macro NODE_MODULE_INITIALIZER

```
using namespace v8;

extern "C" NODE_MODULE_EXPORT void
NODE_MODULE_INITIALIZER(Local<Object> exports,
                        Local<Value> module,
                        Local<Context> context) {
  /* Perform addon initialization steps here. */
}
```

    + The choice to build a context-aware addon carries with it the responsibility of carefully managing global static data. Since the addon may be loaded multiple times, potentially even from different threads, any global static data stored in the addon must be properly protected, and must not contain any persistent references to JavaScript objects. 
    
        1. define a class will hold per-addon-instance data 
        
        static void DeleteInstance(void* data) {
          // Cast `data` to an instance of the class and delete it.
        }

        2. Heap-allocate an instance of this class in the addon initializer.
        
        3. Call node::AddEnvironmentCleanupHook(), passing it the above-created instance and a pointer to DeleteInstance(). Ensure the environment is torn down 

        4. Store the instance of the class in a v8::External, and
        
        Pass the v8::External to all methods exposed to JavaScript by passing it to v8::FunctionTemplate::New() or v8::Function::New() which creates the native-backed JavaScript functions. The third parameter of v8::FunctionTemplate::New() or v8::Function::New() accepts the v8::External and makes it available in the native callback using the v8::FunctionCallbackInfo::Data() method.

        5. example 
        
```
#include <node.h>

using namespace v8;

class AddonData {
 public:
  explicit AddonData(Isolate* isolate):
      call_count(0) {
    // Ensure this per-addon-instance data is deleted at environment cleanup.
    node::AddEnvironmentCleanupHook(isolate, DeleteInstance, this);
  }

  // Per-addon data.
  int call_count;

  static void DeleteInstance(void* data) {
    delete static_cast<AddonData*>(data);
  }
};

static void Method(const v8::FunctionCallbackInfo<v8::Value>& info) {
  // Retrieve the per-addon-instance data.
  AddonData* data =
      reinterpret_cast<AddonData*>(info.Data().As<External>()->Value());
  data->call_count++;
  info.GetReturnValue().Set((double)data->call_count);
}

// Initialize this addon to be context-aware.
NODE_MODULE_INIT(/* exports, module, context */) {
  Isolate* isolate = context->GetIsolate();

  // Create a new instance of `AddonData` for this instance of the addon and
  // tie its life cycle to that of the Node.js environment.
  AddonData* data = new AddonData(isolate);

  // Wrap the data in a `v8::External` so we can pass it to the method we
  // expose.
  Local<External> external = External::New(isolate, data);

  // Expose the method `Method` to JavaScript, and make sure it receives the
  // per-addon-instance data we created above by passing `external` as the
  // third parameter to the `FunctionTemplate` constructor.
  exports->Set(context,
               String::NewFromUtf8(isolate, "method", NewStringType::kNormal)
                  .ToLocalChecked(),
               FunctionTemplate::New(isolate, Method, external)
                  ->GetFunction(context).ToLocalChecked()).FromJust();
}
```

- worker support
    + in order to be loaded from multiple node.js environment requires 
    
    Be an N-API addon, or
    Be declared as context-aware using NODE_MODULE_INIT() as described above

    + In order to support Worker threads, addons need to clean up any resources they may have allocated when such a thread exists.

```
void AddEnvironmentCleanupHook(v8::Isolate* isolate,
                               void (*fun)(void* arg),
                               void* arg);
```
    + example 
```
// addon.cc
#include <assert.h>
#include <stdlib.h>
#include <node.h>

using node::AddEnvironmentCleanupHook;
using v8::HandleScope;
using v8::Isolate;
using v8::Local;
using v8::Object;

// Note: In a real-world application, do not rely on static/global data.
static char cookie[] = "yum yum";
static int cleanup_cb1_called = 0;
static int cleanup_cb2_called = 0;

static void cleanup_cb1(void* arg) {
  Isolate* isolate = static_cast<Isolate*>(arg);
  HandleScope scope(isolate);
  Local<Object> obj = Object::New(isolate);
  assert(!obj.IsEmpty());  // assert VM is still alive
  assert(obj->IsObject());
  cleanup_cb1_called++;
}

static void cleanup_cb2(void* arg) {
  assert(arg == static_cast<void*>(cookie));
  cleanup_cb2_called++;
}

static void sanity_check(void*) {
  assert(cleanup_cb1_called == 1);
  assert(cleanup_cb2_called == 1);
}

// Initialize this addon to be context-aware.
NODE_MODULE_INIT(/* exports, module, context */) {
  Isolate* isolate = context->GetIsolate();

  AddEnvironmentCleanupHook(isolate, sanity_check, nullptr);
  AddEnvironmentCleanupHook(isolate, cleanup_cb2, cookie);
  AddEnvironmentCleanupHook(isolate, cleanup_cb1, isolate);
}
```

load the addon 

```
// test.js
require('./build/Release/addon');
```

- building 
    + create a file called binding.gyp in the top-level of the project describing the build configuration of the module using a JSON-like format. use node-gyp to compile nodejs addons 
    
    https://github.com/nodejs/node-gyp
    
    node-gyp is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js.
    
```
{
  "targets": [
    {
      "target_name": "addon",
      "sources": [ "hello.cc" ]
    }
  ]
}
```
    
//TODO


# C/C++ addons with N-API 

# Child process
- Child process, The child_process module provides the ability to spawn child processes in a manner that is similar, but not identical, to popen(3). This capability is primarily provided by the child_process.spawn()

```
const { spawn } = require('child_process');
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

ls.on('close', (code) => {
  console.log(`child process exited with code ${code}`);
});
```

By default, pipes for stdin, stdout, and stderr are established between the parent Node.js process and the spawned child. These pipes have limited (and platform-specific) capacity.  If child process write to stdout. the child process will block waiting for the pipe buffer to accept more data. This is identical to the behavior of pipes in the shell. Use the { stdio: 'ignore' } option if the output will not be consumed

https://nodejs.org/dist/latest-v12.x/docs/api/child_process.html
- functions 

    Child process

        Asynchronous process creation
            Spawning .bat and .cmd files on Windows
            child_process.exec(command[, options][, callback])
            child_process.execFile(file[, args][, options][, callback])
            child_process.fork(modulePath[, args][, options])

            child_process.spawn(command[, args][, options])
                options.detached
                options.stdio

        Synchronous process creation
            child_process.execFileSync(file[, args][, options])
            child_process.execSync(command[, options])
            child_process.spawnSync(command[, args][, options])

        Class: ChildProcess
            Event: 'close'
            Event: 'disconnect'
            Event: 'error'
            Event: 'exit'
            Event: 'message'
            subprocess.channel
            subprocess.connected
            subprocess.disconnect()
            subprocess.exitCode
            subprocess.kill([signal])
            subprocess.killed
            subprocess.pid
            subprocess.ref()

            subprocess.send(message[, sendHandle[, options]][, callback])
                Example: sending a server object
                Example: sending a socket object
            subprocess.signalCode
            subprocess.spawnargs
            subprocess.spawnfile
            subprocess.stderr
            subprocess.stdin
            subprocess.stdio
            subprocess.stdout
            subprocess.unref()
        maxBuffer and Unicode
        Shell requirements
        Default Windows shell
        Advanced serialization


# Cluster 
- Cluster, A single instance of Node.js runs in a single thread. To take advantage of multi-core systems, the user will sometimes want to launch a cluster of Node.js processes 

create child process that all share server ports 
```
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);

  // Fork workers.
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`worker ${worker.process.pid} died`);
  });
} else {
  // Workers can share any TCP connection
  // In this case it is an HTTP server
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);

  console.log(`Worker ${process.pid} started`);
}
```

https://nodejs.org/dist/latest-v12.x/docs/api/cluster.html

On Windows, it is not yet possible to set up a named pipe server in a worker.

The worker processes are spawned using the child_process.fork() method, so that they can communicate with the parent via IPC and pass server handles back and forth

- functions 

    Cluster
        How it works

        Class: Worker
            Event: 'disconnect'
            Event: 'error'
            Event: 'exit'
            Event: 'listening'
            Event: 'message'
            Event: 'online'
            worker.disconnect()
            worker.exitedAfterDisconnect
            worker.id
            worker.isConnected()
            worker.isDead()
            worker.kill([signal])
            worker.process
            worker.send(message[, sendHandle[, options]][, callback])
        Event: 'disconnect'
        Event: 'exit'
        Event: 'fork'
        Event: 'listening'
        Event: 'message'
        Event: 'online'
        Event: 'setup'
        cluster.disconnect([callback])
        cluster.fork([env])
        cluster.isMaster
        cluster.isWorker
        cluster.schedulingPolicy
        cluster.settings
        cluster.setupMaster([settings])
        cluster.worker
        cluster.workers


# Command line options 
- command line options, To view this documentation as a manual page in a terminal, run man node.

```
$ node [options] [V8 options] [script.js | -e "script" | -] [--] [arguments]

//more doc on debugger sections for inspect 
$ node inspect [script.js | -e "script" | <host>:<port>] …

$ node --v8-options
```

https://nodejs.org/dist/latest-v12.x/docs/api/cli.html

- options 

    Command line options
        Synopsis

        Options
            -
            --
            --abort-on-uncaught-exception
            --completion-bash
            --cpu-prof
            --cpu-prof-dir
            --cpu-prof-interval
            --cpu-prof-name
            --disable-proto=mode
            --disallow-code-generation-from-strings
            --enable-fips
            --enable-source-maps
            --experimental-import-meta-resolve
            --experimental-json-modules
            --experimental-loader=module
            --experimental-modules
            --experimental-policy
            --experimental-repl-await
            --experimental-specifier-resolution=mode
            --experimental-vm-modules
            --experimental-wasi-unstable-preview1
            --experimental-wasm-modules
            --force-context-aware
            --force-fips
            --frozen-intrinsics
            --heapsnapshot-signal=signal
            --heap-prof
            --heap-prof-dir
            --heap-prof-interval
            --heap-prof-name
            --http-parser=library
            --http-server-default-timeout=milliseconds
            --icu-data-dir=file
            --input-type=type
            --inspect-brk[=[host:]port]
            --inspect-port=[host:]port

            --inspect[=[host:]port]
                Warning: binding inspector to a public IP:port combination is insecure
            --inspect-publish-uid=stderr,http
            --insecure-http-parser
            --jitless
            --max-http-header-size=size
            --napi-modules
            --no-deprecation
            --no-force-async-hooks-checks
            --no-warnings
            --openssl-config=file
            --pending-deprecation
            --policy-integrity=sri
            --preserve-symlinks
            --preserve-symlinks-main
            --prof
            --prof-process
            --redirect-warnings=file
            --report-compact
            --report-directory=directory
            --report-filename=filename
            --report-on-fatalerror
            --report-on-signal
            --report-signal=signal
            --report-uncaught-exception
            --throw-deprecation
            --title=title
            --tls-cipher-list=list
            --tls-keylog=file
            --tls-max-v1.2
            --tls-max-v1.3
            --tls-min-v1.0
            --tls-min-v1.1
            --tls-min-v1.2
            --tls-min-v1.3
            --trace-deprecation
            --trace-event-categories
            --trace-event-file-pattern
            --trace-events-enabled
            --trace-exit
            --trace-sigint
            --trace-sync-io
            --trace-tls
            --trace-uncaught
            --trace-warnings
            --track-heap-objects
            --unhandled-rejections=mode
            --use-bundled-ca, --use-openssl-ca
            --use-largepages=mode
            --v8-options
            --v8-pool-size=num
            --zero-fill-buffers
            -c, --check
            -e, --eval "script"
            -h, --help
            -i, --interactive
            -p, --print "script"
            -r, --require module
            -v, --version

        Environment variables
            NODE_DEBUG=module[,…]
            NODE_DEBUG_NATIVE=module[,…]
            NODE_DISABLE_COLORS=1
            NODE_EXTRA_CA_CERTS=file
            NODE_ICU_DATA=file
            NODE_NO_WARNINGS=1
            NODE_OPTIONS=options...
            NODE_PATH=path[:…]
            NODE_PENDING_DEPRECATION=1
            NODE_PENDING_PIPE_INSTANCES=instances
            NODE_PRESERVE_SYMLINKS=1
            NODE_REDIRECT_WARNINGS=file
            NODE_REPL_HISTORY=file
            NODE_REPL_EXTERNAL_MODULE=file
            NODE_TLS_REJECT_UNAUTHORIZED=value

            NODE_V8_COVERAGE=dir
                Coverage output
                Source map cache
            OPENSSL_CONF=file
            SSL_CERT_DIR=dir
            SSL_CERT_FILE=file
            UV_THREADPOOL_SIZE=size

        Useful V8 options
            --max-old-space-size=SIZE (in megabytes)


# Console 
- console, The console module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.

- functions 

    Console

        Class: Console
            new Console(stdout[, stderr][, ignoreErrors])
            new Console(options)
            console.assert(value[, ...message])
            console.clear()
            console.count([label])
            console.countReset([label])
            console.debug(data[, ...args])
            console.dir(obj[, options])
            console.dirxml(...data)
            console.error([data][, ...args])
            console.group([...label])
            console.groupCollapsed()
            console.groupEnd()
            console.info([data][, ...args])
            console.log([data][, ...args])
            console.table(tabularData[, properties])
            console.time([label])
            console.timeEnd([label])
            console.timeLog([label][, ...data])
            console.trace([message][, ...args])
            console.warn([data][, ...args])

        Inspector only methods
            console.profile([label])
            console.profileEnd([label])
            console.timeStamp([label])


# Crypto 

# Debugger 

# Deprecated APIs 

# DNS 

# Domain 

# ECMAScript modules 

# Errors 

# Events 

# File system 

# Globals 

# HTTP 

# HTTP/2 

# HTTPS

# Inspector 

# Internationalization 

# Modules 

# Net 

# OS 

# Path 

# Performance hooks 

# Policies 

# Process 

# Punycode 

# Query strings 

# Readline 

# REPL 

# Report 

# Stream 

# String decoder 

# Timers 

# TLS/SSL 

# Trace events 

# TTY 

# UDP/datagram 

# URL 

# Utilities 

# V8 

# VM 

# WASI 

# Worker threads 

# Zlib 


