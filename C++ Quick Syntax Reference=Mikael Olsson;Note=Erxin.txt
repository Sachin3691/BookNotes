C++ Quick Syntax Reference=Mikael Olsson;Note=Erxin

# hello world
- choosing an ide, visual studio
- include directive 
#include <iostream>
int main() 
{
	std::out << "hello world";
}

- using namespace
to make things a bit easier, you can add a line specifying that the code file uses the standard namespace
#include <isostream>
using namespace std;
int main()
{
	count <<"Hello world";
}

- console compilation
g++ myapp.cpp -o myapp.exe
- comments
	+ single-line, //
	+ multi-line, /* .. */
	

# variable
- data types, on most 32-byte system
data type	   size(byte)	  description
char			1			   integer or character
short		   2 
int			 4			   integer
long			4				   
float		   4
double		  8			   floating-point number
long double	 8 
bool			1			   boolean value	
	
the int size will have the same size as the processor's word size
	
- declaring variables
int name;
	
- octal and hexadecimal aassignment
int variable = 062; //octal notation
int variable = 0x32; //hexadecimal notation
	
- variable scope
	+ global variable
	int globalVar;
	int main()
	{
		int localVar;
	}
	
- default values
	+ global will automatically initialized to zero
	+ local variable not initialized
	
- integer types
	+ char, -128 to +127
	+ short, -32768 to 32767
	+ int, -2^31 to 2^31-1
	+ long, -2^31 to 2^31-1
	
	+ ms vc also support 64-bits
	long long variable = 0; // -2^63 to 2^63 - 1
	
	+ in the microsoft c+= features five sized integer types, type start with __int followed by the number of bits you want the integer to hold either, 8, 16, 32 or 64 bits
	__int8 var = 0; //8 bits
	__int16 var = 0; //16bits
	__int32
	__int64
	
- signed and unsigned integers
unsigned char var = 0; // 0 to 255
	
- floating-point types
float myFLoat = 3.14; //3.4e +/- 38(7 digits)
double myDouble = 3.14; //1.7e +/- 308 (15 digits)
long double = 3.14;// same as double
	
myFloat = 12345.678 //rounded to 12345.68
	
- char type, commonly used to represent ascii characters
char c = 'x';
	
- bool type, only can be true or false


# Operators
- arithmetic operators
+, -, *, /, %(modulus)
	
- assignment operators, =
- combined assignment operators
+=, --, *=, /=, %=
	
- increment and decrement operators
x++, x--, ++x, --x

- comparison operators
==, !=, >, <, >=, <=
	
- logical operators
&&, ||, !
	
- bitwise operators
&, |, ^, <<, >>, ~
	
- bitwise comboned operators
&=, |=, ^=, <<=, >>=

- operator precedence
pre operator	 pre		operator
1   ++ -- ! ~	7		  &
2   * / %		8		  ^
3   + -		  9		  |
4   << >>		10		 &&
5   <<= >>=	  11		 ||
6   == !=		12		 = op=


# pointers
- pointer is a variable that contains the memory address of another variable
- creating pointers
int *p;
int *q;
int i = 10;
p = &i;

- dereferencing pointers
get the value store in the address which pointer contain
*pointer

- point to a pointer
type ** r = &p; //pointer to p

- dynamic allocation, the new operator takes either a primitive data type or an object as its argument
int *d = new int; // dynamic allocation

delete the allocated memory
delete d; //release allocated memory

- null pointer, a pointer should be set to zero when it is not assigned to a valid address, called a null pointer

delete the pointer should be set to zero. trying to delete an already deleted null pointer is safe. however if the pointer has not been set to zero, attempting to delete it again will cause memory corruption

delete d;
d = 0; // mark as null pointer

delete d; // delete null pointer again is safe

constant NULL can also be used to signify a null pointer, NULL is typically defined as zero in c++
#include <iostream>
if (d != NULL) 
{
	*d = 10;
}


# references
- references allow a programmer to create a new name for a variable, provide a simpler, safer and less powerful alternative to pointers

int x = 5;
int& r = x; // r is an alias to x
int &s = x; alternative syntax

reference has been assigned then it can never be reseated to another variable

- references and pointers, reference does not have its address of its own
int* ptr = &x; //pt assgined address to x

- reference and pointer guideline, whenever a pointer does not need to be reassigned a reference should be used, reference is safer than a pointer because it always reference to a variable, this means that there is no need to check if a reference refers to null
int* ptr = 0; //null pointer
int& ref = *ptr;
ref = 10; // segmentation fault


# arrays
- array is a data structure used for storing a collection of values that all have the same data type
- array declaration and allocation
	+ global array, will initialize to their default value
	+ local array, will not initialize 
	
- array assignment, starting with zero
ary[0] = value;

assign values at the same time
int ary[3] = {1, 2, 3};
int ary[] = {1, 2, 3};

- multi-dimensional arrays
int ar[2][2] = {{0, 1}, {2, 3}};

- dynamic arrays, static allocate means the array size should be determine before the allocation therefore the size needs to be a constant value. 
dynamic allocate with new keyword allow allocate a size with variable, but it must be assign to a pointer or reference.

int* p = new int[3];

Any array in C++ is actually a pointer to the first element in the array. The referencing of array elements can be made just as well with pointer arithmetic. 
*(p+1) = 10; // p[1] = 10;

- Determining array size
int length = sizeof(myArray) / sizeof(int); // 3

This method cannot be used for dynamically allocated arrays. The only way to determine the size of such an array is through the variable used in its allocation.

int size = 3;
int* p = new int[size]; // dynamically allocated array

delete the dynamic array
delete[] p; // release allocated array


# string
- used to store string values, standard namespace and also be included since the string class is part of that namespace
#include <string>
using namespace std;

strings can be declared like any other data type

string h = "Hello";
string w (" World");

- string combining, concatenation operator (+) in this context
string a = h + w; // Hello World
h += w; // Hello World

It is not able to concatenate two C strings or two string literals. To do this, one of the values has to be explicitly cast to a string.

char *c = "World"; // C-style string
b = (string)c + c; // ok
b = "Hello" + (string)" World"; // ok

string literals will also be implicit combined if the plug sign is left out
b = "Hel" "lo"; // ok

- escape characters, extended more than one line by putting a backslash sign (\) at the end of each line
string s = "Hello \
			World";
			
character   meaning		 character	   meaning
\n		  newline		 \f			  form feed
\t		  horizontal tab  \a			  alter sound
\v		  vertical tab	\'			  single quote
\b		  backspace	   \"			  double quote 
\r		  carriage return \\			  backslash
\0		  null character

any one of the 128 ascii characters can be expressed by writing a backslash followed by the ascii code
"\07F" // octal character (0-07F)
"\0x177" //hexadecimal character(0-0x177)

- string compare, ==
- string functions
length(), size(), sbustr(start, length)


# conditional
- used to execute different code blocks base on diffferent condition
- if statement
if(condition){
}
else if(condition){
}
else{
}

- switch statement
switch(x)
{
	case condition:
		;
		break;
	default:
		;
		break;
}

- ternary operator
condition? true_statement:false_statement;


# loops
- there are three looping structures available in cpp
- while loop
while(condition){
}

- do while
do{
}while(condition);


- for loop
for(init;condition;additional){
}

- break and continue
for(...)
{
	break; //end loop
	continue; //start next iteration
}

- goto statement, unconditional jump to a specified label
goto label;
label:


# functions
- functions are reusable code block that will only execute when called
- defining functions
void myFunction()
{
	;
}
- calling function
functionName();
- default parementer value
void function(string str = "hello")
{
}

- function overloading, a function in cpp can be defined multiple times with different arguments
void myFunction(string a, string b);
void myFunction(string a);

- return statement
type func()
{
	return value;
}

- forward declaration, important thing to keep in mind in cpp is that functions must be declared before they called
void myFunction(parameters); //prototype
void main()
{
	myFunction(args);
}

void myFunction(parameters) // implementation
{
}

- pass by value, variables of both primitive and object data types are by default passed by value, this means that only a copy of the value or object is passed the function
#include <iostream>
#include <string>
using namespace std;

void change(int i) { i = 10; }
void change(string s) { s = "Hello World"; }

int main()
{
	int x = 0; // value type
	change(x); // value is passed
	cout << x; // 0
	string y = ""; // reference type
	change(y); // object copy is passed
	cout << y; // ""
}

- pass by reference, instead pass a variable by reference you need to add an ampersand before the parameter's name

void change(type& name){ }

int x;
change(x); //reference is passed

- pass by address, passed by address using pointers

void change(int* i){}

int x = 0;
change(&x); //address is passed

- return by value, reference or address, a variable may also be returned in one of these ways, most commonly a function returns by value, in which case a copy of the value is returned to the caller
int byVal(int i){return i + 1;}

int a = 10;
count << byVal(a); // 11

to return by reference instead, an ampersand is placed after the function's return type. the function must then return a variable and may not return an expression or literal
the variable return should never be a local variable
instead return by reference is commonly used to return an argument that has also been passed to the function by reference

int& byRef(int& i) { return i; }
int main()
{
	int a = 10;
	cout << byRef(a); // 10
}

to return by address the dereference operator is appended to the function's return type, the restriction is the address of a variable must be returned and that returned variable must not be local to the function
int* byAdr(int* i){ return i;}
int main()
{
	int a = 10;
	cout << *byAdr(&a); // 10
}

- inline functions, every time a function is called a performance overhead occurs, this keyword is best suited for small functions
inline int myInc(int i) {return i++;}


# class
- a class is a template used to create objects
- class members can be declared inside the class, the two main kinds are fields and methods
class Rectangle
{
	int x, y;
	int getArea();
}

int Rectangle::getArea() { return x*y;}

- inline method, use the inline keyword when implement the function outside the class, if implement the function inside a class this implicit recommend to the compiler that the method should be inlined
inline Rectangle::getArea() {return x*y;}

equal to 
class Rectangle
{
	int x, y;
	int getArea(){return x*y;}
}

- object creation
//object creation, this can be done in the same way as variable are declared
Rectangle r; 

- accessing object members, declared as public class definition by using the public keyword follow by a colon
class Rectangle
{
	private:
		int x, y;
	public:
		int getArea(){return x * y;}
}

Rectangle r;
r.getArea();

when using a object pointer, the arrow operator allows access to the object's members
Rectangle* p = &r;
p->getArea();

- forward declaration
class Rectangle; //class prototype

void main()
{
	Rectangle r;
}

class Rectangle //implementation
{
}


# constructor
- constructor, this is a special kind of method used to construct or instantiate the object, always has the same name as the class does not have a return type

class Rectangle
{
	public:
		Rectangle();
};
Rectangle::Rectangle()
{
}

- constructor overloading
- this keyword, inside the constructor, as well as in other methods belonging to the object, so called instance methods, a special keyword called this can be used

Rectangle::Rectangle(int x, int y)
{
	this->x = x;
	this->y = y;
}

- constructor initialization list, assigning fields inside the constructor, they may also be assigned by using the constructor initialization list
Rectangle::Rectangle(int x, int y):x(x), y(y) {}
this will give better performance than initialize inside the constructor

- default constructor
- destructor, a class can also have a destructor, the destructor is used to release any resources allocated by the object
class Semaphore
{
	public:
		bool *sem;
		Semaphore() {}
		~Semaphore() {}
};

a class only have one destructor and it never takes any arguments or return anything

- direct initialization
Rectangle(5, 10);

- value initialization, creates only a temporary object which is destroyed at the end of the statement, it must copied to another object or assigned to a constant reference, this will maintain the object until that reference goes out of scope
const MyClass& a = MyClass();

- copy initialization, an existing object is assigned to an object of the same type when it is declared, the new object will be copy initialized
MyClass a = MyClass(); //copy initialization

this behavior is different in java and c#, in those languages initializing an object with another object will only copy the object's reference and not create a new object copy

- new initialization, an object can be initialized through dynamic memory allocation by using the new keyword, must be used through a pointer or reference, keep in mind that dynamically allocated memory must be explicitly free once it is no longer needed
MyClass* a = new MyClass();
MyClass& b = new *MyClass();
delete a, b;


# inheritance
- inheritance allows a class to acquire the members of another class, inheritance allows a class to acquire the members of another class. child gains all accessible members in parent except for its constructor and destructor
class Rectangle
{
	
}
class Square : public Rectangle {};

- upcasting, an object can be upcast to its base class, because it contains everything that the base calss contains
Square s;
Rectangle& r = s; //reference upcast
Rectangle* p = &s; //pointer upcast

- downcasting, a rectangle reference that points to a square object can be downcast back to a square object. This downcast has to be made explicit
Square& a = (Square&) r; //reference downcast
Square& p = (Square&) *p; //pointer downcast

- multiple inheritance, cpp allows a derived class to inherit from more than one base class
class Person {}
class Employee {}
class Teacher: public Person, public Employee {}

multiple inheritance is not commonly used since most real-world relationships can be better described by single inheritance
multiple inheritance will also increase the complexity of the code


# overriding
- a new method in a derived class can redefine a method in a class in order to give it a new implementation
- hiding derived members, redeclared a parent method with same signature
	+ function signature include
		* name
		* parameter list
		* return type of the method

	+ example
	class Rectangle
	{
		public:
			int x, y;
			int getArea() { return x * y; }
	};
	class Triangle : public Rectangle
	{
		public:
			Triangle(int a, int b) { x = a; y = b; }
			int getArea() { return x * y / 2; }
	};

	if a triangle object is created and the getArea is invoked, then the triangle's version of the method will be called

	however if the object upcast to a rectangle then the rectangle's version will get called 
- overriding derived members, inorder to redefine a method upwards in the class hierarchy, what is called overriding the method, the method need to define with the keyword virtual modifier in the base class, this modifier allows the method to be overridden in derived classes
class Rectangle
{
	public:
		int x, y;
		virtual int getArea() {return x*y;}
}
class Triangle : public Rectangle
{
	public:
		Triangle(int a, int b) { x = a; y = b; }
		int getArea() { return x * y / 2; }
};
Triangle t = Triangle(10, 20);
Rectangle&r = t;
r.getArea(); // calls triangle's version

- base class scoping, it is still possible to access a redefined method from a derived class by typing in the class name followed by the scope resolution operator. This is called base class scoping and can be used to allow access to redefined methods that are any number of levels deep in the class hierarchy.
class Triangle:public Retangle
{
	public:
		Triangle(int a, int b) {}
		int getArea(return Rectangle::getArea() / 2;)
}

- calling base class constructor, in cpp constructors in derived class will implicitly call the parameterless base class constructor, to call another constructor to call another constructor will need explicitly invoked at the derived constructor's initialization list

class Triangle:public Rectangle
{
	public:
		Triangle(int a, int b): Rectangle(a, b){}
} 


# access levels
- there are three available in cpp, public, protected and private, the default level is private
	+ public, unrestricted
	+ protected, derived and defining only
	+ private, defining only
- access level guideline, choosing an access level generally best to most restrictive level possible
- friend classes and functions, a class can be allowed to access the private and protected members of another class by declaring the class a friend, by using friend modifier

class myClass
{
	int myPrivate;
	friend class OtherClass;
};
class OtherClass
{
	viod test(myClass c){ c.myPrivate = 0;}
};

- public protected and private inheritance, inherited in cpp is possible to change the access level 


# static
- static keyword is used to create class members that exist in only one copy, which is belongs to the class itself.
- static field, cannot be initialized inside the class like an instance field, must be defined outside the class declaration, the static field will then remain initialized throughout the life of the application
class myClass
{
	public:
		static double pi;
}

double myClass::pi = 3.14;

- static methods, method should therefore only be declared static if they perform a generic function that is independent of any instance variables
instance method could use both static and instance methods

class MyCircle
{
	public:
		double r; // instance variable (one per object)
		static double pi; // static variable (only one copy)
		double getArea() { return pi * r * r; }
		static double newArea(double a) { return pi * a * a; }
};

- static local variables, local variable inside a function can be declared as static make the function remember the variable. a static local variable is only initialized once
int myFunc()
{
	static int count = 0;//holds of call to function
	count ++;
}

- static global variables, this will limit the accessibility of the variable to only the current source file, and can therefore be used to help avoid naming conflicts
static int myGlobal; //only visible in current source file


# enum
- enum is a user-defined type consisting of a fixed list of named constant
enum Color {
Red, 
Green = 2, 
Blue = Green+1};

then the color type can be used to create variables that may hold one of these constant values
int main()
{
	Color c = Red;
}
- enum constant values, default values can be overridden by assigning values to the constants
- enum conversion, compiler can implicit convert an enumeration constant to an integer, but convert a int to enum need explicit convertion
int i = Red;
Color c = (Color)i;
- enum scope, an enum does not have to be declared globally. it can also be placed within a class or a function

class MyClass
{
	enum Color { Red, Green, Blue };
};

void myFunction()
{
	enum Color { Red, Green, Blue };
}


# struct and union
- struct is equivalent to a class, except that members of a struct default to public access
struct Point
{
	int x, y; // public
};
class Point
{
	int x, y; // private
};

- declarator list
Point p, q; // object declarations

struct Point
{
int x, y;
} r, s; // object declarations

- aggregate initialization,  This allows programmers to set fields by using a brace-enclosed comma-separated list of initializer-clauses. Aggregate initialization can only be used when the class type does not include any constructors, virtual functions or base classes.

struct Point {
	int x, y;
} r = { 2, 3 }; // set values of x and y

- union, similar to struct, the union type is different in that all fields share the same memory position. the size of a union is the size of largest field it contains

union Mix
{
	char c; // 1 byte
	short s; // 2 bytes
	int i; // 4 bytes
}m;
this means union type can only be used to store one value at a time
m.c = 0xFF;
m.s = 0;

union provides multiple ways of viewing the same memory location. 

use union allow access to the same group of 4 bytes in multiple ways
union Mix
{
	char c[4];				  // 4 bytes
	struct { short hi, lo; } s; // 4 bytes
	int i;					  // 4 bytes
} m;

- anonymous union, can be declared without a name, unnamed object whose members can be accessed directly from the scope where it is declared. An anonymous union cannot contain methods or non-public members.

int main()
{
	union {short s;}; //defines an unnamed union object
	
	s = 15;
}

An anonymous union that is declared globally must be made static.
static union {};


# operation overloading
- operator overloading allows operators to be redefined and used where one or both of the operands are of a user-defined class. binary operator overloading, the binary operator expect return a copy of the result.
class MyNum
{
	public:
		int val;
		MyNum(int i) : val(i) {}
		MyNum add(MyNum &a)  { return MyNum( val + a.val ); }
		MyNum operator + (MyNum &a) { return MyNum( val + a.val ); }
}

the operator is only an alternative syntax for calling the actual method.
MyNum d = a.operator + (b);

- unary operator overloading, expect return a reference of the original argument

MyNum& operator++() // ++ prefix
{ ++val; return *this; }

The two postfix operators – post-increment and post-decrement – should instead return by value

MyNum operator++(int) // postfix ++
{
	MyNum t = MyNum(val);
	++val;
	return t;
}

- over loadable operators
	+ binary operators
	;   +  -  *  /  %
	;   =  +=  -=  *=  /=  %=
	;   &=  ^=  |=  <<=  >>=
	;   ==  !=  >  <  >=  <=
	;   &  |  ^  <<  >>  &&  ||
	;   ->  ->*
	
	+ unary operators
	+  -  !  ~  &  *  ++ --
	[] ()  delete  new 
	
- not over loadable
.  .*  :: ?:  #  ## sizeof
  

  
# custom conversions
- custom type conversion is possible to allow integer types to implicit converted to this object's type
class MyNum
{
	public:
		int value;
};

- implicit conversion methods, added that takes a single parameter of the desired type
class MyNum
{
	public:
		int value;
		MyNum(int i) { value = i; }
};

MyNum A = 5; // implicit conversion
MyNum D = 'H'; // implicit conversion (char->int->MyNum)

- explicit conversion methods, To help prevent potentially unintended object type conversions it is possible to disable the second use of the single parameter constructor. by use a explicit keyword

class MyNum
{
	public:
		int value;
		explicit MyNum(int i) { value = i; }
};

MyNum A = 5; // error
MyNum B(5); // allowed


# Namespaces
- namespaces are used to avoid naming conflicts by allowing entities such as classes and functions to be grouped under a seperate scope

class Table {};
class Table {}; // error: class type redefinition

to resolve this one way is rename a class or wrap them into different namespaces

namespace furniture
{
	class Table {};
}
namespace html
{
	class Table {};
}

- accessing namespace members, use fully qualified name
int main()
{
	furniture::Table fTable;
	html::Table hTable;
}

- nesting namespaces, it is possible to nest namespaces any number of levels deep to further structure

namespace furniture
{
	namespace wood { class Table {}; }
}

reference the table entity
furniture::wood::Table fTable;

- importing namespaces, to avoid specify the namespace everytime, the namespace can be imported into the global or localscope

using namespace html; // global namespace import
int main()
{
	using namespace html; // local namespace import
}

Keep in mind that importing a namespace into the global scope defeats the main 
purpose of using namespaces, which is to avoid naming conflicts

- namespace member import, only import the specific members that are needed from the namespace

using html::Table; // import a single namespace member

- namespace alias, shorten the fully qualifiedname is to create a namespace alias

namespace myAlias = furniture::wood; // namespace alias

then could use  myAlias to reference the namespace
myAlias::Table fTable;

namespace import and alias could be declared both globally and locally

alias are also could be create for types, is used the typedef keyword
typedef my::name::MyClass MyType;

use the type alias
MyType t;

typedef are also work for user-defined type
typedef struct { int len; } Length;
Length a, b, c;

- including namespace memebers, Keep in mind that in C++ merely importing a namespace does not provide access to the members included in that namespace.

// Include input/output prototypes
#include <iostream>
// Import standard library namespace to global scope
using namespace std;


# constants
- A constant is a variable that has a value which cannot be changed once the constant has been assigned.

- constant variables, adding the const keyword
const int var = 5;
int const var2 = 10; // alternative order

- constant pointers, const can be used in two ways
	+ the pointer can be made constant, means that it cannot be changed to point to another location
	int var;
	int* const p = &var; // pointer constant
	
	+ the pointee can be declared constant, means that the variable pointed to cannot be modified through this pointer
	const int* q = &var; //pointee constant

	+ it is possible to declare the both
	const int* const p = &var; // pointer & pointee constant

	constant variable may not be pointed to by a non-constant pointer
	int *s = &var; // error: const to non-const assignment

- const references, because the reference reseating is never allowed, there is only one way
const int& y = var; //reference constant

- constant objects, A constant object of this class cannot be reassigned to another instance. 
class MyClass
{
	public:
		int x;
		void setX(int a) { x = a; }
};

const MyClass a, b;
a = b; // error: object is const
a.x = 10; // error: object field is const

- constant methods, a constant object may not call a non-constant method since such methods are allowed to change the object's fields
a.setX(2); // error: cannot call non-const method

mark the method with const 
int getX() const { return x; } // constant method

This const modifier means that the method is not allowed to modify the state of the object and can therefore safely be called by a constant object of the class. 

- constant return type and parameters, In addition to making a method constant, the return type and method parameters may also be made read-only.
mark return type are also constant
const int& getX() const { return x; }

- constant fields, both static and instance field in a class can be declared constant, a constant instance field must be assigned its value using the constructor initialization list
class MyClass
{
	public:
		int i;
		const int c;
		MyClass() : c(5), i(5) {}
}

A constant static field on the other hand must be defined outside of the class 
declaration
The exception to this is when the constant static field is of an integer data type. Such a field may also be initialized within the class at the same time as the field is declared.

class MyClass
{
	public:
		static int si;
		const static double csd;
		const static int csi = 5;
};
int MyClass::si = 1.23;
const double MyClass::csd = 1.23;

- constant guideline, if a variable is not need to modified, declare it as constant


# preprocessor
- The preprocessor is a program invoked by the compiler that modifies the source code before the actual compilation takes place. The preprocessing directive must start with a hash sign(#) as the first non-whitespace character on a line
Directive   Description	
#include	File include
#define	 Macro definition
#undef	  Macro undefine
#ifdef	  If macro defined
#ifndef	 If macro not defined
#if		 If
#elif	   Else if
#else	   Else
#endif	  End if
#line	   Set line number
#error	  Abort compilation
#pragma	 Set compiler option

- including source files, inserts the content of a file into the current source file 
	+ if the filename is enclosed between angle brackets, the compiler will search for the file in the default directory
	#include <iostream> //search default directory

	+ if the filename is specified between double-quotes, the compiler will first search for the file in the same directory as the source file
	#include "myFile"

	can also specify absolute or relative path
	#include "c:\myfile" //absolute
	#include "..\myfile"

- defining macros, the name of the macro is specified followed by what it will be replaced by.
#define MACRO 0 // macro definition

int x = MACRO; // x = 0
By convention, macros should be named in uppercase letters with each word separated by an underscore

- undefining marcos, to redefine or change a macro, it need to be undefine first
#undef MARCO // marco undefined
#undef MACRO // allowed

- macro functions, A macro can be made to take arguments. 
#define MAX(a,b) a>b ? a:b

- line break, define a macro in seeral lines, there must be not be any whitespace after the backslash
#define MAX(a,b) \
		a>b ? \
		a:b

- avoid using macros,  #definedirectives can be powerful, they tend to make the code more difficult to read and debug. 
there are some equavalent method to accomplish the same goal compare to macro
#define DEBUG 0
const bool DEBUG = 0;

#define FORWARD 1
#define STOP 0
#define BACKWARD -1
enum DIR { FORWARD = 1, STOP = 0, BACKWARD = -1 };

#define MAX(a,b) a>b ? a:b
inline int MAX(int a, int b) { return a>b ? a:b; }

- conditional compilation directives, can include or exclude part of the source code if a certain condition is met
#define DEBUG_LEVEL 3
#if DEBUG_LEVEL > 2
// ...
#elif DEBUG_LEVEL == 2
// ...
#else
// ...
#endif


- compile if defined, a section of code should only be compiled if a certain macro has been defined
#define DEBUG
#if defined DEBUG
// ...
#elif !defined DEBUG
// ...
#endif

Note that a macro is considered defined even if it has not been given a value.

The same effect can also be achieved using the directives #ifdefand #ifndef
#ifdef DEBUG
// ...
#endif
#ifndef DEBUG
// ...
#endif

- error directive, #error directive is encountered the compilation is aborted This directive can be useful for example to determine whether or not a certain line of code is being compiled. optionally take a parameter that specifies the description
#error Compilation aborted

- line directive, is used to change the line number. The directive can 
take an optional string parameter
#line 5 "My MyApp Error"

- pragma directive, is used to specify options to the compiler
	+ #pragma messagecan be used to have the compiler output a string to the build window.
	// Show compiler message
	#pragma message( "Hello Compiler" )
	
	+ Another argument for this directive is warning, changes how the compiler handles warnings
	// Disable warning 4507
	#pragma warning(disable : 4507)


# exception handling
- exception handling allows programmer to deal with unexpected situations
- throwing exceptions, using the throw keyword
int divide(int x, int y)
{
	if (y == 0) throw 0;
	return x / y;
}

- try-catch statement, one or more catch clauses to handle them
try {
	divide(10,0);
}
catch(int& e) {
	std::cout << "Error code: " << e;
}
An exception handler can catch a thrown expression by either value, reference or 
pointer. However, catching by value should be avoided since this causes an extra copy to be made.
To catch all types of exceptions an ellipsis (...) can be used as the parameter of 
catch. 
catch(...) { std::cout << "Error"; }

- re-throwing exceptions, If an exception handler is not able to recover from an exception it can be re-thrown by using the throw keyword with no argument specified.
int main()
{
	try {
		try { throw 0; }
		catch(...) { throw; } // re-throw exception
	}
	catch(...){
		throw; 
	} // run-time error
}

- exception specification, Functions are by default allowed to throw exceptions of any type. To specify the exception types that a function may throw. The throw keyword can be appended to the function declaration. it is followed by a comma separated list of the allowed types
void error1() {} // may throw any exceptions
void error2() throw(...) {} // may throw any exceptions
void error3() throw(int) {} // may only throw int
void error4() throw() {} // may not throw exceptions

it's rare to specify exceptions in c++, the compiler will not enforce the specified exception in any way or make any optimizations

- exception class, although any type can throw in c++, how ever the standard library does provide a base class called exception

#include <exception>
void make_error()
{
	throw std::exception("My Error Description");
}

# type conversions
- converting an expression from one type to another is known as type-conversion
- implicit conversions, is performed automatically by the compiler 
long a = 5; // int implicitly converted to long
double b = a; // long implicitly converted to double

implicit primitive conversions can be further grouped into two kinds, promotion and demotion, demotion can result in the loss of information, the warning can be suppressed by using an explicit cast
// Promotion
long a = 5; // int promoted to long
double b = a; // long promoted to double

// Demotion
int c = 10.5; // warning: possible loss of data
bool d = c; // warning: possible loss of data

- explicit conversions
	+ c-style cast
	int c = (int)10.5; // double demoted to int
	char d = (char)c; // int demoted to char

	c-style case is too powerful when it used to conversions classes and pointers, c++ introduced four new casts, these will help compiler to catch conversion error
	+ static_cast<new_type>(expression), conversons between compatible types, similar to c-type but more restrictive
	char c = 10; // 1 byte
	int *p = (int*)&c; // 4 bytes, a 4-byte pointer pointing to 1 byte of allocated memory, writing to this pointer will either cause a run-time error or will overwrite some adjacent memory
	
	static cast will allow the compiler to check that the pointer and pointee data types are compatible
	int *q = static_cast<int*>(&c); // compile-time error
	
	+ reinterpret_cast<new_type>(expression), to force the pointer conversion it like c-style cast does in the background
	int *r = reinterpret_cast<int*>(&c); // forced conversion
	this is a low-level operation and is system-specific, it is not portable
	
	+ const_cast<new_type>(expression), this is primarily used to add or remove the const modifier of a variable
	const int myConst = 5;
	int* nonConst = const_cast<int*>(&a); // removes const
	
	change the converted const variable still may cause run-time error, if the const was located in a section of read-only memory
	*nonConst = 10; // potential run-time error
	
	this conversion is mainly used in a function that takes a non-constant pointer argument, even though it does not modify the pointee
	void print(int *p) { std::cout << *p; }
	print(&myConst); // error: cannot convert
	// const int* to int*
	print(nonConst); // allowed
	
	+ dynamic_cast<new_type>(expression), is only used to convert object pointers and object references into other pointer or reference types in the inheritance, it is the only cast that makes sure that the object pointed to can be converted by performing a run-time check, the object must be polymorphic, that is the class must define or inherit at least one virtual function
	class MyBase { public: virtual void test() {} };
	class MyChild : public MyBase {};
	
	MyChild *child = new MyChild();
	MyBase *base = dynamic_cast<MyBase*>(child); // ok
	MyBase *base = new MyBase();
	MyChild *child = dynamic_cast<MyChild*>(base);
	if (child == 0) std::cout << "Null pointer returned";

	If a reference is converted instead of a pointer, the dynamic cast will then fail by throwing a bad_castexception
	#include <exception>
	// ...
	try { MyChild &child = dynamic_cast<MyChild&>(*base); }
	catch(std::bad_cast &e)
	{
		std::cout << e.what(); // bad dynamic_cast
	}
- dynamic or static cast, dynamic cast is required run-time check, If the base-to-derived conversion had been performed using a static cast instead of 
a dynamic cast the conversion would not have failed. It would have returned a pointer that referred to an incomplete object.


# templates
- templates provide a way to make a class or function operate with different data types without having to rewrite the code for each type
void swap(int& a, int& b)
{
	int tmp = a;
	a = b;
	b = tmp;
}
add a template parameter declarationbefore the function. This declaration includes the templatekeyword followed by the keyword classand the name of the template parameter
template<class T>

Alternatively, the keyword typenamecan be used instead of class. They are both equivalent in this context.
template<typename T>

template<class T>
void swap(T& a, T& b)
{
	T tmp = a;
	a = b;
	b = tmp;
}

int a = 1, b = 2;
swap<int>(a,b); // calls int version of swap
swap(a,b); // calls int version of swap, compiler automatic supply the type

- multiple template parameters
template<class T, class U>
void swap(T& a, U& b)
{
	T tmp = a;
	a = b;
	b = tmp;
}

- class template, allow class members to use template parameters as types. they are created in the same way as function templates
template<class T>
class myBox
{
	public:
		T a, b;
};

class template must always instantiated with explicit specified template parameters
myBox<int> box;

if a method is defined outside of the class template that definition must also be preceded by the template declaration.
template<class T>
class myBox
{
	public:
	T a, b;
	void swap();
};

template<class T>
void myBox<T>::swap()
{
	T tmp = a;
	a = b;
	b = tmp;
}

- non-type parameters, function or class can define mixed with template parameter and regular parameter
template<class T, int N>
class myBox
{
	public:
		T store[N];
};

myBox<int, 5> box;

- default types and values, parameters can be given default values and types
template<class T = int, int N = 5>
to use the default types by 
myBox<> box;

default template parameters may not be used in function templates.

- class template specialization, Instead, a boolspecialization parameter is placed after the class template’s name and this data type
#include <iostream>
template<class T>
class myBox
{
	public:
		T a;
		void print() { std::cout << a; }
};

template<>
class myBox<bool>
{
	public:
		bool a;
		void print() { std::cout << (a ? "true" : "false"); }
};

Note that there is no inheritance of members from the standard template to the specialized template. The whole class will have to be redefined.

- function template specialization, looks like class specialization
#include <iostream>
template<class T>
class myBox
{
	public:
		T a;
		template<class T> void print() {
			std::cout << a;
		}
		template<> void print<bool>() {
			std::cout << (a ? "true" : "false");
		}
};

in this way, only the function need to redefine, not the whole class

myBox<bool> box = { true };
box.print<bool>(); // true

template parameter has to be specified when the specialized function is invoked. 


# headers
- when a project grows it common to split code up into different source files, interface and implementation are generally separated. interface is placed in the header file

- why to use headers, c++ requires everything to be declared before it can be used, if a function define in a source file and another function in other source file want to use the previous function, the compiler will report cannot find the function
// MyFunc.c
void myFunc()
{
// ...
}
// MyApp.c
int main()
{
	myFunc(); // error: myFunc identifier not found
}

to make it works the function’s prototype has to be included in MyApp.c.

- using headers
// MyFunc.h
void myFunc(); // prototype
// MyApp.c
#include "MyFunc.h"

- what to include in headers, the compiler is concerned there is no difference between a header file and a source file. 
the key idea is that the header should contain the interface of the implementation file
// MyApp.h - Interface
#define PI 3.14
const double E = 2.72;

if a shared class member function or global function is declared as inline should define in the header, or call them will get a unresolved external error

shared template should be define in the header include the declare and implementation. Since templates are not compiled until they are required
template<class T>
void templateFunction()
{
// ...
}

- include guards, to prevent a header file been include multiple times #ifndef section that checks for a macro specific to that header file.

// MyApp.h
#ifndef MYAPP
#define MYAPP
// ...
#endif



# c++11, new feature references
- blog
http://www.bogotobogo.com/index.php



























