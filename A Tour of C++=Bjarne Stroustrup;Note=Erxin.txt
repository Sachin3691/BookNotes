A Tour of C++=Bjarne Stroustrup;Note=Erxin

# User defined types 
- declaration is a statement that introduces an entity into the program 
A type defines a set of possible values and a set of operations (for an object).
 
An object is some memory that holds a value of some type.

A value is a set of bits interpreted according to a type.

A variable is a named object.

- bool, char, int, double 
int, 4 bytes 
double, 8 bytes 

- single quote (') as a digit separator. For example, π is about 3.14159'26535'89793
- logic 
x&y      // bitwise and
x|y      // bitwise or
x^y      // bitwise exclusive or
~x       // bitwise complement
x&&y     // logical and
x||y     // logical or
!x       // logical not (negation)

- initialization 
complex<double> z = 1;
complex<double> z2 {1.0, -2.0};

The = form is traditional and dates back to C, but if in doubt, use the general {}-list form.

- We use auto where we don’t have a specific reason to mention the type explicitly.

- scope and lifetime 
    + local scope 
    + class scope 
    + namespace scope 

- constants 
    + const, the value of a const can be calculated at runtime and promise not to change 
    + constexpr, evaluated at compile time. The value of a constexpr must be calculated by the compiler 
    
- C++ also offers a simpler for-statement, called a range-for-statement

for (auto x : {10,21,32,43,54,65})           
    cout << x << '\n';

- There is only one nullptr shared by all pointer types

- The advice here is a subset of the C++ Core Guidelines

    + Don’t use the built-in features exclusively or on their own. On the contrary, the fundamental (built-in) features are usually best used indirectly through libraries, such as the ISO C++ standard library

    + Focus on programming techniques, not on language features
    
    + You don’t have to know every detail of C++ to write good programs

    + A function should perform a single logical operation 
    
    + keep function short 
    
    + evaluated at compile time, declare it constexpr
    
    + Minimize the scope of a variable
    
    + Keep common and local names short, and keep uncommon and nonlocal names longer
    
    + Avoid similar-looking names; 
    
    + Avoid ALL_CAPS names
    
    + Prefer the {}-initializer syntax for declarations with a named type; 
    
    + Use unsigned for bit manipulation only
    
    + Use nullptr rather than 0 or NULL
    
    + Don’t declare a variable until you have a value to initialize it with
    
    + Don’t say in comments what can be clearly stated in code; 


# User defined types
- Structures 
struct name{
    type field_name;
};

- classes, public private and default private 
class name{
    type field_name;
};

- union is a struct in which all members are allocated at the same address 
union name{
    type field0;
    type field1;
};

- enumerations, ser-defined type for which we can enumerate the values:
enum class Color { red, blue, green };
enum class Traffic_light { green, yellow, red };

Color col = Color::red;
Traffic_light light = Traffic_light::red;

    + init value 
Color x = Color{5};  // OK, but verboseColor 
y {6};         // also OK

    + The “plain” enums have been in C++ (and C) since the earliest days
    
- advice 
    + Represent the distinction between an interface and an implementation using a class
    
    + A struct is simply a class with its members public by default;
    
    + Avoid “naked” unions; wrap them in a class together with a type field
    
    + Use enumerations to represent sets of named constants; 
    
    + prefer class enums over plain enums 
    
    + define operations on enumerations for safe and simple use 
    

# Modularity 
-     
    
    
    
    
    
    
    
    
    
    
    

