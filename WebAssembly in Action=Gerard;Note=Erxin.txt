WebAssembly in Action=Gerard;Note=Erxin

# Introduction 
- design a performance test cases for 
    + other implmentations 
    http://hildstrom.com/projects/langcomp/index.html
    https://github.com/kostya/benchmarks
    https://attractivechaos.github.io/plb/
    
    koch curve ?
    
    check prime number?
    
    

- live book discussion 

https://livebook.manning.com/#!/book/webassembly-in-action/discussion

- the languages support to compile to webassembly 

https://github.com/appcypher/awesome-wasm-langs

- author

http://blogger.com/

http://dzone.com/

- other 
https://medium.com/@mikevdg/why-webassembly-is-a-big-deal-a308d72c6de1

- improve your mobile site to boost your business 

https://www.thinkwithgoogle.com/intl/en-gb/feature/testmysite/


# First step 
- what is webassembly 
function AsmModule() {
  "use asm";                 1
  return {
    add: function(a, b) {
      a = a | 0;             2
      b = b | 0;
      return (a + b) | 0;    3
    }
  }
}

- WebAssembly is a low-level assembly-like language that can run at near-native speeds in all modern desktop browsers 

- can be written in cpp, rust, go typescript etc. 

- fast start up speed compare to js 

- compile process 
{c/cpp/rust/...} > IR  > .wasm 

- basic webassembly file structure 
preamble //header, all other sections are optional 
type 
import 
function 
table 
memory 
global 
export 
start 
element 
code 
data 
any kind of data //custom sections, optional 

- WebAssembly is secure is that it’s the first language to ever share the JavaScript VM, which is sandboxed from the runtime and has had years of hardening and security tests to make it secure. 

https://webassembly.org/docs/security


# Look inside webassembly modules 
- The Import section declares all the imports that will be used in the module, which can include Function, Table, Memory, or Global imports.                  Imports are designed so that modules can share code and data, but still allow for the modules to be compiled and cached separately

- The Function section is a list of all the functions in the module. The position of the function declaration in this list represents the                  index of the function body in the Code section. 

- The Table section holds a typed array of references, like functions, that can’t be stored in the module’s linear memory as raw bytes.                  This section provides one of the core security aspects of WebAssembly by giving the WebAssembly framework a way to map objects                  in a secure way.

- memory, The Memory section holds the linear memory used by the module instance.                                          

- global section for the definition of global variables 
- The Export section holds a list of all objects that will get returned to the host environment once the module has been instantiated. include function, table, memory or global exports 
- The Start section declares the index of the function that’s to be called after the module has been initialized but before the export section are callable 
- Element declares the data that get loaded into the module's table section during instantiation 
- Code holds the body of each function 
- Data declares the data that gets loaded into the module's linear memory 
- custom section 


# Creating your first webassembly module 
- The Emscripten toolkit is currently the most mature toolkit available to compile C or C++ code into WebAssembly bytecode.

    + setup env window 
$ git clone https://github.com/emscripten-core/emsdk.git
$ cd emsdk
$ emsdk install latest
$ emsdk activate latest
$ emsdk_env.bat

    + updating sdk 
$ emsdk update 
$ emsdk install latest 
$ emsdk active latest 
$ emsdk_env.bat

    + using docker image 
$ docker run --rm -v $(pwd):/src -u $(id -u):$(id -g) \ 
    emscripten/emsdk emcc helloworld.cpp -o helloworld.js

    + reference 
    https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm
    https://developer.mozilla.org/en-US/docs/WebAssembly/existing_C_to_wasm
    
    + example 
#include <stdlib.h>
#include <stdio.h>
#include <emscripten.h>
    
    
int IsPrime(int value) {
  if (value == 2) { return 1; }                      1
  if (value <= 1 || value % 2 == 0) { return 0; }    2

  for (int i = 3; (i * i) <= value; i += 2) {        3
    if (value % i == 0) { return 0; }                4
  }

  return 1;                                          5
}

$ emcc calculate_primes.c -o html_template.html

//generated html 
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
  </head>
  <body>
    HTML page I created for my WebAssembly module.

    <script src="js_plumbing.js"></script>          1
  </body>
</html>

    + other options 
    https://emscripten.org/docs/optimizing/Optimizing-Code.html
    
    + specify only one function in the EXPORTED_FUNCTIONS command-line array. If you need to specify multiple functions, don’t include a space in between the comma and the next function,         or you’ll receive a compilation error.
    
    + The WebAssembly.instantiateStreaming() function compiles and instantiates a WebAssembly module directly from a streamed underlying source. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming
    
var importObject = { imports: { imported_func: arg => console.log(arg) } };

WebAssembly.instantiateStreaming(fetch('simple.wasm'), importObject)
.then(obj => obj.instance.exports.exported_func());


    

- intermediate representation (IR), and a backend to convert the IR into the desired machine code

{c/cpp/rust} => {IR} => {x86, ARM}

 Emscripten uses the LLVM compiler

- typescript -> webassembly

https://www.assemblyscript.org/

    + setup environment 
npm install --save @assemblyscript/loader
npm install --save-dev assemblyscript

npx asinit .

npm run asbuild

- rust to webassembly
    + reference 
    https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm

- go to webassembly 
    + reference 
    https://github.com/golang/go/wiki/WebAssembly#getting-started


# Workign with modules 
- Emscripten provides a number of helper functions that make interactions between the module and JavaScript 


# Creating a webassembly module that calls into javascript 
- example 

int ValidateCategory(char* category_id, int* valid_category_ids,
    int array_length) {                                             1
  if (ValidateValueProvided(category_id,
      "A Product Category must be selected.") == 0) {               1
    return 0;
  }

  if ((valid_category_ids == NULL) || (array_length == 0)) {
    UpdateHostAboutError("There are no Product Categories available.");
    return 0;
  }

  if (IsCategoryIdInArray(category_id, valid_category_ids,
      array_length) == 0) {
    UpdateHostAboutError("The selected Product Category is not valid.");
    return 0;
  }

  return 1;
}

mergeInto(LibraryManager.library, {                               1
  UpdateHostAboutError: function(errorMessagePointer) {
    setErrorMessage(Module.UTF8ToString(errorMessagePointer));
  }
});

$ emcc validate.cpp --js-library mergeinto.js

function onClickSave() {
  setErrorMessage("");                                 1

  const name = document.getElementById("name").value;
  const categoryId = getSelectedCategoryId();

  if (validateName(name) &&                            2
      validateCategory(categoryId)) {                  3
                                                       4
  }
}

function validateName(name) {                     1
  const isValid = Module.ccall('ValidateName',
      'number',
      ['string', 'number'],                       2
      [name, MAXIMUM_NAME_LENGTH]);               3

  return (isValid === 1);
}

- creating a webassembly module that talks to javascript using function pointers 

    + Using a function pointer given to the module by JavaScript

void(*UpdateHostOnSuccess)(void);

#ifdef __EMSCRIPTEN__
  EMSCRIPTEN_KEEPALIVE
#endif
void ValidateName(char* name, int maximum_length,                 1
    OnSuccess UpdateHostOnSuccess, OnError UpdateHostOnError) {   2
  if (ValidateValueProvided(name) == 0) {
    UpdateHostOnError("A Product Name must be provided.");
  }
  else if (strlen(name) > maximum_length) {
    UpdateHostOnError("The Product Name is too long.");
  }
  else {
    UpdateHostOnSuccess();
  }
}

#ifdef __EMSCRIPTEN__
  EMSCRIPTEN_KEEPALIVE
#endif
void ValidateCategory(char* category_id, int* valid_category_ids,   1
    int array_length, OnSuccess UpdateHostOnSuccess,
    OnError UpdateHostOnError) {                                    2
  if (ValidateValueProvided(category_id) == 0) {
    UpdateHostOnError("A Product Category must be selected.");
  }
  else if ((valid_category_ids == NULL) || (array_length == 0)) {
    UpdateHostOnError("There are no Product Categories available.");
  }
  else if (IsCategoryIdInArray(category_id, valid_category_ids,
      array_length) == 0) {
    UpdateHostOnError("The selected Product Category is not valid.");
  }
  else {
    UpdateHostOnSuccess();
  }
}

$ emcc validate.cpp -s RESERVED_FUNCTION_POINTERS=4
 -s EXTRA_EXPORTED_RUNTIME_METHODS=['ccall','UTF8ToString',
'addFunction','removeFunction'] -o validate.js


# Advanced topics 
- how dynamic linking works for webasssemlby modules 
- Your C or C++ code can manually link to a module by using the dlopen function.
- JavaScript, you can manually take the exports of one module and pass them in as imports to another using the WebAssembly JavaScript API.

- reference 
https://emscripten.org/docs/api_reference/Filesystem-API.html

- debug webasssembly in chrome 
https://developers.google.com/web/updates/2019/12/webassembly
https://hacks.mozilla.org/2019/09/debugging-webassembly-outside-of-the-browser/

- webassembly binary toolkit 
https://github.com/WebAssembly/wabt#running-wasm2wat

- decompile webassembly 
https://v8.dev/blog/wasm-decompile

