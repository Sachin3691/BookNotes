Windows Kernel Debugging Fundamentals=Bruce MackenzieLow;Note=Erxin

# introduction to windows crashs and hangs 
- introduction 
    + why learn windows kernel debugging 
    + debugging crashes verses hangs 
    + common culprits 
    + how memory dumps are created 
    + types of memory dumps 
    + configuring memory dump settings 
    + dedicated dump file 
    + restrictions and gotchas 
    
- kernel debugging skills 
    + driver developers 
    debugging your own code 
    debugging someone else's code 
    
    + IP professionals 
    minimize downtime 
    identify suspect driver 
    
- crash dump analysis, interpreting the contents of RAM to determine why a system is failed. 

    + MS tool for help generate system failure in a variety of ways 
    NotMyFault
    
- windows crashes and hangs 
    + crashses are unexpected, unhandled exceptions that occur in kernel mode 
    
    + the state of operating system becomes questionable 
    
    + the operating system stops to avoid corrupting data 
    
    + also known as the blue screen of death (BSOD) stops and bugchecks 
    
    + the contents of RAM is saved in a file called memory.dmp 
    
- windows system hangs 
    + hangs occur when processors or peripheral devices unresponsive and freezed 
    
    + software induced hangs include 
    depleted system resources(memory pool)
    runaway high priority compute-bound threads 
    synchronization mechanisms (deallocks & spinlocks)
    
    
    + hardware originated hangs include 
    faulty devices causing false interrupts 
    failing processors 
    corrupted RAM 
    
    + memory dump must be manually forced generated on a hung system 
    
- common culprits for crashes 
    + the big reasons are old antivirus software. it is not fully tested on the new OS 
    
    + new drivers 
    Storport(over 50 hotfixes in windows 2003), https://docs.microsoft.com/en-us/windows-hardware/drivers/storage/storport-driver
    
    MPIO(over a dozen hotfixes in windows 2008)
    
    + incompatible drivers 
    old Storport driver with a new miniport driver 
    
    + too many filter drivers 
    antivirus deduplication, disk quota, mirroring 
    
    + memory corruption 
    + hardware failures 
    + operating system bugs 
- Common culprits for hangs 
    + depleted system resources (memory pool). limited resource cause system to hang 
    
    + broken applications with deadlocks or spinlock hangs. 
    
    + high priority compute-bound(runaway) applications 
    
    + old antivirus software 
    
    + new drivers 
    
    + incompatible drivers 
    
    + broken hardware
    
- determining driver dependencies 
    + use dependency walker(depends.exe)
    http://www.dependencywalker.com 
    
    + opening a driver QL2300.SYS. will display the dependency 
    
- How memory dumps are created 
    + crash or hang, content of RAM is writen to Pagefile.sys* 
    
    on reboot the pagefiles.sys* -> memory.dmp 
    
    analyze crash with windbg 
    
    + In window 2008/vista later, a dedicated dump files can be used instead of the page file on any local disk. This is specified using the DedicatedDumpfile registry value 
    
- types of memory dumps 
    + small dump: a small(64k) mini-dump containing minimal debugging information(stop code, parameters, stack, drivers)
    
    help for checking the reason
    
    + kernel dump, medium size dump containing kernel data structures, drivers and current process & thread information. 
    
    + complete dump, large memory dump containning complete contents of memory. can take considerabletime to dump memory. consume long time to write and large disk space
    
    + automatic dump, new to window server 2012 and window 8. same as kernel memory dump, but uses a smaller page file when system managed page fiels are used 
    
    http://blogs.technet.com/b/askcore/archive/2012/09/12/windows-8-and-windows-server-2012-automatic-memory-dump.aspx
    
    see microsoft kb 254649 for further details 
    
- configuring memory dumps 
    + use control panel | system applet | Advanced 
    under startup and recovery|settings 
    
    + configure dump type(see microsoft kb 254649)
    small, kernel, complete or automatic 
    
    + select dump file location(see microsoft kb 886429 for details)
    default%systemroot%memory.dmp 
    
    + select overwrite any existing dump file 
    
    + select options such as send alert and auto restart 
    
    + for further details see microsoft kb 307973 
    how to configure system failure and recovery options in windows 
    https://support.microsoft.com/en-us/help/307973/how-to-configure-system-failure-and-recovery-options-in-windows
    
    + open control panel 
    open system | Advanced system setting |startup and recovery 
    
    we could configure the system recovery strategy
    
- dedicated dump file 
    + new feature available with window server 2008 earlier. a page file has to be exist on the disk to catch the dump file
    
    this is an issue for lower hardware disk. 2008 later we could configure the page file to be saved to different location and support put pagefile could be saved on different disk 
    
    + dedicated dump file can be located on any local disk 
    
    + new registry value: DedicatedDumpFile & DumpFileSize 
    for further details see Microsoft KB 969028 
    how to generate kernel or a complete memory dump in windows server 2008 r2 
    
- restrictions and gotchas 
    + sufficient free disk space for memory.dmp 
    + pagefile.sys located on boot partition(pre-windows 2008)
    
    + pagefile.sys sufficiently size for type of memory dump 
    
    + automatic server recovery(ASR) may prevent memory dump from being written(disable in BIOS). See Microsoft KB 244139 for details 
    
    the solution is temporary disable the watch dog feature 
    
    + additional reasons why a dump file is not created(microsoft kb 130536)
    
    + gotachas 
    kernel memory dump files may not be generated on windows server 2008 and windows vista computers when system meory is larger than the size of the page file(microsoft kb 949052)
    
    new registry value: IgnorePagefileSize 
    
    dedicated dump files are unexpectlly truncated to 4gb on a computer that is running windows server 2008 or vista and that has more than 4gb of physical memory (microsoft kb 950858)
    
    new registry value: DedicatedDumpfile & DumpfileSize 
    
    enables windows 7 or windows 2008 r2-based computer to create a memory dump file without a page file(microsoft kb 2716542)
    
    windows 7 does not save memory dump if less than 25gb of free disk space. 
    new registry value AlwaysKeepMemoryDump 
    
    windows doesnot create a memory dump file when a stop error occurs in windows 8 or windows server 2012(microsoft kb 2853466)
    
    existing memory dump file is removed if you turn off the "overwrite any existing fiel" option in windows 8 and windows server 2012(microsoft kb 2851299)
    
    windows error reporting reports a crash when you shut down a computer that is running windows rt, windows 8 or windows server 2012(microsoft kb 2800185)
    
    memory dump file is generated very slowly on a hyper-v virtual machine that uses dynamic memory when the maximum RAM setting is over 4gb in windows server 2008r2 (microsoft kb 2587660)
    
    remember to use http://support.microsoft.com 
    
- summary 
different reasons for crash 
only crashes automatically generate a memory dump 
memory dump must be forced on a hung system 

different types of memory dumps 
small, kernel, complete and automatic 
dedicated dump file can be used instaed of a page file 

configure dump file options in the system applet 

variety of hotfixes for problems capturing memory dumps 
    
    
# Getting started with the windows debugger 
- windbg is used for 
    
    
# Getting help in windows debugger 
- module topics 
    + introducing the window debugger 
    + live kernel debugging 
    + post mortem analysis 
    + installing the debugging tools 
    + starting the debugger for the first time 
    + debugger workspaces 
    + opening a memory dump 
    
- the windows debugger 
    + commonly known as windbg 
    + graphical user interface 
    + kernel or user-mode memory dumps 
    + live kernel debugging or post mortem analysis 
    + part of the debugging tools for windows 
    + kd.exe, kernel debugger 
    command line interface 
    user for scripting and auomating 
    
    + CDB & NTSD user mode debuggers 
    
    + adplus.exe process dumper 
    capture process exceptions in memory dumps 
    force a memory dump on a hung process 
    capture multiple simultaneous process memory dumps 
    
    + other tools 
    dumpchk, kill, tlist, usbview...

- live kernel debugging 
    + step through the operating system 
    + step breakpoints examine variables, ...
    + requires 2 computers 
    target, the computer is being debugged 
    host, the computer that runs the debugger 
    
    + uses special cable to connect computers 
    + requires intricate knowledge of the operating system 
    + dedicated downtime for the target system 
    
- Post mortem analysis 
    + analyzing memory dumps 
    + most common use of windbg 
    + snapshot of memory at the time of the crash 
    + stack trace gives history of function calls 
    + examine registers and instruction stream 
    + display kernel data structures(threads, processes, locks)
    + identify hardware components, driver revisions, firmware, ...
    + major focus of the course is how to analysis the dump 
    
- installing the debugging tools 
    + quick and easy installation 
    + part of the software development kit(sdk), we could only install the debugging tool 
    + also included in the windows driver kit(wdk). no option to only install debugging tool 
    + requires .net framework 4.5 for setup 
    + two versions of windbg, 323-bit x86 and 64-bit x64 
    + wdk and windbg downloads 
    http://msdn.microsoft.com/en-US/windows/hardware/gg463009/
    
    + sdk and windbg downloads 
    http://msdn.microsoft.com/en-US/windows/desktop/bg162891/
    
    + important, required v8.0+ debugger is required to check window server 2012+ or window 8+ dumps 
    
- sdk installation options 
    + install on local and then you could copy the tool any other computers 
    + installation path 
    c:\program files(x86)\windows kits\8.x\debuggers\x64 
    c:\program files(x86)\windows kits\8.x\debuggers\x86
    
    + additional notes on installing the debugging tools for windows 
    http://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx 
    
- starting debugger 
- debugger workspaces 
    + customize your debugging environment 
    font settings 
    window placement 
    source path 
    symbol path 
    etc...
    
    default workspace name is "base"
    
    per-dump workspace 
    
    + prompted to save workspace when existing the debugger or use the file pull-down menu save workspaces 
    
    workspaces{
        per-dump settings
        base settings 
    }
- opening a memory dump 
    + from within windbg, use the file pull-down menu 
    open crash dump ....
    
    + from the command prompt 
    windbg -z memory.dmp 
    
    + command output window displays crash information 
    
    + debugger command prompt awaits your commands 
    
    + open a dump file 
    myfault.sys 
    
- summary 
    

# Getting help in the windows debugger 
- introducing the windows debugger online helps library 
- why learn about windbg help? 
- debugger operations 
- debugger commands 
commands 
    d, display memory 
    k, display stack 
meta commands 
    .command 
extension commands
    !command, explanation symbol. we call bane 
    
    + open the debugger reference section from the windbg document 
- bug check code reference section. most important 
    + system death 
    blue screen 
    BSOD, 
    bugcheck 
    symbolic name 
    
    + blue screen contain stop code etc. From windows 8 and windows server 2012 or later, stop code and parameters are no longer displayed. (see Microsoft hotfix KB 2929742)
    
    + blue screen data, Bug Check Code Reference section in window debugger help document 
    
    there are many helpful information provided by the help document 
   
- processor architecture & instructions 
    + processor types 
    x86 -> 32bit 
    x64 -> 64bit (AMD 64 & intel64)
    
    + defines registers, flags, calling conventions 
    
    + assembly instructions(MOV, PUSH, POP, ...). check the processor architecture session from the debugger helps 
    
    contains x86 and x64 architecture

- wealth information 
- updated between versions 
- provides command usage and examples 
- detailed information on stop codes 
- recommended troubleshooting steps 
- architecture references manuals 
- debugger operations check the windbg debugger helps document 


# Configuring the windows debugger 
- what needs to be configured 
    + module topics 
what are symbols?
setting up the symbol file path 
establishing the source code file path 
configuring the executable image page 
    + what need to be configured?
    symbol file path 
    source file path 
    image file path 
    
- symbols 
    symbols provide meaning full names instead of hexadecimal numbers 
    
    identify function names and variables 
    
    symbol will help translate the hex number(address/data/command)  to function names 
    
    + symbol files 
    stored in .PDB files created by the compiler 
    changes to programs result in new unique symbol files 
    debugger must have access to the right symbol files 
        OS version 
        service pack 
        hotfix 
        
    + types of symbols 
    public symbols 
        function names 
        global variables 
        freely available from Microsoft for windows 
        
    private symbols 
        local variables 
        source file paths and line numbers 
        structure definitions(types)
        rarely distributed 
        
- setting the symbol file path 
automatically downloads symbols 
uses the correct symbols for the OS version and service pack level beining debugged 
http://support.microsoft.com/kb/311503/

copy symbols locally to your own symbol store 
http://msdn.microsoft.com/en-us/windows/hardware/gg463028.aspx 

    + setting the symbol file path 
from the windbg GUI
srv*c:\symbols*http://msdl.microsoft.com/download/symbols 

from the CLI, use the -y command line 
windbg -y srv*c:\symbols*http://msdl.microsoft.com/download/symbols

from the windbg command prompt 
.sympath srv*c:\symbols*http://msdl.microsoft.com/download/symbols 

set the _NT_SYMBOL_PATH environment variable 

save your workspace will save the previous set symbol path 

    + additional symbol commands to know 
    .symfix, set the symbol path to use microsoft symbol server 
    
    !sympath, display the current symbol path 
    
    !sym noisy, turns on verbose mode for display symbol information 
    
    !sym quiet, turn off 
    
    .reload, reload all the symbols after changed the symbol path 

- establishing the source file path 
    + allows debugger to display the source code 
    + display corresponding c/c++ source code in the debugger 
    from GUI, source file path 
    
    from the CLI, use the -srcpath command line option 
    windbg -srcpath c:\mysource 
    
    from the debuger command prompt 
    .srcpath c:\mysource 
    
    set the _NT_SOURCE_PATH environment variable 

- configuring the executable image 
needed for kernel-mode small dumps and user-mode minidumps. additional information will be provided for the minidumps file 

binaries not included in these memory dump(.exe, .dll, .sys)

image file path can also use the microsoft symbol server 
    image file path... and assign the microsoft symbol server 
    
from the cli use the -i option 
$ windbg -i 

from the debugger prompt 
.exepath 

set _NT_EXECUTABLE_IMAGE_PATH variable 


# Starting your crash dump analysis
- starting your crash dump analysis  
    + starting your analysis with !analyze 
    + demo !analyze -v 
    + strategies for analyzing crashes 
    + strategies for analyzing hangs 
    
- check your symbol file path 
    + point to MS symbol server 
    + open the memory dump 
    c:\windows\memory.dmp is the default location 
    
    + read the initial debugger output. display the versio of os the processor number time, suspect of the crash 
    
    + !analyze -v 
    most important debugger command 
    
    performs a preliminary analysis 
    
    provides details to get you started 

    first command to automatic set the environment for the crash 
    
    display the stop code and symbolic name 
    
    gives an explanation of the crash about the exception 
    
    shows the stack trace and arguments 
    
    provides recommendations 
    
    Goal -> identify keywords to search for known issues & hotfixes 
    
    + example 
3 kd> !analyze -v                   //3 the header 3 means cpu 3
*********...
*....
*********...
DRIVER_CORRUPTED_EXPOOL (c5)        //stop code 
An attempt was made to access a pageable ...  //explanation
...
...
Arguments:
Arg1: 0000000000008, memory referenced 
Arg2: 0000000000002, IRQL 
....

- Demonstration using !analyze -v 
    + load a dump and execute 
3 kd> !analyze 
Microsoft (R)...
Copyright ...

Loading Dump File [C:\...]
Kernel Complete Dump File...

*****Symbol path validation summary *****
Response            Times               Location 
Deferred                                SRV*....
Symbol search path is SRV*c:\symbols....
Execute search path is:
Windows Server 2003 Kernel Version 3790(ServicePack 1) MP (4 procs) Free x86 compatible 
Product: ....
Build by: 3790.srv...
Machine Name 
Kernel base = 0x808.....
Debug session: ...
System uptime 
Loading Kernel symbols 
....
....
Loading User Symbols 
Loading unloaded module list 
*****...
*...
*****...
Use !analyze -v to get detailed debugging information 
BugCheck 54, {361595, e8aab501, 0, 0}   //stop code and {arguments}
Probably caused by : srv.sys (srv!SrvVerifyDeviceStackSize+78)
Followup:MachineOwner
----------------

    + after check the !analyze -v command get the stop code and error macro 
    
    got to http://support.microsoft.com and search with the stop code and driver name 
    
    these two information is good to get the hotfix  
    
- Strategies for analyzing system crashes 
    + start with !analyze -v 
    + look up the stop code with the bug and check code reference section from debugger help doc 
    
    + examine the stack grace to determine what drivers were executing (kv)
    
    + determine what process and thread was running(!process, !thread) help you particular application is involved in the crash process 
    
    + review loaded driver dates for old or brand new drivers(lm t n, !lmi) these command can show the driver relative information 
    
    + track down any outstanding I/O request packets(!irp, !object, !devstack)
    
    + search http://support.microsoft.com (KBs), bing and google 
    
- strategies for analyzing hangs from a memory dump 
    + start with !analyze -v -hang 
    add -hang command will help info the debugger to check the dead locks 
    
    + check for dealocks for spinlocks(!locks, !qlocks)
    
    + check for compute-bound runaway threads(!thread, !running -t, !stacks)
    
    + check for depleted system memory resources (!vm, !memusage)
    
    + determine memory pool consumers (!poolused)
    
    + search http://support.microsoft.com (KBs) bing and google 
- summary 


# Understanding Stack Traces 
- module topics 
    + stack fundamentals 
    + what is a stack trace?
    + displaying the stack trace 
    + stack trace commands 
    k, display stack trace 
    dds, dqs, display address with symbols 
    !stacks, display all kernel stacks 
    
    + what is a stack 
    fundamental data structure 
    keep track of function calls and parameters
    temporary storage of data 
    used for manipulating strings and parsing expressions 
    
    + calling functions 
    stack pointer register keeps track of the top of the stack 
    call instructions push the return address on the stack 
    ret instructions pop the return address off the stack 
    
- stack traces 
history of function call 
stack develop from the bottom up 
as threads execute functions, the return address is pushed on the stack 
bottom of stack contains first functions that were called 
top of stack contains the most recent functions that were called 
    
- window stacks 
    + window implement 2 stacks per thread 
    user-mode stack(1mb, pageable)
    
    kernel-mode stack(12kb, non-pageable)
    
    + when a user proces call a kernel function the user stack switches to kernel stack and after the kernel function complete the kernel stack is switch back to user stack 
    
    the same scenario is happend whne interrupts or traps happened 
    system calls 
    interrupts 
    traps 
    
    + window maintain a dpc(deferred procedure call) stack, this allow the driver deferred somework to be done at a lower interrupt level to free the process to do more priority works 
    per-processor have its own dpc stack 
    execute driver DPCs
    
- display the stack trace 
    + from View|Call Stack in windbg 
    + separate window displays call stack. The symbol files are required 
    
    + tabs to customize view 
    Raw args 
    Func info 
    Source 
    Addrs 
    Heading 
    Nonvolatile regs 
    Frame nums 
    Source args

    + demo 
    check sympath 
    kd> !sympath 
    
    select the call stack view. we could press the toggle button to display the additional information. Press the heading button will display the title for each column 
    
- windbg k command for display stack trace 
display call stack information 
    call stack pointer 
    return address 
    function 
    parameters 
    
several variants 
    k displays child stack pointer, return address, function name 
    kb, display child SP, ret.addr, function name, first 3 paraeters 
    kv, display child SP, ret.addr, function name, first 3 parameters, FPO(Frame Pointer Omission) info 
    kc, display function name 
    kn, displays frame numbers 
    kd, displays raw stack data
    
- debugger stack trace commands, display addresses with symbols 
    + display addresses on stack with symbols 
    dds for 32bit 
    dqs for 64bit 
    
    parameters are also displayed on the stack 
    
    alternate way to view the same stack data 
    
    ESP register is the stack pointer for 32 bit architecture 
    
    RSP register is the stack pointer for 64 bit architecture 
    
    command variants 
        dds, display double-word(4 byte) addresses with symbols for 32 bit dumps 
        kd> dds esp 
        
        dqs, display quad-word(8 byte) addresses with symbols for 64 bit dumps 
        kd> dqs rsp 
        
    + display stack info
    kd> dds esp 
    
    continue use the dds without parameter will continue display the stack information 
    kd> dds 
        
- debugger stack trace command with !stack 
    + displays a summary of the kernel stack for all threads 
    + optionally display stack trace history for all threads 
    + displays the thread state(running, blocked, ready, ...)
    + command variants 
    !stacks, displays a summary of kernel stacks 
    kd> !stacks 
    
    !stacks2, displays full stack trace for all threads 
    
- summary


# Debugging Processes and Threads
- module topics 
    + windows processes 
    + !process debugger command to list process information 
    + learn about window threads 
    + !thread debugger command to display useful information
    + thread scheduling and states 
    
- understanding windows processes 
    + basic building blocks of an operating system 
    + provides a container for the execution of a program 
    + private virtual address space 
    + security context or access token, which is access token for the process 
    + system processes and threads implementation 
    System process (used for kernel-mode system threads)
    system support processes(winlogon, session manager...)
    service processes (print spooler, task scheduler...)
    
    + user processes and threads 
    native win32 applications 
    environment subsystems(MS-DOS, POSIX, and OS/2)
    
- process internals 
    + unique process ID(PID) used for identification 
    + process consists of 1 or more threads 
    + handle table for objects 
    + contains quota limits usage information 
    limits on processor usage 
    paged pool 
    non-paged pool 
    page file usage 
    working set sizes 
    virtual size 
    peak virtual size 
    
    + process scheduling information 
    contains scheduling information 
    processes state 
    base priority 
    quantum(time slice) 
    processor affinity 
    
    + CPU time metrics 
    elapsed time 
    kernel time 
    user time 
    
- using the !process debugger command 
    + display the process information 
    !process 
    
    process id 
    image name 
    handle count 
    cpu times(elapsed, kernel, user)
    quotas & usage (pool, working set, virtual address space)
    priority 
    threads 
    
    + command syntax 
    !process<process address> <flag> 
    display current process if no address is specified 
    displays all processes if 0 
    level of detail is controlled with flags 
    0 brief detail 
    7 full details(threads, stack trace...)
    
    example:
    > !process              display current process
    > !process 0 0          display all process brief 
    > !process 0 7          display all processes full 
    > !process 87fd8990     display process address at 
    
- window threads 
    + entity within a process that is scheduled for execution 
    + unique thread id(client id)
    + 1 or more theads per process 
    + 2 stacks per thread(user-mode, kernel-mode)
    + thread maintain the cpu register contents represent the processor state 
    + each thread shares the process virtual address space 
    + each thread shares the process security context 
    + each thread shares the process handle table 
    + thread specifics 
    thread start address, is the function will be call when the thread is started 
    owning process(parent)
    pending i/o requests 
    pointers to system service dispatch table 
    asynchronous procedure calls (APC)queue 
    scheduling information(base & current priority, affinity, quantum...)
    
    + system threads
    special threads used by system process 
    only runs in kernel model 
    used by the nt kernel and deivce drivers 
    uses system address space, no user process address space 
    performs functions such as 
        * writing dirty pages to the page file 
        * swapping processes in and out of memory 
        * balance set manager scheduling activities 
        * cache manager read-ahead/write-behind I/O 
        * file serving requests 
        ....
        
    + idle thread 
    when no other runnable threads need the CPU 
    
    base priority 0, but not really scheduled 
    
    on idle thread per processor 
    
    one idle process for all idle threads 
    
    idle thread loops to itself(nt!KildleLoop)
    
    idle thread is also used to execute DPCs(deferred procedure calls)
    
    idle thread calls registered power management idle processor routine to reduce the power consumption 
    
- examining threads with the !thread debugger command 
    + display thread information 
    thread id 
    state(running, wait...)
    image name 
    owning process 
    stack base, current, limit 
    cpu times(kernel, user)
    priority 
    stack trace 

    + command syntax 
    > !thread <thread address> <flag> 
    
    no address will display the current thread 
    0 brief details 
    6 full details 
    
    > !thread <address> 6 full details for a particular thread 
    
    
- understanding thread scheduling and states 
    + windows implement a priority driven, preemptive scheduling system 
    + highest priority runnable (ready) thread always runs 
    + 32 priority levels 
    16-31 are real-time 
    1-15 are variable levels 
    0 reserved for the zero page thread 
    
    + threads many be limited to particular processors(with the affinity mask)
    
    + threads run for a time slice called quantum 
    
    + at quantum end, thread priority is reduced, but not lower than base 
    
    + threads waiting on I/O receive a priority boost once ready 
    
    + thread states 
    running, actively executing on a processor 
    ready, a runnable waiting for a processor 
    waiting, voluntarily wait for an event(I/O, sychronization...)
    standby, selected to run on a specific processor, but not yet scheduled 
    transition, ready to run, but kernel stack is paged out
    initialized, used while a thread is being created 
    terminated, used after a thread has finished executing 
    
- summary 
process and thread are the fundamental of building block of window 
    
    
# Understanding Processors and Disassembled Code 
- module topics 
    + processors and registers 
    + multiprocessor systems 
    + sockets, cores, and hyper threading 
    + unassembling instruction streams understand what instructions were executing on at the time 
    
    + processors 
    32bit processors x86 
    intel i-386 (Pentium)
    32bit registers 
    32bit addresses and data width 
    
    64bit processors(x64)
    AMD64 & Intel 64 chips 
    64-bit registers 
    64 bit addresses and data width 
    backwards compatible with x86 
    backwards compatible with x86 
    IA-64 itanium and alpha processors no longer provided on windows 
    
    + 32 bit registers 
    8 general purpose integer registers & 8 floating point registers 
    hold values for computation 
    addressable by byte word double-word 
    EAX, accumulator , holds return value from function calls 
    EBX, base register, used for counting during REP(repeat) operations 
    EDX, holds the high 32 bit returned by functions returning 64 bit values 
    EDI, ESI, used by block move and compare instructions(indexing)
    ESP, stack pointer, used for the address of the top of the stack 
    EBP, base pointer register, stack pointer for a given routine 
    
    special processor registers:
    EIP, instruction pointer 
    EFLAGS, flags register such as overflow, negative zero etc, zero flag 
    
    + 64 bit registers 
    16 general purpose integer registers and 16 floating point registers 
    addressable by byte word doulbe-word, quad-word 
    RAX, accumulator hold return value form function calls 
    RBX, base register, used for addressing memory as a pointer 
    RCX, count register, used for counting during REP(repeat) operations 
    RDI, RSI, used by block move and compare instructions(indexing)
    RSP, stack pointer used for the address of the top of the stack 
    RBP, base pointer register, stack pointer for a given routine 
    R8...R15, new regsiters for x64 
    
    dedicated regsiters:
    RIP, instruction pinter 
    RFLAGS, flags register 
    
    + windbg regsiters command 
    r, display integer register and current instruction 
    r<register name> displays the register contents 
    command variants 
        rF, displays floating pointer registers 
        rX, displays SSE XMM registers 
        
    Example usage: 
    kd> r 
    eax=f774f13c ....   //register values 
    nt!KeBugCheckEx+0x... //instruction current executed 
    
- multiprocessor systems 
    + multiprocessor system 
    multiple independent processors 
    widnows implements symmetric multiprocessing 
        no master processor 
        system or user threads run on any processor 
        
    processor affinity specify which processor is run on 
        control  which processors a thread will run 
        optimize throughput 
        partition workload 
        
    special inter-processor synchronization to avoid corrupt memory 
    spinlocks, ensure only one processor access the data at a time 
    inter-processor interrupts(IPI), to generate interprocessor interrupt 
    
    + windbg ~s command 
    windbg support multprocessor debugging 
    
    processors are numbered 0 through n-1 
    
    debugger command prompt reflects the current processor context 
    0 kd> the heading 0 indicates that processor 0 is current 
    
    use the ~s(tilde s) command to switch to a different processor 
    0 kd> ~1s 
    1 kd> 
    
    subsequent debugger commands execute in the new processor context 
    > !thread 
    > !process 
    > k 
    > r 

    + windbg !running command 
    !running displays the current thread on each processor 
    
    !running -t includes the stack trace for each thread 
    
    tilde ~
    
- sockets, cores, and hyper-thread 
    + sockets are connectors on system board for physical processors 
    + the number of sockets depends on the system hardware model to plug in processors 
    + cores contain a central processing unit(CPU)
    
    + physical processor can have two or more cores 
    dual core 
    quad core 
    up to 16 cores 
    
    + hyper threading technology provides simultaneous multi-threading 
    
    + hyper threading results in 2 logical processor per physical CPU 
    
    + windows server 2012 supports 640 logic processors 
    
    + windbg process commands 
    !cpuinfo, display cpu manufacturer, speed(mhz), features 
    
    !sysinfo cpuinfo, displays detailed processor information 
    
    !sysinfo machineid, displays system hardware model, BIOS, current executing thread id, idle thread on the cpu etc. 
    
    !pcr, displays processor control region used by windows 
    current thread 
    next thread 
    idle thread 
    IRQL(interrupt request level)
    DPC queue(Defferred procedure calls) 
    
- unassembling instruction 
    + processor instructions 
    output from compilers conssit of assembly instructions 
    
    + x86 and x64 instruction sets used by windows 
    
    + different types of instructions 
    arithmetic (ADD, SUB, MUL, DIV, SHL, INC, DEC, NEG)
    
    logic(OR, AND, XOR, NOT )
    
    data conversion(CBW, CWD, CWDE, CDQ)
    
    data transfer(MOV, MOVSX, MOVZX)
    
    string(MOVS, CMPS, STOS, LODS, SCAS)
    
    stack(PUSH, POP)
    
    Flow control(JMP, CALL, INT, CMP, TEST, JNZ, LOOP)
    
    + operands, arguments or parameters(zero, 1 or 2)
    
    + instructions are variable in length 
    
    + windbg unassemble command 
    u, display an assembly translation of the program in memory 
    
    u <address>, disassembles code starting at an address 
    
    u < address range> disassembles a range of addresses 
    
    ub <address> disassemble the preceding 8 instructions 
    
    uf <function name> disassemble an entire function 
    
    example usage: 
    kd> u address 
    
- summary 


# Investigating Locks and Spinlocks 
- module topics 
locks and resources 

debugging deadlocks 

spinlocks, avoid multiple processor access a same data 

analyzing spinlock hangs 

- locks & resources 
    + executive resources provide synchronization through out the windows kernel, specially in file system drivers 
    
    Example:
    nt!CmpRegistryLock, 
    
    + locks are used by threads to synchornize access to executive resource 
    
    + shared locks allow multiple threads owners 

    + exclusive locks permit only 1 thread owner 
    
    + example lock request 
    call ExAcquireResourceExclusiveLite will own a resource, the first argument of the function is the resource address 
    
    other threads may try to access the resource too, but as the resource is locked so the requests will be queued in a FIFO queue 
    
    + kernel locking functions to acquire resource locks 
    system functions used to acquire resource locks 
    ExAcquireResourceSharedLite 
    ExAcquireResourceExeclusiveLite 
    ExAcquireSharedStarveExclusive 
    ExAcquireWaitForExclusive 
    ExTryToAcquireResourceExclusiveLite 
    
    kb> kb 
    
    + windbg !locks command 
    !locks, used to display resources and locking information 
    
    !locks -v <resourceaddress> displays threads with lock requires on a resource 
    
    kd> !locks 
    the lock type and owner thread id will be marked with <*> 
    
- debugging dead locks 
    + hang caused by 2 or more threads wanting resources the other owns 
    
    + caused by a programming error or an outstanding I/O request not completing 
    
    both threads want something the other threads own 
    
    + finding deadlocks 
    use !locks to display locks held on resources 
    
    look for exclusively owned locks with waiter threads 
    
    thread owning the exclusive lock will have asterish* 
    
    kd> !locks 
    the all other waiting thread id are lised 
    
    + example owning threads 
    
    use !thread to display the thread that owns the exclusive lock 
    
    view the stack trace to determine why it is waiting 
    
    kd> !thread <address> 
    
- spinlocks 
!qlocks, will display the information for spinlocks 

spinlocks are used to synchronize access to common data structures with multiple processors 

processors try to acquire spinlocks to update data structures 

owner of the spinlock is guaranteed exclusive access 

other processors "spin" trying to acquire the spinlock 

potential hangs occur when the multiple processor all try to acquire the same spinlock and the owner of the spinlock is waiting on something else(e.g. stalled I/O request) 

- kernel spinlock functions 
KeAcquireSpinLock 
KeReleaseSpinLock 
KeAcquireQueuedSpinLock 
KeAcquireInStackQueueSpinLock 
KeAcquireSpinLockRaiseToSynch 

kd> k 
Ret addr 
hal!KeAcquireSpinLockRaiseToSynch+0x28 

    + display all kernel spinlocks, !qlocks 
kd> !qlocks 
Key: O = Owner, 1-n = wait order, blank = not owned/waiting, C = corrupt 

Lock name           Processor number 
                    0   1   2   ...  the number is processor number 
KEP -dispatcher                    
...
CC -Vacb            15  O   13  ...   the number is the wait order     
...

use !running --it command to display the information for the spinlock owner thread

- analyzing spinlock hangs, when you suspect the hang is caused 

# Exploring Windows Virtual Memory 

# Windows Drivers and Interrupts 

# Forcing Windows Memory Dumps 

























    
    
    
    
    
    
    
    
    
    
    