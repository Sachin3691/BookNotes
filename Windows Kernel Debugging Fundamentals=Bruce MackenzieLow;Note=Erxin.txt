Windows Kernel Debugging Fundamentals=Bruce MackenzieLow;Note=Erxin

# introduction to windows crashs and hangs 
- introduction 
    + why learn windows kernel debugging 
    + debugging crashes verses hangs 
    + common culprits 
    + how memory dumps are created 
    + types of memory dumps 
    + configuring memory dump settings 
    + dedicated dump file 
    + restrictions and gotchas 
    
- kernel debugging skills 
    + driver developers 
    debugging your own code 
    debugging someone else's code 
    
    + IP professionals 
    minimize downtime 
    identify suspect driver 
    
- crash dump analysis, interpreting the contents of RAM to determine why a system is failed. 

    + MS tool for help generate system failure in a variety of ways 
    NotMyFault
    
- windows crashes and hangs 
    + crashses are unexpected, unhandled exceptions that occur in kernel mode 
    
    + the state of operating system becomes questionable 
    
    + the operating system stops to avoid corrupting data 
    
    + also known as the blue screen of death (BSOD) stops and bugchecks 
    
    + the contents of RAM is saved in a file called memory.dmp 
    
- windows system hangs 
    + hangs occur when processors or peripheral devices unresponsive and freezed 
    
    + software induced hangs include 
    depleted system resources(memory pool)
    runaway high priority compute-bound threads 
    synchronization mechanisms (deallocks & spinlocks)
    
    
    + hardware originated hangs include 
    faulty devices causing false interrupts 
    failing processors 
    corrupted RAM 
    
    + memory dump must be manually forced generated on a hung system 
    
- common culprits for crashes 
    + the big reasons are old antivirus software. it is not fully tested on the new OS 
    
    + new drivers 
    Storport(over 50 hotfixes in windows 2003), https://docs.microsoft.com/en-us/windows-hardware/drivers/storage/storport-driver
    
    MPIO(over a dozen hotfixes in windows 2008)
    
    + incompatible drivers 
    old Storport driver with a new miniport driver 
    
    + too many filter drivers 
    antivirus deduplication, disk quota, mirroring 
    
    + memory corruption 
    + hardware failures 
    + operating system bugs 
- Common culprits for hangs 
    + depleted system resources (memory pool). limited resource cause system to hang 
    
    + broken applications with deadlocks or spinlock hangs. 
    
    + high priority compute-bound(runaway) applications 
    
    + old antivirus software 
    
    + new drivers 
    
    + incompatible drivers 
    
    + broken hardware
    
- determining driver dependencies 
    + use dependency walker(depends.exe)
    http://www.dependencywalker.com 
    
    + opening a driver QL2300.SYS. will display the dependency 
    
- How memory dumps are created 
    + crash or hang, content of RAM is writen to Pagefile.sys* 
    
    on reboot the pagefiles.sys* -> memory.dmp 
    
    analyze crash with windbg 
    
    + In window 2008/vista later, a dedicated dump files can be used instead of the page file on any local disk. This is specified using the DedicatedDumpfile registry value 
    
- types of memory dumps 
    + small dump: a small(64k) mini-dump containing minimal debugging information(stop code, parameters, stack, drivers)
    
    help for checking the reason
    
    + kernel dump, medium size dump containing kernel data structures, drivers and current process & thread information. 
    
    + complete dump, large memory dump containning complete contents of memory. can take considerabletime to dump memory. consume long time to write and large disk space
    
    + automatic dump, new to window server 2012 and window 8. same as kernel memory dump, but uses a smaller page file when system managed page fiels are used 
    
    http://blogs.technet.com/b/askcore/archive/2012/09/12/windows-8-and-windows-server-2012-automatic-memory-dump.aspx
    
    see microsoft kb 254649 for further details 
    
- configuring memory dumps 
    + use control panel | system applet | Advanced 
    under startup and recovery|settings 
    
    + configure dump type(see microsoft kb 254649)
    small, kernel, complete or automatic 
    
    + select dump file location(see microsoft kb 886429 for details)
    default%systemroot%memory.dmp 
    
    + select overwrite any existing dump file 
    
    + select options such as send alert and auto restart 
    
    + for further details see microsoft kb 307973 
    how to configure system failure and recovery options in windows 
    https://support.microsoft.com/en-us/help/307973/how-to-configure-system-failure-and-recovery-options-in-windows
    
    + open control panel 
    open system | Advanced system setting |startup and recovery 
    
    we could configure the system recovery strategy
    
- dedicated dump file 
    + new feature available with window server 2008 earlier. a page file has to be exist on the disk to catch the dump file
    
    this is an issue for lower hardware disk. 2008 later we could configure the page file to be saved to different location and support put pagefile could be saved on different disk 
    
    + dedicated dump file can be located on any local disk 
    
    + new registry value: DedicatedDumpFile & DumpFileSize 
    for further details see Microsoft KB 969028 
    how to generate kernel or a complete memory dump in windows server 2008 r2 
    
- restrictions and gotchas 
    + sufficient free disk space for memory.dmp 
    + pagefile.sys located on boot partition(pre-windows 2008)
    
    + pagefile.sys sufficiently size for type of memory dump 
    
    + automatic server recovery(ASR) may prevent memory dump from being written(disable in BIOS). See Microsoft KB 244139 for details 
    
    the solution is temporary disable the watch dog feature 
    
    + additional reasons why a dump file is not created(microsoft kb 130536)
    
    + gotachas 
    kernel memory dump files may not be generated on windows server 2008 and windows vista computers when system meory is larger than the size of the page file(microsoft kb 949052)
    
    new registry value: IgnorePagefileSize 
    
    dedicated dump files are unexpectlly truncated to 4gb on a computer that is running windows server 2008 or vista and that has more than 4gb of physical memory (microsoft kb 950858)
    
    new registry value: DedicatedDumpfile & DumpfileSize 
    
    enables windows 7 or windows 2008 r2-based computer to create a memory dump file without a page file(microsoft kb 2716542)
    
    windows 7 does not save memory dump if less than 25gb of free disk space. 
    new registry value AlwaysKeepMemoryDump 
    
    windows doesnot create a memory dump file when a stop error occurs in windows 8 or windows server 2012(microsoft kb 2853466)
    
    existing memory dump file is removed if you turn off the "overwrite any existing fiel" option in windows 8 and windows server 2012(microsoft kb 2851299)
    
    windows error reporting reports a crash when you shut down a computer that is running windows rt, windows 8 or windows server 2012(microsoft kb 2800185)
    
    memory dump file is generated very slowly on a hyper-v virtual machine that uses dynamic memory when the maximum RAM setting is over 4gb in windows server 2008r2 (microsoft kb 2587660)
    
    remember to use http://support.microsoft.com 
    
- summary 
different reasons for crash 
only crashes automatically generate a memory dump 
memory dump must be forced on a hung system 

different types of memory dumps 
small, kernel, complete and automatic 
dedicated dump file can be used instaed of a page file 

configure dump file options in the system applet 

variety of hotfixes for problems capturing memory dumps 
    
    
# Getting started with the windows debugger 
- windbg is used for 
    
    
# Getting help in windows debugger 
- module topics 
    + introducing the window debugger 
    + live kernel debugging 
    + post mortem analysis 
    + installing the debugging tools 
    + starting the debugger for the first time 
    + debugger workspaces 
    + opening a memory dump 
    
- the windows debugger 
    + commonly known as windbg 
    + graphical user interface 
    + kernel or user-mode memory dumps 
    + live kernel debugging or post mortem analysis 
    + part of the debugging tools for windows 
    + kd.exe, kernel debugger 
    command line interface 
    user for scripting and auomating 
    
    + CDB & NTSD user mode debuggers 
    
    + adplus.exe process dumper 
    capture process exceptions in memory dumps 
    force a memory dump on a hung process 
    capture multiple simultaneous process memory dumps 
    
    + other tools 
    dumpchk, kill, tlist, usbview...

- live kernel debugging 
    + step through the operating system 
    + step breakpoints examine variables, ...
    + requires 2 computers 
    target, the computer is being debugged 
    host, the computer that runs the debugger 
    
    + uses special cable to connect computers 
    + requires intricate knowledge of the operating system 
    + dedicated downtime for the target system 
    
- Post mortem analysis 
    + analyzing memory dumps 
    + most common use of windbg 
    + snapshot of memory at the time of the crash 
    + stack trace gives history of function calls 
    + examine registers and instruction stream 
    + display kernel data structures(threads, processes, locks)
    + identify hardware components, driver revisions, firmware, ...
    + major focus of the course is how to analysis the dump 
    
- installing the debugging tools 
    + quick and easy installation 
    + part of the software development kit(sdk), we could only install the debugging tool 
    + also included in the windows driver kit(wdk). no option to only install debugging tool 
    + requires .net framework 4.5 for setup 
    + two versions of windbg, 323-bit x86 and 64-bit x64 
    + wdk and windbg downloads 
    http://msdn.microsoft.com/en-US/windows/hardware/gg463009/
    
    + sdk and windbg downloads 
    http://msdn.microsoft.com/en-US/windows/desktop/bg162891/
    
    + important, required v8.0+ debugger is required to check window server 2012+ or window 8+ dumps 
    
- sdk installation options 
    + install on local and then you could copy the tool any other computers 
    + installation path 
    c:\program files(x86)\windows kits\8.x\debuggers\x64 
    c:\program files(x86)\windows kits\8.x\debuggers\x86
    
    + additional notes on installing the debugging tools for windows 
    http://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx 
    
- starting debugger 
- debugger workspaces 
    + customize your debugging environment 
    font settings 
    window placement 
    source path 
    symbol path 
    etc...
    
    default workspace name is "base"
    
    per-dump workspace 
    
    + prompted to save workspace when existing the debugger or use the file pull-down menu save workspaces 
    
    workspaces{
        per-dump settings
        base settings 
    }
- opening a memory dump 
    + from within windbg, use the file pull-down menu 
    open crash dump ....
    
    + from the command prompt 
    windbg -z memory.dmp 
    
    + command output window displays crash information 
    
    + debugger command prompt awaits your commands 
    
    + open a dump file 
    myfault.sys 
    
- summary 
    

# Getting help in the windows debugger 
- introducing the windows debugger online helps library 
- why learn about windbg help? 
- debugger operations 
- debugger commands 
commands 
    d, display memory 
    k, display stack 
meta commands 
    .command 
extension commands
    !command, explanation symbol. we call bane 
    
    + open the debugger reference section from the windbg document 
- bug check code reference section. most important 
    + system death 
    blue screen 
    BSOD, 
    bugcheck 
    symbolic name 
    
    + blue screen contain stop code etc. From windows 8 and windows server 2012 or later, stop code and parameters are no longer displayed. (see Microsoft hotfix KB 2929742)
    
    + blue screen data, Bug Check Code Reference section in window debugger help document 
    
    there are many helpful information provided by the help document 
   
- processor architecture & instructions 
    + processor types 
    x86 -> 32bit 
    x64 -> 64bit (AMD 64 & intel64)
    
    + defines registers, flags, calling conventions 
    
    + assembly instructions(MOV, PUSH, POP, ...). check the processor architecture session from the debugger helps 
    
    contains x86 and x64 architecture

- wealth information 
- updated between versions 
- provides command usage and examples 
- detailed information on stop codes 
- recommended troubleshooting steps 
- architecture references manuals 
- debugger operations check the windbg debugger helps document 


# Configuring the windows debugger 
- what needs to be configured 
    + module topics 
what are symbols?
setting up the symbol file path 
establishing the source code file path 
configuring the executable image page 
    + what need to be configured?
    symbol file path 
    source file path 
    image file path 
    
- symbols 
    symbols provide meaning full names instead of hexadecimal numbers 
    
    identify function names and variables 
    
    symbol will help translate the hex number(address/data/command)  to function names 
    
    + symbol files 
    stored in .PDB files created by the compiler 
    changes to programs result in new unique symbol files 
    debugger must have access to the right symbol files 
        OS version 
        service pack 
        hotfix 
        
    + types of symbols 
    public symbols 
        function names 
        global variables 
        freely available from Microsoft for windows 
        
    private symbols 
        local variables 
        source file paths and line numbers 
        structure definitions(types)
        rarely distributed 
        
- setting the symbol file path 
automatically downloads symbols 
uses the correct symbols for the OS version and service pack level beining debugged 
http://support.microsoft.com/kb/311503/

copy symbols locally to your own symbol store 
http://msdn.microsoft.com/en-us/windows/hardware/gg463028.aspx 

    + setting the symbol file path 
from the windbg GUI
srv*c:\symbols*http://msdl.microsoft.com/download/symbols 

from the CLI, use the -y command line 
windbg -y srv*c:\symbols*http://msdl.microsoft.com/download/symbols

from the windbg command prompt 
.sympath srv*c:\symbols*http://msdl.microsoft.com/download/symbols 

set the _NT_SYMBOL_PATH environment variable 

save your workspace will save the previous set symbol path 

    + additional symbol commands to know 
    .symfix, set the symbol path to use microsoft symbol server 
    
    !sympath, display the current symbol path 
    
    !sym noisy, turns on verbose mode for display symbol information 
    
    !sym quiet, turn off 
    
    .reload, reload all the symbols after changed the symbol path 

- establishing the source file path 
    + allows debugger to display the source code 
    + display corresponding c/c++ source code in the debugger 
    from GUI, source file path 
    
    from the CLI, use the -srcpath command line option 
    windbg -srcpath c:\mysource 
    
    from the debuger command prompt 
    .srcpath c:\mysource 
    
    set the _NT_SOURCE_PATH environment variable 

- configuring the executable image 
needed for kernel-mode small dumps and user-mode minidumps. additional information will be provided for the minidumps file 

binaries not included in these memory dump(.exe, .dll, .sys)

image file path can also use the microsoft symbol server 
    image file path... and assign the microsoft symbol server 
    
from the cli use the -i option 
$ windbg -i 

from the debugger prompt 
.exepath 

set _NT_EXECUTABLE_IMAGE_PATH variable 


# Starting your crash dump analysis
- starting your crash dump analysis  
    + starting your analysis with !analyze 
    + demo !analyze -v 
    + strategies for analyzing crashes 
    + strategies for analyzing hangs 
    
- check your symbol file path 
    + point to MS symbol server 
    + open the memory dump 
    c:\windows\memory.dmp is the default location 
    
    + read the initial debugger output. display the versio of os the processor number time, suspect of the crash 
    
    + !analyze -v 
    most important debugger command 
    
    performs a preliminary analysis 
    
    provides details to get you started 

    first command to automatic set the environment for the crash 
    
    display the stop code and symbolic name 
    
    gives an explanation of the crash about the exception 
    
    shows the stack trace and arguments 
    
    provides recommendations 
    
    Goal -> identify keywords to search for known issues & hotfixes 
    
    + example 
3 kd> !analyze -v                   //3 the header 3 means cpu 3
*********...
*....
*********...
DRIVER_CORRUPTED_EXPOOL (c5)        //stop code 
An attempt was made to access a pageable ...  //explanation
...
...
Arguments:
Arg1: 0000000000008, memory referenced 
Arg2: 0000000000002, IRQL 
....

- Demonstration using !analyze -v 
    + load a dump and execute 
3 kd> !analyze 
Microsoft (R)...
Copyright ...

Loading Dump File [C:\...]
Kernel Complete Dump File...

*****Symbol path validation summary *****
Response            Times               Location 
Deferred                                SRV*....
Symbol search path is SRV*c:\symbols....
Execute search path is:
Windows Server 2003 Kernel Version 3790(ServicePack 1) MP (4 procs) Free x86 compatible 
Product: ....
Build by: 3790.srv...
Machine Name 
Kernel base = 0x808.....
Debug session: ...
System uptime 
Loading Kernel symbols 
....
....
Loading User Symbols 
Loading unloaded module list 
*****...
*...
*****...
Use !analyze -v to get detailed debugging information 
BugCheck 54, {361595, e8aab501, 0, 0}   //stop code and {arguments}
Probably caused by : srv.sys (srv!SrvVerifyDeviceStackSize+78)
Followup:MachineOwner
----------------

    + after check the !analyze -v command get the stop code and error macro 
    
    got to http://support.microsoft.com and search with the stop code and driver name 
    
    these two information is good to get the hotfix  
    
- Strategies for analyzing system crashes 
    + start with !analyze -v 
    + look up the stop code with the bug and check code reference section from debugger help doc 
    
    + examine the stack grace to determine what drivers were executing (kv)
    
    + determine what process and thread was running(!process, !thread) help you particular application is involved in the crash process 
    
    + review loaded driver dates for old or brand new drivers(lm t n, !lmi) these command can show the driver relative information 
    
    + track down any outstanding I/O request packets(!irp, !object, !devstack)
    
    + search http://support.microsoft.com (KBs), bing and google 
    
- strategies for analyzing hangs from a memory dump 
    + start with !analyze -v -hang 
    add -hang command will help info the debugger to check the dead locks 
    
    + check for dealocks for spinlocks(!locks, !qlocks)
    
    + check for compute-bound runaway threads(!thread, !running -t, !stacks)
    
    + check for depleted system memory resources (!vm, !memusage)
    
    + determine memory pool consumers (!poolused)
    
    + search http://support.microsoft.com (KBs) bing and google 
- summary 


# Understanding Stack Traces 
- module topics 
    + stack fundamentals 
    + what is a stack trace?
    + displaying the stack trace 
    + stack trace commands 
    k, display stack trace 
    dds, dqs, display address with symbols 
    !stacks, display all kernel stacks 
    
    + what is a stack 
    fundamental data structure 
    keep track of function calls and parameters
    temporary storage of data 
    used for manipulating strings and parsing expressions 
    
    + calling functions 
    stack pointer register keeps track of the top of the stack 
    call instructions push the return address on the stack 
    ret instructions pop the return address off the stack 
    
- stack traces 
history of function call 
stack develop from the bottom up 
as threads execute functions, the return address is pushed on the stack 
bottom of stack contains first functions that were called 
top of stack contains the most recent functions that were called 
    
- window stacks 
    + window implement 2 stacks per thread 
    user-mode stack(1mb, pageable)
    
    kernel-mode stack(12kb, non-pageable)
    
    + when a user proces call a kernel function the user stack switches to kernel stack and after the kernel function complete the kernel stack is switch back to user stack 
    
    the same scenario is happend whne interrupts or traps happened 
    system calls 
    interrupts 
    traps 
    
    + window maintain a dpc(deferred procedure call) stack, this allow the driver deferred somework to be done at a lower interrupt level to free the process to do more priority works 
    per-processor have its own dpc stack 
    execute driver DPCs
    
- display the stack trace 
    + from View|Call Stack in windbg 
    + separate window displays call stack. The symbol files are required 
    
    + tabs to customize view 
    Raw args 
    Func info 
    Source 
    Addrs 
    Heading 
    Nonvolatile regs 
    Frame nums 
    Source args

    + demo 
    check sympath 
    kd> !sympath 
    
    select the call stack view. we could press the toggle button to display the additional information. Press the heading button will display the title for each column 
    
- windbg k command for display stack trace 
display call stack information 
    call stack pointer 
    return address 
    function 
    parameters 
    
several variants 
    k displays child stack pointer, return address, function name 
    kb, display child SP, ret.addr, function name, first 3 paraeters 
    kv, display child SP, ret.addr, function name, first 3 parameters, FPO(Frame Pointer Omission) info 
    kc, display function name 
    kn, displays frame numbers 
    kd, displays raw stack data
    
- debugger stack trace commands, display addresses with symbols 
    + display addresses on stack with symbols 
    dds for 32bit 
    dqs for 64bit 
    
    parameters are also displayed on the stack 
    
    alternate way to view the same stack data 
    
    ESP register is the stack pointer for 32 bit architecture 
    
    RSP register is the stack pointer for 64 bit architecture 
    
    command variants 
        dds, display double-word(4 byte) addresses with symbols for 32 bit dumps 
        kd> dds esp 
        
        dqs, display quad-word(8 byte) addresses with symbols for 64 bit dumps 
        kd> dqs rsp 
        
    + display stack info
    kd> dds esp 
    
    continue use the dds without parameter will continue display the stack information 
    kd> dds 
        
- debugger stack trace command with !stack 
    + displays a summary of the kernel stack for all threads 
    + optionally display stack trace history for all threads 
    + displays the thread state(running, blocked, ready, ...)
    + command variants 
    !stacks, displays a summary of kernel stacks 
    kd> !stacks 
    
    !stacks2, displays full stack trace for all threads 
    
- summary


# Debugging Processes and Threads
- module topics 
    + windows processes 
    + !process debugger command to list process information 
    + learn about window threads 
    + !thread debugger command to display useful information
    + thread scheduling and states 
    
- understanding windows processes 
    + basic building blocks of an operating system 
    + provides a container for the execution of a program 
    + private virtual address space 
    + security context or access token, which is access token for the process 
    + system processes and threads implementation 
    System process (used for kernel-mode system threads)
    system support processes(winlogon, session manager...)
    service processes (print spooler, task scheduler...)
    
    + user processes and threads 
    native win32 applications 
    environment subsystems(MS-DOS, POSIX, and OS/2)
    
- process internals 
    + unique process ID(PID) used for identification 
    + process consists of 1 or more threads 
    + handle table for objects 
    + contains quota limits usage information 
    limits on processor usage 
    paged pool 
    non-paged pool 
    page file usage 
    working set sizes 
    virtual size 
    peak virtual size 
    
    + process scheduling information 
    contains scheduling information 
    processes state 
    base priority 
    quantum(time slice) 
    processor affinity 
    
    + CPU time metrics 
    elapsed time 
    kernel time 
    user time 
    
- using the !process debugger command 
    + display the process information 
    !process 
    
    process id 
    image name 
    handle count 
    cpu times(elapsed, kernel, user)
    quotas & usage (pool, working set, virtual address space)
    priority 
    threads 
    
    + command syntax 
    !process<process address> <flag> 
    display current process if no address is specified 
    displays all processes if 0 
    level of detail is controlled with flags 
    0 brief detail 
    7 full details(threads, stack trace...)
    
    example:
    > !process              display current process
    > !process 0 0          display all process brief 
    > !process 0 7          display all processes full 
    > !process 87fd8990     display process address at 
    
- window threads 
    + entity within a process that is scheduled for execution 
    + unique thread id(client id)
    + 1 or more theads per process 
    + 2 stacks per thread(user-mode, kernel-mode)
    + thread maintain the cpu register contents represent the processor state 
    + each thread shares the process virtual address space 
    + each thread shares the process security context 
    + each thread shares the process handle table 
    + thread specifics 
    thread start address, is the function will be call when the thread is started 
    owning process(parent)
    pending i/o requests 
    pointers to system service dispatch table 
    asynchronous procedure calls (APC)queue 
    scheduling information(base & current priority, affinity, quantum...)
    
    + system threads
    special threads used by system process 
    only runs in kernel model 
    used by the nt kernel and deivce drivers 
    uses system address space, no user process address space 
    performs functions such as 
        * writing dirty pages to the page file 
        * swapping processes in and out of memory 
        * balance set manager scheduling activities 
        * cache manager read-ahead/write-behind I/O 
        * file serving requests 
        ....
        
    + idle thread 
    when no other runnable threads need the CPU 
    
    base priority 0, but not really scheduled 
    
    on idle thread per processor 
    
    one idle process for all idle threads 
    
    idle thread loops to itself(nt!KildleLoop)
    
    idle thread is also used to execute DPCs(deferred procedure calls)
    
    idle thread calls registered power management idle processor routine to reduce the power consumption 
    
- examining threads with the !thread debugger command 
    + display thread information 
    thread id 
    state(running, wait...)
    image name 
    owning process 
    stack base, current, limit 
    cpu times(kernel, user)
    priority 
    stack trace 

    + command syntax 
    > !thread <thread address> <flag> 
    
    no address will display the current thread 
    0 brief details 
    6 full details 
    
    > !thread <address> 6 full details for a particular thread 
    
    
- understanding thread scheduling and states 
    + windows implement a priority driven, preemptive scheduling system 
    + highest priority runnable (ready) thread always runs 
    + 32 priority levels 
    16-31 are real-time 
    1-15 are variable levels 
    0 reserved for the zero page thread 
    
    + threads many be limited to particular processors(with the affinity mask)
    
    + threads run for a time slice called quantum 
    
    + at quantum end, thread priority is reduced, but not lower than base 
    
    + threads waiting on I/O receive a priority boost once ready 
    
    + thread states 
    running, actively executing on a processor 
    ready, a runnable waiting for a processor 
    waiting, voluntarily wait for an event(I/O, sychronization...)
    standby, selected to run on a specific processor, but not yet scheduled 
    transition, ready to run, but kernel stack is paged out
    initialized, used while a thread is being created 
    terminated, used after a thread has finished executing 
    
- summary 
process and thread are the fundamental of building block of window 
    
    
# Understanding Processors and Disassembled Code 
- module topics 
    + processors and registers 
    + multiprocessor systems 
    + sockets, cores, and hyper threading 
    + unassembling instruction streams understand what instructions were executing on at the time 
    
    + processors 
    32bit processors x86 
    intel i-386 (Pentium)
    32bit registers 
    32bit addresses and data width 
    
    64bit processors(x64)
    AMD64 & Intel 64 chips 
    64-bit registers 
    64 bit addresses and data width 
    backwards compatible with x86 
    backwards compatible with x86 
    IA-64 itanium and alpha processors no longer provided on windows 
    
    + 32 bit registers 
    8 general purpose integer registers & 8 floating point registers 
    hold values for computation 
    addressable by byte word double-word 
    EAX, accumulator , holds return value from function calls 
    EBX, base register, used for counting during REP(repeat) operations 
    EDX, holds the high 32 bit returned by functions returning 64 bit values 
    EDI, ESI, used by block move and compare instructions(indexing)
    ESP, stack pointer, used for the address of the top of the stack 
    EBP, base pointer register, stack pointer for a given routine 
    
    special processor registers:
    EIP, instruction pointer 
    EFLAGS, flags register such as overflow, negative zero etc, zero flag 
    
    + 64 bit registers 
    16 general purpose integer registers and 16 floating point registers 
    addressable by byte word doulbe-word, quad-word 
    RAX, accumulator hold return value form function calls 
    RBX, base register, used for addressing memory as a pointer 
    RCX, count register, used for counting during REP(repeat) operations 
    RDI, RSI, used by block move and compare instructions(indexing)
    RSP, stack pointer used for the address of the top of the stack 
    RBP, base pointer register, stack pointer for a given routine 
    R8...R15, new regsiters for x64 
    
    dedicated regsiters:
    RIP, instruction pinter 
    RFLAGS, flags register 
    
    + windbg regsiters command 
    r, display integer register and current instruction 
    r<register name> displays the register contents 
    command variants 
        rF, displays floating pointer registers 
        rX, displays SSE XMM registers 
        
    Example usage: 
    kd> r 
    eax=f774f13c ....   //register values 
    nt!KeBugCheckEx+0x... //instruction current executed 
    
- multiprocessor systems 
    + multiprocessor system 
    multiple independent processors 
    widnows implements symmetric multiprocessing 
        no master processor 
        system or user threads run on any processor 
        
    processor affinity specify which processor is run on 
        control  which processors a thread will run 
        optimize throughput 
        partition workload 
        
    special inter-processor synchronization to avoid corrupt memory 
    spinlocks, ensure only one processor access the data at a time 
    inter-processor interrupts(IPI), to generate interprocessor interrupt 
    
    + windbg ~s command 
    windbg support multprocessor debugging 
    
    processors are numbered 0 through n-1 
    
    debugger command prompt reflects the current processor context 
    0 kd> the heading 0 indicates that processor 0 is current 
    
    use the ~s(tilde s) command to switch to a different processor 
    0 kd> ~1s 
    1 kd> 
    
    subsequent debugger commands execute in the new processor context 
    > !thread 
    > !process 
    > k 
    > r 

    + windbg !running command 
    !running displays the current thread on each processor 
    
    !running -t includes the stack trace for each thread 
    
    tilde ~
    
- sockets, cores, and hyper-thread 
    + sockets are connectors on system board for physical processors 
    + the number of sockets depends on the system hardware model to plug in processors 
    + cores contain a central processing unit(CPU)
    
    + physical processor can have two or more cores 
    dual core 
    quad core 
    up to 16 cores 
    
    + hyper threading technology provides simultaneous multi-threading 
    
    + hyper threading results in 2 logical processor per physical CPU 
    
    + windows server 2012 supports 640 logic processors 
    
    + windbg process commands 
    !cpuinfo, display cpu manufacturer, speed(mhz), features 
    
    !sysinfo cpuinfo, displays detailed processor information 
    
    !sysinfo machineid, displays system hardware model, BIOS, current executing thread id, idle thread on the cpu etc. 
    
    !pcr, displays processor control region used by windows 
    current thread 
    next thread 
    idle thread 
    IRQL(interrupt request level)
    DPC queue(Defferred procedure calls) 
    
- unassembling instruction 
    + processor instructions 
    output from compilers conssit of assembly instructions 
    
    + x86 and x64 instruction sets used by windows 
    
    + different types of instructions 
    arithmetic (ADD, SUB, MUL, DIV, SHL, INC, DEC, NEG)
    
    logic(OR, AND, XOR, NOT )
    
    data conversion(CBW, CWD, CWDE, CDQ)
    
    data transfer(MOV, MOVSX, MOVZX)
    
    string(MOVS, CMPS, STOS, LODS, SCAS)
    
    stack(PUSH, POP)
    
    Flow control(JMP, CALL, INT, CMP, TEST, JNZ, LOOP)
    
    + operands, arguments or parameters(zero, 1 or 2)
    
    + instructions are variable in length 
    
    + windbg unassemble command 
    u, display an assembly translation of the program in memory 
    
    u <address>, disassembles code starting at an address 
    
    u < address range> disassembles a range of addresses 
    
    ub <address> disassemble the preceding 8 instructions 
    
    uf <function name> disassemble an entire function 
    
    example usage: 
    kd> u address 
    
- summary 


# Investigating Locks and Spinlocks 
- module topics 
locks and resources 

debugging deadlocks 

spinlocks, avoid multiple processor access a same data 

analyzing spinlock hangs 

- locks & resources 
    + executive resources provide synchronization through out the windows kernel, specially in file system drivers 
    
    Example:
    nt!CmpRegistryLock, 
    
    + locks are used by threads to synchornize access to executive resource 
    
    + shared locks allow multiple threads owners 

    + exclusive locks permit only 1 thread owner 
    
    + example lock request 
    call ExAcquireResourceExclusiveLite will own a resource, the first argument of the function is the resource address 
    
    other threads may try to access the resource too, but as the resource is locked so the requests will be queued in a FIFO queue 
    
    + kernel locking functions to acquire resource locks 
    system functions used to acquire resource locks 
    ExAcquireResourceSharedLite 
    ExAcquireResourceExeclusiveLite 
    ExAcquireSharedStarveExclusive 
    ExAcquireWaitForExclusive 
    ExTryToAcquireResourceExclusiveLite 
    
    kb> kb 
    
    + windbg !locks command 
    !locks, used to display resources and locking information 
    
    !locks -v <resourceaddress> displays threads with lock requires on a resource 
    
    kd> !locks 
    the lock type and owner thread id will be marked with <*> 
    
- debugging dead locks 
    + hang caused by 2 or more threads wanting resources the other owns 
    
    + caused by a programming error or an outstanding I/O request not completing 
    
    both threads want something the other threads own 
    
    + finding deadlocks 
    use !locks to display locks held on resources 
    
    look for exclusively owned locks with waiter threads 
    
    thread owning the exclusive lock will have asterish* 
    
    kd> !locks 
    the all other waiting thread id are lised 
    
    + example owning threads 
    
    use !thread to display the thread that owns the exclusive lock 
    
    view the stack trace to determine why it is waiting 
    
    kd> !thread <address> 
    
- spinlocks 
!qlocks, will display the information for spinlocks 

spinlocks are used to synchronize access to common data structures with multiple processors 

processors try to acquire spinlocks to update data structures 

owner of the spinlock is guaranteed exclusive access 

other processors "spin" trying to acquire the spinlock 

potential hangs occur when the multiple processor all try to acquire the same spinlock and the owner of the spinlock is waiting on something else(e.g. stalled I/O request) 

- kernel spinlock functions 
KeAcquireSpinLock 
KeReleaseSpinLock 
KeAcquireQueuedSpinLock 
KeAcquireInStackQueueSpinLock 
KeAcquireSpinLockRaiseToSynch 

kd> k 
Ret addr 
hal!KeAcquireSpinLockRaiseToSynch+0x28 

    + display all kernel spinlocks, !qlocks 
kd> !qlocks 
Key: O = Owner, 1-n = wait order, blank = not owned/waiting, C = corrupt 

Lock name           Processor number 
                    0   1   2   ...  the number is processor number 
KEP -dispatcher                    
...
CC -Vacb            15  O   13  ...   the number is the wait order     
...

use !running --it command to display the information for the spinlock owner thread

- analyzing spinlock hangs, when you suspect the hang is caused 
    + suspect spinlock then using 
    $ !qlocks 
    to display any kernel spinlock owners 
    
    + using 
    $ !running -it 
    looking for threads and cpu trying to acquire spinlocks 
    check the method call KeAcquireSpinLock()
    
    will display the call stacks and at the bottom of the stacks the second number is the thread address
    
    + use 
    $ !thread <address>
    to exame stack trace leading up to spinlock requests 
    
    + the key is to determine which driver is responsible for acquiring spinlocks 

    
# Exploring Windows Virtual Memory 
- Module topics 
    + What is virtual memory? why it's important 
    + consumer of virtual memory 
        * user address space 
        * system address space 
        * !vm debugger command 
    + window virtual address space layouts 
        * x86(32 bit)
        * x64 
        * !memusage debugger command 
        
    + window memory pools to check the memory contents 
    $ !pool 
    $ !poolused 
    
    + displaying memory contents from virtual memory 
    
- virtual memory 
    + fundamental concept for OS, large memory address space size and independent of physical RAM 
    
    + not all process & thread data resides in physical memory all the time 
    
    + windows uses pagefile.sys for swapped out data 
    OS&User programs -mapped-> virtual memory -loaded-> physical memory RAM -swapped-> Pagefile.sys(Disk)
    
- Consumers of virtual memory divided into several sections 
    + private address space, major consumer, user processes live 
    
    where user processes live 
    
    1 per process 
    
    contains code and data 
    
    process threads share the same address space 
    
    + session address space. used to collectively by processes that are part of single user logon sessions. such ass winlogon process
    1 per user logon 
    
    contains session-wide code and data 
    
    part of system address space 
    
    + system address space 
    operating system code 
    
    device drivers 
    
    data structures 
    
    memory pools 
    
    + analyze a dump by using !vm to display the virtual memory information 
    
    physical memory(RAM)
    
    page file usage 
    
    available memory 
    
    modified pages 
    
    non-paged pool 
    
    paged pool 
    
    system committed memory 
    
    process private bytes 
    
    + demo check !vm command 
    kd> !vm 
    if any of the IO pages, modified pages, etc go to 0, that maybe need to concern 
    
- window virtual address space layouts 
    + x86 layout 
    1 bit can have 2 values (0 or 1)
    
    32 bits = 2^32 = 4 billion addressable locations 
    
    first 2 billion addresses are for user-mode code 
    
    next 2 billion address are for the widnows os 
    
    000000000       process address space (2gb)
                    user application code 
                    global variables 
                    user stacks 
                    dll code 
                    
    7FFFFFFFF       system address space  (2gb)    
                    kernel operating system 
                    drivers 
                    hal 
                    session space 
                    process page tables 
                    system cache 
                    non-paged pool 
    FFFFFFFFF
    
    + x64 layout 
    AMD and intel only imple
    + !memusage command to check the memory usage for virtua memory 
    
    will read from the pnf database 
    
- Windows memory pools 
    + non-paged memory pool 
    system memory buffers always resident in RAM. drivers live in. This will avoid access memory without any page fault 
    
    up to 128GB(or 75% of physical memory ) for x64 
    
    up to 2GB(or 75% of physical memory) for x86 
    
    system function ExAllocatePoolWithTag used to allocate pool 
        * specify NonPaged pool type as 1st argument 
        * specify size in bytes as 2nd argument
        * specify device driver ID tag as 3rd argument
        
    system function ExFreePoolWithTag used to deallocate pool 
    
    improperly allocating & deallocating buffers can cause pool corruption, override begin or end of memory pool will cause pool corruption. STOP C2 or STOP C5 
    
    + paged memory pool, allowed system to page out to disk. the device driver have to request a specific lower interrupt level to let the page to be back in 
    
    system memory buffers can be paged to disk 
    
    up to 128GB for x64 
    
    up to 2GB for x86 
    
    + WinDbg pool commands 
    !pool <address>, display information about pool allocation 
    
    !poolused, display paged & non-paged memory use by driver tag 
    
    !vm displays paged & non-paged pool usage and maximum limits 
    kd> !vm 
    
    
- display the content of virtual memory. use the d command to display memory from a dump 

    + hexadecimal, binary, octal and decimal notation 
    
    + byte 8 bits 00-FF
    
    + word 16bits 0000-FFFF
    
    + double word  32bits 
    
    + quad-word 
    
    + ascii representation - Abcd...
    
    + d command display the contents of memory location or rage 
    
    many variants 
    
    db  display byte 
    dw  display word 
    dd  display double word 
    dq  display quad word 
    dc  display ascii characters 

    kd> dc 
    
    db, dw may reverse display the content compare to dd/dq as lower address is displayed first 
    
    
# Windows Drivers and Interrupts 
- Module topics 
    + what is a driver? 
device drivers 
filter drivers 
WinDbg driver commands (lm and !lmi) for help examine the drivers 

    + I/O request packets (IRP)
    I/O request flow 
    WinDbg I/O commands (!irp, !irpfind, !devobj, !drvobj, !devstack, !object)
    to check the i/o queue 
    
    + interrupts request level (IRQL)
    !irql, !idt, !pcr 
    
    display irql from memory dumps
    
    + deferred procedure calls(DPC)
    !dpcs, !timer 
    
    how to use dpc to reduce IRQL to improve the performance 
    
- what is a driver? 
driver is a set of routines to process an I/O request. drivers operate in kernel model could cause system to crash 

works in conjunction with the window I/O manager 

numerous types of device drivers 
    + video drivers 
    + network drivers 
    + storage drivers 
    + sound drivers 
    + print drivers, is operate in user mode which will not cause the system to crash 
    + bus drivers 
    + file system drivers 
    + plug and play drivers 
    
- filter drivers 
filter drivers are used to augment device drivers 

logically layered above or below device drivers 

    + anti-virus drivers 
    + file screening 
    + disk quotas 
    + deduplication 
    + disk mirroring 
    
    + for example process 
    I/O write request -> filter driver -> check disk quota -> device driver perform write operation 
    
- windbg driver commands 
    + lm list loaded modules (drivers)
    
    numerous variants 
    
    > lm t n
    list moduels with time stamps and driver/module names 
    
    > lmvm <modulename> 
    detailed driver/module information 
    
    > !lmi <modulename> 
    displays detailed driver/module information 
    
    kd> lmvm hal 
    
- I/O request packets (IRP)
Thread calls ReadFile() application 
ReadFile            |
        Call NtReadFile()       Kernel32.dll 
                    |
NtReadFile      SYSENTER<--+    Ntdll.dll  lead to a system trap
                    |      |
                    V      |            User mode 
---------------------------|----------------
                           |            Kernel mode 
KiSystemService Call NtReadFile()<-+ Ntoskrml.exe
                                   |
NtReadFile      Invoke driver -----+ Ntoskrnl.exe
                              <--------+
                                       |
                Initiate I/O operation-+ drivers.sys 

    + during this process a data structure IRP is used by the I/O manager & device drivers 
    
    + contains information needed to process an I/O request 
    
    + threads initiate the I/O requests 
    
    + I/O manager allocates an IRP from the IRP nonpaged look-aside list 
    
    + IRPs are linked to the thread data structure
    
    + IRP is dispatched to corresponding driver 
    
    Thread -request I/O-> I/O manager -allocate IRP-> IRP function -> Driver 
    IRP list                                            |
     A                                                  |
     |                                                  |
     +--------------------------------------------------+
        IRP linked to thread 
     
    + WinDbg I/O commands 
    !thread, reveals any outstanding IRPs for the thread 
    !irp, displays detailed information about a IRP 
    !irpfind, displays information about all IRPs currently allocated 
    !devobj, display detailed information about a driver object 
    !drvobj, display detailed information about a driver object 
    !devstack, displays the device stack associated with a device object 
    !object, displays information about a system object 
    
    
    !drvobj \FileSystem\Ntfs 
    the address display by the thread 
    
    !devobj <address> 
    
    !object <address> 
    
    
    check the first line of each command to get the column title. use the !thread to get the thread information and it will contain the IRP list  
    
    !irp <irp_list_address> 
    the address could be found from the !thread command 
    
- Interrupt request levels(IRQL). Window is an interrupts driven operation system 

    + devices interrupt at a particular interrupt request level 
    dictate the system flow and control of the system 
    
    + higher IRQLs will preempt lower IRQLs 
    
    + each processor maintains an interrupt dispatch table(IDT). 
    
    + interrupts map to a particular Interrupt Service Routine(ISR) in the IDT
    
    + ISR will request a Deferred Procedure Call(DPC) to perform the work 

    keyboard -interrupt -> keyboard interrupt -> keyboard interrupt service 
                            dispatch table          routine 
                                                    IRQLx 
                                                ISR will perform the initial work on the request I/O 
                                                including raising the IRQL level to synchronize its effort. it will request a DPC providing the address of the driver's DPC routine  
    + interrupt request levels 
    x86 has 32 IRQLs and x64 has 16 IRQLs 
    
    highest IRQLs are reserved for hardware interrupts. such as system clock and device drivers 
    
    software IRQLs occurred at IRQL2 and below such as DPCs and asynchronous procedure calls 
    
    normal thread activity occurs at IRQL 0 
    
        * diagram for x86 IRQLs 
        31  High 
        30  Power Fail 
        29  inter-processor interrupt 
        28  clock 
        27  profile/synch 
        26  device n 
        ...
        3   device 1 
        2   DPC/dispatch 
        1   APC 
        0   Passive 
        
        * x64 IRQLs 
        15  High/Profile 
        14  Power/IPI 
        13  clock 
        12  Synch 
        11  Device n 
        ...
        3   Device 1 
        2   DPC/dispatch 
        1   APC 
        0   Passive 
        
    + windbg interrupt commands 
    !idt, display the interrupt dispatch table listing the ISRs 
    
    !irql, display the IRQL just prior to the bugcheck 
    
    !pcr, displays the processor status including the current IRQL 
    
        * demo 
        load the dump file 
        
        kd> !idt 
        all the routines will be listed 
        
        kd> !irql 
        will list the processor's IRQL information 
        
        kd> !pcr 
        will display IRQL control region 
        
- Deferred procedure calls (DPC)
    + DPC performs most of the work involved with a device interrupt 
    
    this will block all the activity below the IRQL level. driver will typically defer any work can be done at lower IRQL 
    
    + created by the device driver's interrupt service routine(ISR)
    
    + also created by system components to perform a system task. system can request a DPC task 
    
    + DPCs are dispatched at IRQL 2
    
    only the level below and equal to 2 are used for software such as DPC or APC 
    
    + different DPC priority levels (support different low, medium, high). high priority will be insert into the head of the processor's DPC queue. low will be insert at the end 
    
    + each processor has its own DPC queue for DPCs 
    
    + starts executing at the kernel function specified in the DPC object 
        
    the kernel function typically be the device driver's DPC routine for the I/O function that was request by the user application 
    
        * graph 
    Interrupt Service Routine execute a particular IRQL associate with the device that cause the interrupt. after the time critical part of the ISR executed. the DPC will execute at lower IRQL to avoid blocking any other device 
    IRQL x 
    . 
    . 
    . 
    Request DPC -----------------> DPC object.  the created DPC object will be 
                                   Dispatched 
                                   ...
                                   DPC function -> Processor Control Region 
                                                   Append to the DPC queue
                                                   When the object reaches the
                                                   front of the queue 
                                                   |
                                                   |
                                                   V 
                                                   Driver DPC function 
                                                   When the DPC object get
                                                   to the front of the queue
                                                   it will first reduce the IRQL 
                                                   to 2 and then perform the 
                                                   remain works 
                                                   IRQL 2 
                                                   . 
                                                   . 
    + windbg command for helping exame the DPC 
    !dpcs, displays the DPC queues for a specified processor 
    
    !pcr, displays the processor control region including DPC queues 
    
    !timer, displays system timers and the DPC or thread to run 
    
        * demo 
        kd> !dpcs 
        will show all the dpcs of a processor 
        
        kd> !pcr 
        
        kd> !timer 
        will display the timers which depends on the system 
        
- Summary 
drivers are used to process an I/O request 

device drivers and filter drivers 

IRPs describe the I/O requests 

IRQLs control device interrupts 

drivers defer most work for DPCs 

variety of Windbg commands to display drivers, IRPs, IRQLs and DPCs 
        
     
# Forcing Windows Memory Dumps 
- force memory dump on a hung or locked up system for helping debugging 
- module topics 
    + why do windows servers hang? 
    + forcing a memory dump with NotMyFault 
    + forcing a memory dump with a keyboard 
    + forcing a memory dump with a non-maskable interrupt 

- why do windows servers hang? 
    + not enough memory resources 
    available physical memory 
    paged and non-aged pools 
    
    + kernel-mode deadlocks 
    
    + driver spinlock hangs 
    
    + runaway high priority compute-bound thread 
    
    + interrupting device drivers caused by faulty devices 
    
    
MEMORY DUMP MUST BE MANUALLY FORCED for hang system 

- ways to force a memory dump 
    + run kernel-mode code that is designed to crash a system (NotMyFault)
    
    system must be minimally functional 
    
    + special keyboard control & function. keystroke used to crash a system 
    
    results in a stop 0xe2 bugcheck 
    
    + hyper-v manager connected session to a virtual machine with keystroke 
    
    + generating a non-maskable interrupt (NMI)
    result in a stop 0x80 bugcheck 
    
- demo generate dump with NotMyFault
    + free tool 
    http://download.sysinternals.com/files/NotMyFault.zip 
    
    system internal tools 
    
    + documented in microsoft article (KB969028)
    http://support.microsoft.com/kb/969028 
    
    + graphical user interface(GUI)
    
    + command line interface 
    $ notmyfault.exe /crash 
    
    + system must be minimally functional 
    in order to execute the notmyfault.exe tool 
    

    + the tool can 
    crash with high IRL fault 
    hang with IRP 
    simulate memory leak etc. 
    
    + CLI 
    useful for scripting an automated memory dump 
    
    use on windows server core installation types 
    $ notmyfault [/crash][/bugcheck <code>]
    /crash,  crashes the system with a high IRQL fault 
    /bugcheck code, crashes the system with specified stop code e.g. notmyfault /bugcheck 0xe2

    + check the dump which is generated NotMyFault
    
    $ !analyze -v 
    
    check the information and which instruction cause the crash 
    
    use !thread to check which thread is executing 
    $ !thread 
    
    $ !irp <address>
    will display the driver 
    
    $ !drvobj <driver object path> 
    will display the \Driver\MYFAULT 
    
    $ k 
    will display the call stack 
    
    $ u <start address> <end address> 
    
    rbx out of bounds cause the crash 
    
- Forcing a crash with a PS/2 keyboard

    + allows you to force a system memory dump from a PS/2 keyboard 
    
    + performed on the system console, not remotely via Remote Desktop 
    
    + Works with virtual machines if connected through Hyper-V manager 
    
    + uses a special keystroke combination 
    Right-Ctrl + Scroll Lock(twice)
    
    + required setup registry value CrashOnCtrlScroll 
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\i8042prt\Parameters
    CrashOnCtrlScroll REG_DWORD value of 0x01 

    required to reboot to make it take effect 
    + Results in a stop 0xe2 bugcheck (MANUALLY_INITIATED_CRASH)
    
    + Additional documentation in microsoft MSDN 
    http://msdn.microsoft.com/en-us/library/ff545499.aspx 
    
    
- Forcing a Crash with a USB keyboard 
    + the only difference compare to PS/2 is a different registry key 
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\kbdhid\Parameters
    CrashOnCtrlScroll REG_DWORD value of 0x01 
    
    + demo 
    make system hang with NotMyFault 
    
    press the keystroke to generate the dump 
    
    check dump with the previous process 
    
    we can she NotMyFault just jmp to same address to make the system hang 
    
- Non-Maskable interrupts (NMI)
hardware/BIOS induced memory dump 

H/W or virtual NMI switch 

some of the BIOS support or provide switch 

    + dell, IBM, HP provide different mechanisms 
    
    + allows you to force a memory dump by generating NMI 
    http://support.microsoft.com/kb/927069 
    
    + create new registry value NMICrashDump 
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CrashControl
    NMICrashDump    REG_DWORD value of 0x01 
    
    + windows server 2012 & window 8 do not require NMICrashDump enabled from registry 
    http://support.microsoft.com/kb/2750146

    + results in a stop 0x80 bugcheck (NMI_HARDWARE_FAILURE) but sometimes this means real hardware failure 

    + Example document for HP Proliant servers 
    http://h20195.www2.hp.com/V2/GetDocument.aspx?docname=4AA4-7853ENW&cc=us&lc=en

- summary 
system hangs require manually intervention to force a memory dump 

NotMyFault is a tool used to force a memory dump 

console keyboard with special keystroke combinations can be used to force a memory dump 

hardware or virtual NMI buttons can be used to force a memory dump 




















































    
    
    
    
    
    
    
    
    
    
    