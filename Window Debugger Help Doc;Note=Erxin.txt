Window Debugger Help Doc;Note=Erxin

# Introduction
- window sdk 10 debugger document note 

# Getting started with windows debugging, window debug main process 
- if your code is communicate with low leve hardware then suggest not use virtual machine as target 
- determine if you are will be doing kernel or user mode debugging 
    + kernel mode 
    gain full access to system resource 
    os functionality and system driver have this privileged 
    
    + user mode for normal application process 
    
some of the debug command may have different function 

- set up debug environment 
- connect the target and host system 
    + set up kernel mode dubbging manually, over 
    
    + setup debug environment in visual studio 
    
- choose 32-bit or 64-bit debugging tool 
- configure symbols 
- configure source code 
- familiar with debugger operations 
- become familiar with debugging techniques 
- use the debugger reference commands 
- use debugging extensions for specific technologies 


# getting start with windbg(user-mode)
- launch notepad adn attach windbg 
    + attach to process 
    + specify symbol path 
    > .sympath srv* 
    Symbol search path is: srv* 
    Expanded Symbol search path is: cache*;SRV*http://msdl.microsoft.com/download/symbols

for custom build application to set symbo by 
> .sympath srv*

> .sympath+ C:\MyApp\x64\Debug

> .srcpath C:\MyApp\MyApp

    + reload to initla windbg find and loading symbol files 
    > .reload 
    
    + see symbols for the notepad.exe module 
    > x notepad!*
    
    to see symbols contain main 
    > x notepad!*main 
    
    + put a break point at notepad!WinMain enter this 
    > bu notepad!WinMain 
    
    + verify your breakpoint was set by 
    > bl 
    
    + start notepad running by 
    > g 
    
    + check all the code modules that are loaded in the notepad process 
    > lm 
    
    + check stack trace 
    > k 
    
    + list all the threads 
    > ~ 
    
    + look at the stack trace for thread 0 
    > ~0s 
    
    + quit debugging 
    > qd 
    
    + when encounter a problem, let winDbg analyze the error information by 
    > !analyze -v
    
 
# getting started with windbg (kernel-mode)
- setup a kernel-model debugging 
host computer 
target computer 

debug cable type 
ethernet 
usb 2/3 
1394 
serial(null modem)

if window 8+ then all types of cable are supported, if not the ethernet is not avalable 

- establish a kernel-mode debugging session 
    + from network cable 
    + from usb 2.0
- get started using windbg 
    + on host open windbg, establish a kernel-model debugging sessions from File|Kernel Debug menu 
    + from the windbg window cmd line enter 
    > .sympath srv* 
    
    > .reload
    
    + see a list of loaded module 
    > lm 
    
    + start target computer running 
    > g 
    
    + break again 
    
    + examine the _FILE_OBJECT data type in the nt module 
    > dt nt!_FILE_OBJECT
    
    + enter the command to examine some of the symbols in the nt module 
    > x nt!*CreateProcess* 
    
    + enter this commadn to put a breakpoint at MmCreateProcessAddressSpace 
    > bu nt!MmCreateProcessAddressSpace
    
    verify the setted breakpoints 
    > bl 
    
    > g 
    
    if target computer doesn't break into the debugger immediately, perform a few actions(such as open nodepad)
    
    + after break input 
    > .reload 
    > k 
    to check the call stack 
    
    + on the view check disassmbly, choose step over or press F10 
    
    + clear your breakpoint by entering this command 
    > bc * 
    
    + list all processes 
    > !process 0 0 
    
    + copy the address of one process and enter this command 
    > !process Address 2 
    
    + copy the address of one thread enter 
    > !thread Address 
    
    + see all the device nodes in the plug and play device tree enter 
    > !devnode 0 1 
    
    + see device nodes along their hardware resources 
    > !devnode 0 9 
    
    + see device node that has a service name of disk 
    > !devnode 0 1 disk 
    
    + output of !devnode 0 1 displays the address of the physical device object(PDO) for the node. copy address of a physical object(PDO) and enter this 
    > !devstack PdoAddress 
    
    + get information about driver disk.sys 
    > !drvobj disk 2 
    
    + output of !drvobj displays addresses of dispatch routines for example CLASSNP!ClassGlobalDispatch, to set and verify breakpoint with 
    > bu CLASSPNP!ClassGlobalDispatch
    > bl 
    after hit break point 
    > .reload 
    > k 
    
    + end debug session 
    > qd 
    
- window debug command and syntax 
https://msdn.microsoft.com/en-us/library/windows/hardware/ff540507%28v=vs.85%29.aspx


# Choosing 32bit or 64bit debugger 
- when use visual studio, you don't have to consider this 
- when use windbg, kd, cdb, or ntsd you have to make choice yourself
- when x64 base host with running 64 bit version of windows 
    + analyzing a dump file, you can ue either 32 or 64 
    
    + live kernel-mode debug, you can use either 32-bit or 64 base on target 
    
    + debugging user mode on same computer, 64 for 64, 32 for 32 
    

# debugging environment 
- contains 
vs 
windbg 
kd, kernel debugger 
ntkd 
cdb, console debugger 
ntsd, nt symbolic debugger 

- VS with integrated window debugger 
    + supported 
Configure a set of target computers for debugging. 
Configure the debugging connections to a set of target computers. 
Launch a kernel-mode debugging session between the host computer and a target computer. 
Debug a user-mode process on the host computer. 
Debug a user-mode process on a target computer. 
Connect to remote debugging sessions. 
View assembly code and source code. 
View and manipulate local variables, parameters, and other symbols. 
View and manipulate memory. 
Navigate call stacks. 
Set breakpoints. 
Execute debugger commands. 

    + also support develop and debug drivers some of the WDK capabilities are integrated into VS 
Configure a set of target computers for driver testing. 
Create and sign a driver package. 
Deploy a driver package to a target computer. 
Install and load a driver on a target computer. 
Test a driver on a target computer. 

- windbg, support user and kernel mode, use VS debug symbol format. can access any public function's name that is exposed by modules that were compiled with COFF symbol files such as *.dbg files 

- kd, character-based console program, enables in depth analysis of kernel mode activity on all nt-based operating system. debug driver or monitor os. typically you need two computer 

- ntkd, variation of kd. variation of the kd debugger. identical to kd except spawns a new text window when it is started, where as kd inherits the command prompt widnow from which it was invoked 

- cdb, character-based console program enables low-level analysis of window user-mode memory and constructs. 

powerful for debugging a program current running or has recently crashed(live analysis)

it can be used to obtain stack trace or look at the guilty parameters 

with cdb you can display and execute program code, set bp and examine change values in memory. cbd can access memory location through addresses or global symbols you can refer to data and instructions by name rather than by address 

support multiple processes can read poth paged and non-paged memory. it target is console app then will share consle with cdb also support spwan a new window 

- ntsd, it is identical to cbd in every way, except spawns a new text wndow. fully capabile of debugging consle and window program. Controlling NTSD from the kernel debugger is therefore especially useful, since it results in an extremely light-weight debugger that places almost no burden on the computer containing the target application. This combination can be used to debug system processes, shutdown, and the later stages of boot up.

check the charpter about the user-mode debugger from the kernel debugger 


# Setting up Debugging(kernel -mode and user mode)
## setup kernel-mode in VS 
### Setup kernel-mode debugging over network cable in VS 
- to use VS do kernel-mode debugging you must have Windows Driver Kit integrated with VS 
check more info from window driver development http://go.microsoft.com/fwlink/p?linkid=301383

- configure host and target 
    + on host in VS, go to the computer configuration dialog select Provision compter and choose debugger settings 
    
    + connection type select network 
    
    + port choose from 49152 through 65535 
    
    + use the automatic generated key 
    
    + set the bus paramter if target computer contain more than one network cards. if target only contain one card than keep it empty 
    Bus Parameters, enter b.d.f where b, d, and f are the bus number, device number, and function number of the adapter
    
    + configuration process takes several minutes and might automatically reboot the target computer once or twice 
    
    + enable or disable kernel debugging by command Prompt window as Administrator and enter the command bcdedit /debug off. Reboot the target computer.
    $ bcdedit /debug off 
    
    + verify dbgsettings on target 
    
    $ bcdedit /dbgsettings 
    $ bcdedit /enum 
    
    if you don't see the value entered for Bus paramters, enter this command 
    $ bcdedit /set "{dbgsettings}" busparams b.d.f

    where b, d, and f are the bus, device, and function numbers of the network adapter on the target computer that you have chosen to use for debugging
    
    Reboot the target computer.
    
    + starting the debugging session 
    on host VS|Tools | Attah to Process 
    
    from transport choose Window Kernel Mode Debugger 
    
    Qualifier select name of the target computer that your previous configured 
    
    + click attach 
    
- creating your own key, Network debugging uses a 256-bit key that is specified as four 64-bit values, in base 36, separated by periods. Each 64-bit value is specified by using up to 13 characters

- troubleshooting tips for debugging over a network cable . windbg or kd must have access through the firewall 

- change port number 
on host VS | Driver menu |Configure Computers 
select target computer click next 
select Provision computer and choose debugger settings and next 
reset the port number and next 

### setting up kernel-mode debugging of a virtual machine in VS 
- virtual machine can be located on the same physical computer as the debugger or on a different computer 

required WDK 

- in the virtual machine enter command 
> bcdedit /debug on 
> bcdedit /dbgsettings serial debugport:n baudrate:115200 
  
n is the COM port on the virtual machine 
  
reboot 

- in the VM configure the COM port to map to a named pip. check your virtual machine document for this 

- configuring the host 

    + Driver menu Test|Configure computer 
    
    + add new computer give the physical computer name contain the VM 
    + select manually configure debuggers and do not provision and click next 
    + connect type click serial 
    + check pipe and check reconnect 
    + if the debugger is running on the same computer name as VM enter this pip name 
    \\.\pipe\pip-name 
    
    on different physical computer use 
    \\vm-host\pip\pip-name 
    
    + finish 
    
- starting debugging session 
    + on host VS|Tools|Attach to process 
    + transport choose window kernel mode debugger 
    + qualifier select name of the physical computer that is running the target virtual machine 
    + attach 
- generation 2 vritual machine 
    + COM ports are not presented in generation 2 virtual machines. you can add COM ports through powershell or wmi for COM ports to be displayed 
    
        * disable secure boot by entering this powershell comand 
        Set-VMFirmware-Vmname vm-name -EnableSecureBoot Off 
        
        * add a com port to the virtual machine by 
        Set-VMFirmware-Vmname vm-name 1 \\.\pipe\PipeName 
        
        * configures the first com port on virtual machine TestVM to connect to named pipe 
        Set-VMFirmware-Vmname TestVM 1 \\.\pipe\TestPipe
    
### setting up kernel-mode debugging over a newwork cable manually 
    
    

## conditional breakpoints 
- with either the j(execute if - else) command or the .if token, followed by the gc(go from conditional breakpoint) command. 

0:000> bp Address "j (Condition) 'OptionalCommands'; 'gc' "

0:000> bp Address ".if (Condition) {OptionalCommands} .else {gc}"

- base on string comparison 
break into the debugger only if a string variable matches a pattern, for example. suppose want to break at kernel32!CreateEventW only if the lpName argument points to a string that matches the pattern "global*"

bp kernel32!CreateEventW "$$<c:\\commands.txt"

the script file commands.txt contain the following statements 
.if (@r9 != 0) { as /mu ${/v:EventName} @r9 } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "Global*") == 0)  { gc } .else { .echo EventName }

The lpName argument passed to the CreateEventW function is the fourth argument, so it is stored in the r9 register (x64 processor)

If lpName is not NULL, use as and ${} to create an alias named EventName. Assign to EventName the null-terminated Unicode string beginning at the address pointed to by lpName. On the other hand, if lpName is NULL, use ad to delete any existing alias named EventName
Use $spat to compare the string represented by EventName to the pattern "Global*". If the string does not match the pattern, use gc to continue without breaking. If the string does match the pattern, break and display the string represented by EventName

$spat performs a case-insenstive match 

- conditional breakpoint base on register value 
The following command will break at the beginning of the myFunction function if the eax register is equal to 0xA3:

0:000> bp mydriver!myFunction "j @eax = 0xa3  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xa3  {} .else {gc}"
 
The following 


## Executing until a specified state is reached 
- 
















































