Window Debugger Help Doc;Note=Erxin

# Introduction
- window sdk 10 debugger document note 

# Getting started with windows debugging, window debug main process 
- if your code is communicate with low leve hardware then suggest not use virtual machine as target 
- determine if you are will be doing kernel or user mode debugging 
    + kernel mode 
    gain full access to system resource 
    os functionality and system driver have this privileged 
    
    + user mode for normal application process 
    
some of the debug command may have different function 

- set up debug environment 
- connect the target and host system 
    + set up kernel mode dubbging manually, over 
    
    + setup debug environment in visual studio 
    
- choose 32-bit or 64-bit debugging tool 
- configure symbols 
- configure source code 
- familiar with debugger operations 
- become familiar with debugging techniques 
- use the debugger reference commands 
- use debugging extensions for specific technologies 


# getting start with windbg(user-mode)
- launch notepad adn attach windbg 
    + attach to process 
    + specify symbol path 
    > .sympath srv* 
    Symbol search path is: srv* 
    Expanded Symbol search path is: cache*;SRV*http://msdl.microsoft.com/download/symbols

for custom build application to set symbo by 
> .sympath srv*

> .sympath+ C:\MyApp\x64\Debug

> .srcpath C:\MyApp\MyApp

    + reload to initla windbg find and loading symbol files 
    > .reload 
    
    + see symbols for the notepad.exe module 
    > x notepad!*
    
    to see symbols contain main 
    > x notepad!*main 
    
    + put a break point at notepad!WinMain enter this 
    > bu notepad!WinMain 
    
    + verify your breakpoint was set by 
    > bl 
    
    + start notepad running by 
    > g 
    
    + check all the code modules that are loaded in the notepad process 
    > lm 
    
    + check stack trace 
    > k 
    
    + list all the threads 
    > ~ 
    
    + look at the stack trace for thread 0 
    > ~0s 
    
    + quit debugging 
    > qd 
    
    + when encounter a problem, let winDbg analyze the error information by 
    > !analyze -v
    
 
# getting started with windbg (kernel-mode)
- setup a kernel-model debugging 
host computer 
target computer 

debug cable type 
ethernet 
usb 2/3 
1394 
serial(null modem)

if window 8+ then all types of cable are supported, if not the ethernet is not avalable 

- establish a kernel-mode debugging session 
    + from network cable 
    + from usb 2.0
- get started using windbg 
    + on host open windbg, establish a kernel-model debugging sessions from File|Kernel Debug menu 
    + from the windbg window cmd line enter 
    > .sympath srv* 
    
    > .reload
    
    + see a list of loaded module 
    > lm 
    
    + start target computer running 
    > g 
    
    + break again 
    
    + examine the _FILE_OBJECT data type in the nt module 
    > dt nt!_FILE_OBJECT
    
    + enter the command to examine some of the symbols in the nt module 
    > x nt!*CreateProcess* 
    
    + enter this commadn to put a breakpoint at MmCreateProcessAddressSpace 
    > bu nt!MmCreateProcessAddressSpace
    
    verify the setted breakpoints 
    > bl 
    
    > g 
    
    if target computer doesn't break into the debugger immediately, perform a few actions(such as open nodepad)
    
    + after break input 
    > .reload 
    > k 
    to check the call stack 
    
    + on the view check disassmbly, choose step over or press F10 
    
    + clear your breakpoint by entering this command 
    > bc * 
    
    + list all processes 
    > !process 0 0 
    
    + copy the address of one process and enter this command 
    > !process Address 2 
    
    + copy the address of one thread enter 
    > !thread Address 
    
    + see all the device nodes in the plug and play device tree enter 
    > !devnode 0 1 
    
    + see device nodes along their hardware resources 
    > !devnode 0 9 
    
    + see device node that has a service name of disk 
    > !devnode 0 1 disk 
    
    + output of !devnode 0 1 displays the address of the physical device object(PDO) for the node. copy address of a physical object(PDO) and enter this 
    > !devstack PdoAddress 
    
    + get information about driver disk.sys 
    > !drvobj disk 2 
    
    + output of !drvobj displays addresses of dispatch routines for example CLASSNP!ClassGlobalDispatch, to set and verify breakpoint with 
    > bu CLASSPNP!ClassGlobalDispatch
    > bl 
    after hit break point 
    > .reload 
    > k 
    
    + end debug session 
    > qd 
    
- window debug command and syntax 
https://msdn.microsoft.com/en-us/library/windows/hardware/ff540507%28v=vs.85%29.aspx


# Choosing 32bit or 64bit debugger 
- when use visual studio, you don't have to consider this 
- when use windbg, kd, cdb, or ntsd you have to make choice yourself
- when x64 base host with running 64 bit version of windows 
    + analyzing a dump file, you can ue either 32 or 64 
    
    + live kernel-mode debug, you can use either 32-bit or 64 base on target 
    
    + debugging user mode on same computer, 64 for 64, 32 for 32 
    

# debugging environment 
- contains 
vs 
windbg 
kd, kernel debugger 
ntkd 
cdb, console debugger 
ntsd, nt symbolic debugger 

- VS with integrated window debugger 
    + supported 
Configure a set of target computers for debugging. 
Configure the debugging connections to a set of target computers. 
Launch a kernel-mode debugging session between the host computer and a target computer. 
Debug a user-mode process on the host computer. 
Debug a user-mode process on a target computer. 
Connect to remote debugging sessions. 
View assembly code and source code. 
View and manipulate local variables, parameters, and other symbols. 
View and manipulate memory. 
Navigate call stacks. 
Set breakpoints. 
Execute debugger commands. 

    + also support develop and debug drivers some of the WDK capabilities are integrated into VS 
Configure a set of target computers for driver testing. 
Create and sign a driver package. 
Deploy a driver package to a target computer. 
Install and load a driver on a target computer. 
Test a driver on a target computer. 

- windbg, support user and kernel mode, use VS debug symbol format. can access any public function's name that is exposed by modules that were compiled with COFF symbol files such as *.dbg files 

- kd, character-based console program, enables in depth analysis of kernel mode activity on all nt-based operating system. debug driver or monitor os. typically you need two computer 

- ntkd, variation of kd. variation of the kd debugger. identical to kd except spawns a new text window when it is started, where as kd inherits the command prompt widnow from which it was invoked 

- cdb, character-based console program enables low-level analysis of window user-mode memory and constructs. 

powerful for debugging a program current running or has recently crashed(live analysis)

it can be used to obtain stack trace or look at the guilty parameters 

with cdb you can display and execute program code, set bp and examine change values in memory. cbd can access memory location through addresses or global symbols you can refer to data and instructions by name rather than by address 

support multiple processes can read poth paged and non-paged memory. it target is console app then will share consle with cdb also support spwan a new window 

- ntsd, it is identical to cbd in every way, except spawns a new text wndow. fully capabile of debugging consle and window program. Controlling NTSD from the kernel debugger is therefore especially useful, since it results in an extremely light-weight debugger that places almost no burden on the computer containing the target application. This combination can be used to debug system processes, shutdown, and the later stages of boot up.

check the charpter about the user-mode debugger from the kernel debugger 


# Setting up Debugging(kernel -mode and user mode)
## setup kernel-mode in VS 
### Setup kernel-mode debugging over network cable in VS 
- to use VS do kernel-mode debugging you must have Windows Driver Kit integrated with VS 
check more info from window driver development http://go.microsoft.com/fwlink/p?linkid=301383

- configure host and target 
    + on host in VS, go to the computer configuration dialog select Provision compter and choose debugger settings 
    
    + connection type select network 
    
    + port choose from 49152 through 65535 
    
    + use the automatic generated key 
    
    + set the bus paramter if target computer contain more than one network cards. if target only contain one card than keep it empty 
    Bus Parameters, enter b.d.f where b, d, and f are the bus number, device number, and function number of the adapter
    
    + configuration process takes several minutes and might automatically reboot the target computer once or twice 
    
    + enable or disable kernel debugging by command Prompt window as Administrator and enter the command bcdedit /debug off. Reboot the target computer.
    $ bcdedit /debug off 
    
    + verify dbgsettings on target 
    
    $ bcdedit /dbgsettings 
    $ bcdedit /enum 
    
    if you don't see the value entered for Bus paramters, enter this command 
    $ bcdedit /set "{dbgsettings}" busparams b.d.f

    where b, d, and f are the bus, device, and function numbers of the network adapter on the target computer that you have chosen to use for debugging
    
    Reboot the target computer.
    
    + starting the debugging session 
    on host VS|Tools | Attah to Process 
    
    from transport choose Window Kernel Mode Debugger 
    
    Qualifier select name of the target computer that your previous configured 
    
    + click attach 
    
- creating your own key, Network debugging uses a 256-bit key that is specified as four 64-bit values, in base 36, separated by periods. Each 64-bit value is specified by using up to 13 characters

- troubleshooting tips for debugging over a network cable . windbg or kd must have access through the firewall 

- change port number 
on host VS | Driver menu |Configure Computers 
select target computer click next 
select Provision computer and choose debugger settings and next 
reset the port number and next 

### setting up kernel-mode debugging of a virtual machine in VS 
- virtual machine can be located on the same physical computer as the debugger or on a different computer 

required WDK 

- in the virtual machine enter command 
> bcdedit /debug on 
> bcdedit /dbgsettings serial debugport:n baudrate:115200 
  
n is the COM port on the virtual machine 
  
reboot 

- in the VM configure the COM port to map to a named pip. check your virtual machine document for this 

- configuring the host 

    + Driver menu Test|Configure computer 
    
    + add new computer give the physical computer name contain the VM 
    + select manually configure debuggers and do not provision and click next 
    + connect type click serial 
    + check pipe and check reconnect 
    + if the debugger is running on the same computer name as VM enter this pip name 
    \\.\pipe\pip-name 
    
    on different physical computer use 
    \\vm-host\pip\pip-name 
    
    + finish 
    
- starting debugging session 
    + on host VS|Tools|Attach to process 
    + transport choose window kernel mode debugger 
    + qualifier select name of the physical computer that is running the target virtual machine 
    + attach 
- generation 2 vritual machine 
    + COM ports are not presented in generation 2 virtual machines. you can add COM ports through powershell or wmi for COM ports to be displayed 
    
        * disable secure boot by entering this powershell comand 
        Set-VMFirmware-Vmname vm-name -EnableSecureBoot Off 
        
        * add a com port to the virtual machine by 
        Set-VMFirmware-Vmname vm-name 1 \\.\pipe\PipeName 
        
        * configures the first com port on virtual machine TestVM to connect to named pipe 
        Set-VMFirmware-Vmname TestVM 1 \\.\pipe\TestPipe
    
### setting up kernel-mode debugging over a newwork cable manually 
    
### supported eithernet NICs for network kernel debugging in window 8+


### setup user mode debugging in VS 
- there are two user-mode debuggers available in VS one is the windows user-mode debugger 
    + one contain in the debuggings tools for windows 
    + VS debugger which is part of VS 
    
- debugging user-mode process on the local computer, attach process or launching process under the debugger 

- debugging a user-mode process on a target computer 
debugger runs on the host computer the code that is being debugged runs on target computer 
    + in VS use the user-mode debugger to attach process 
    + on target computer set Control Panel>Network and Internet>Network and Sharing Center>Advanced sharing settings. Under Guest or Public, select Turn on network discovery and Turn on file and printer sharing.
    + do the rest of configuration on the host 
    + VS tools > attach to process 
    + for transport choose window user mode debugger 
    + qualifier click browse 
    + click add 
    + enter target computer 
    + click Configure Target Computer
    + Click ok 
    
- if target is a VM host, requires, set up network debugging before add hyper-v role. if set debugging after added hyper-v role, must change the network settings for your virtual machines to bridge them to the microsoft kernel network debug adapter. other wise the virtual machines will not have access to the network 
    + target computer has a single network interface card 
    + install the hyper-v role on the target computer 
    + create one or more vitual machines on the target computer 
    
### configure tools.ini
- contains information to initialize the command-line debuggers 
- windbg saves initialization settings in workspaces 
- tools.ini entries are shown in the following table 

$u0:value ... $u9:value, assig values to fixed-name aliases 
DebugChildren:flag TRUE or FALSE
LazyLoad 
SetDll:filename, set extension dll. 
StopFirst:flag
StopOnProcessExit:flag 
sxd:event, sets the debugger resposne and the handling status for the specified exception or event 
sxe:event
IniFile, specifies the name of the ini file 
- section headers 
[CDB], [NTSD], and [KD].
- example 
[NTSD]
sxe: 3c
sxe: cc
$u0: VeryLongName
VerboseOutput:true

### Using KDbgCtrl
- KDbgCtrl, kernel debugging control, kdbgctrl.exe can be used to control the kernel debugging connection from the target computer
- can control five different settings 
full kernel debugging 
automatic kernel debugging 
user-mode error handling 
blocking of kernel debugging 
the size of DbgPrint buffer 

- first must enable kernel debugging  
- full kernel debugging is enable by default 
$ kdbgctrl -c 
check current settings 

$ kdbgctrl -d 
disable settings 

$ kdbgctrl -e 
enable settings 

- autoamtic kernel debugging, if full kernel debugging is not enabled then the autoamtic kernel debugging means only the target computer could init a kernel debug connection 
- user mode error handling, some user-mode events will cause the target computer to break into the kernel debugger 

- block kernel debugging, wait to enable kernel debugging until after the traget computer started 
- change the size of DbgPrint buffer 
$ kdbgctrl -sdb 0x100000 


### Debug Universal drivers, step by step lab, echo kernel-mode 

## conditional breakpoints 
- with either the j(execute if - else) command or the .if token, followed by the gc(go from conditional breakpoint) command. 

0:000> bp Address "j (Condition) 'OptionalCommands'; 'gc' "

0:000> bp Address ".if (Condition) {OptionalCommands} .else {gc}"

- base on string comparison 
break into the debugger only if a string variable matches a pattern, for example. suppose want to break at kernel32!CreateEventW only if the lpName argument points to a string that matches the pattern "global*"

bp kernel32!CreateEventW "$$<c:\\commands.txt"

the script file commands.txt contain the following statements 
.if (@r9 != 0) { as /mu ${/v:EventName} @r9 } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "Global*") == 0)  { gc } .else { .echo EventName }

The lpName argument passed to the CreateEventW function is the fourth argument, so it is stored in the r9 register (x64 processor)

If lpName is not NULL, use as and ${} to create an alias named EventName. Assign to EventName the null-terminated Unicode string beginning at the address pointed to by lpName. On the other hand, if lpName is NULL, use ad to delete any existing alias named EventName
Use $spat to compare the string represented by EventName to the pattern "Global*". If the string does not match the pattern, use gc to continue without breaking. If the string does match the pattern, break and display the string represented by EventName

$spat performs a case-insenstive match 

- conditional breakpoint base on register value 
The following command will break at the beginning of the myFunction function if the eax register is equal to 0xA3:

0:000> bp mydriver!myFunction "j @eax = 0xa3  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xa3  {} .else {gc}"
 
The following 

# Debugging Resouces 
- debugging tools for windows: new for window 10 
.settings, set debug settings set modify display load and save settings in the debugger, settings naemspace 
dx, display NatVis expression 

    + new command ofr NatVis 
    .nvlist 
    .nvload 
    .nvunload 
    .nvunloadall 
    
blueTooth extensions, Bthkd.dll 
Storage kernel debugger extensions 
    + new symproxy information inculding symProxy automated Installation 
    http symbol stores 
    symproxy 
    installing symproxy 
    configuring the registry 
    configuring iss for symproxy 
cdb commandline options 
!analyze, update to include information about using this extension with UMDF 2.15 
!wdfkd.wdfcrashdump, update to include information about using this extension with UMDF 2.15 
!irp, updated, starting with window 10 irp major and mino code text 
using debugger markup language 
crash dump analysis using windbg 
debug universal drivers 

## Tools included in debugging tools for windows 
- adplus, automatically create memory dump files and log files 
- dumpchk, validate a memory dump file 
- gflags, control registry keys and other settings 
- kill, terminate a process 
- logger and logviewer, record and display function calls and other actions of a program 
- PLMDebug, use the windows debugger to debug window store apps, support manual control suspending, resuming, and terminating a window store app 
- remote tool, any console program including, kd, cbd, and ntsd, check detail from remote debugging through remote.exe 
- tlist, list all running process 
- umdh, analyze heap allocations 
- usbview, display usb host controllers and connected devices 
- DbgRpc, display microsoft remote procedure call state information 
- KDbgCtrl, control and configure the kernel debugging connection 
- SrcSrv, a source server that can be used to deliver source files while debugging 
- SymProxy, create a single http symbol server on your network that all your debuggers can point to, Symproxy.dll is in the SymProxy folder in the installation directory 

64 bit OS installs for the debugging tools is C:\Program Files (x86)\Windows Kits\10\Debuggers\
32 bit  C:\Program Files. To determine if you should use the 32 bit or 64 bit tools

- symchk, compare executable files to symbol files to verify that the correct symbols are available 
- symstore, create a symbol store 
- agestore, removes old entries in the downstream store of a symbol server or a source server 
- dbh, display information about the contents of a symbol file 
- pdbCopy, remove private symbol information and control which public symbols are included in the file 
- DbgSrv, a process server used for remote debugging 
- KdSrv, a kd connection server 
- DbEngPrx, a repeater(small proxy server) for remote debugging 
- Breakin, causes a user-mode break to occur in a process, for help, open a command prompt window 
- list
- RTLsit, remote task lsit viewer, Rtlist.exe 

### ADPlus
- v7.0 is a total rewrite of ADPlus in manage code, allows us to eaisly add new features, add some addtional features compare to ADPlus.vbs, a new component called ADPlusManager to distributed environment such as HPC computer cluster 



### DumpChk 
- performs a quick analysis of a crash dump file 
- command 
$ DumpChk [-y SymbolPath] DumpFile

## GFlags 
- GFlags, is the global flags editor, enables and disables advanced debugging, diagostic and troubleshooting features. used to turn on indicators that other tools track, count and log 

- overview of Glags 
    + page heap verification features can help you to identify memory leaks and buffer errors in kernel-mode drivers 
    + contain dialog box and command-line interface, but some features only accessbile from one interface 
    + features 
        * page heap verification includes the functions of pageheap.exe 
        * no reboot required for the special pool feature 
        * object referece tracing, for tracing of object referencing and dereferencing in the kernel, supported vista+
        * new dialog box design 
        
- requirements administrator right 

### GFlags Overview 
### GFlags Details 
### GFlags Commands 
### GFlags and PageHeap 
### Monitoring Silent Process Exit 

## Global Flags Dialog Box 
## Global Flag Reference 
## GFlags Reference 
## GFLags Example 
- displaying global flags 
- setting a flag by using a flag abbrevation 
- setting a falg by using its hexadecimal value 
- setting multiple flags 
- clearing a flag 
- clearing all flags for an image file 
- enlarging the user-mode stack trace database 
- detecting a pool memory leak 
- detecting a heap memory leak in process 
- enable page heap verification 
- usig page heap verfication to find a bug 
- listing image files with global flags 
- configuring special pool 
- using object reference tracing 

## Kill tool 
- kill tool, kill.exe terminates one or more process and all of their threads, works only on processes running on the local computer 

$ kill [/f] {PID|Pattern*}

## Logger 
- can be activated through two different vechicles. one way is to use the stand-alone logger.exe program. the other is to start cdb or windbg use the logexts.dll debugger extensions 
logger vechicle works as well, but using the debugger gives you the full power of the debugger along with the power of logger 
- using the debugger and logexts.dll 
one way to active logger is use debugger attach the target and use !logexts.logi or !logexts.loge extesion command. this is inject logger into the target application 

there actually be two instances of logexts.dll running since this module is both a debugger extension dll and the program that is injected into the target application. they communicated through a shared section of memory 

    + using the logger extension commands 
    !logexts.logi, inject logger into target, initialize but not enable 
    !logexts.loge, enables logging 
    !logexts.logd, disable logging, API hooks to be removed in an effort to allow the program to run freely. COM hooks are not removed because they cannot be re-enabled at will 
    !logexts.logo, displays or modifies output options. there are three types of options, message to debugger, text file, or an *.lgv file which could be view by logViewer 
    if you disable the text file output, a .txt file zero also will be output which may overwrite previous-saved text 
    COM hook are not removed because they could not be reenabled 
    !logexts.logb, display or flushes the current output buffer 
    !logexts.logm, display or creates a module inclusion/exclusion list 

- using logger.exe, run the stand-alone logger program to a single target 
$ logger target-path`

after that a logger window will appear for change settings 
API setting, displays the available API categories 
logging
inclusion/exclusion list 
flush the buffer 
go, start the application 

- restrictions and limitations, logger increase stack consumption for process. can expose bugs in application that usually related to uninitialized variables. the only workarund is to try siabling categories of functions in an attempt to isolate the area that is causing the problem 

### LogViewer
- utility can manipulate an .lgv file which is a compressed log file produced by the logger tool 
...

### Logging manifest
- logging manifest is the group of "header" files that define the functions and COM interfaces that are intercepted and logged. 
designation of OUT parameter 
definition of flag masks 
definition of failure cases 
designation of parameters that can be aliased for log differencing 

- manifest file placement 
- manifest file format 

### PLMDebug 
- a tool that enables you to use the windows debugger to debug windows store app 
...

### Remote Tool 
- remote.exe is a command-line tool that lets you run and control any console program from a remote computer 
- components 
    + a server application that starts a console program and opens a named pipe for client connections 
    + a client application taht establishes a connection to a server 
    + a query feature that lists the remote sessions 
- with remote tool you could start multiple server sessions on a single computer where multiple clients can connect to each sessions 

- remote server syntax 
$ remote /s Command SessionName [/f Color] [/b] [/u User [/u User...]] [/ud User [/ud User...]] [/v | /-v]

- remote client syntax 
$  remote /c Server SessionName [/L Lines] [/f] [/b] [/k ColorFile] 

- remote server query command 
$ remote /q Computer

- remote session commands to communicate with the remote tool during the console session 
@H, displays the session commands on server and client computer 
@M message, displays the specified message on all server and client computer 
@P message, generates a popup window on the server computer 
@Q, quite 
@K, discnonects all clients and ends the remote session 

- remote tool example
...

### TList 
- tlist, task list viewer
all process running on the computer along with their process id 
a tree showing which processes created each process 
details of the process including its virtual memory use and the command that started the process 
threads running in each process, including their ids, entry points last reported error and thread state 
the modules running in each process, including the version number atributes and virtual address of the module 

- command 
$ tlist [/p ProcessName | PID | Pattern | /t | /c | /e | /k | /m [Module] | /s | /v

- example 
...


### UMDH
- user mode dump heap tool, umdh.exe, analyzes the microsoft widnows heap memory allocations for a given process. have following modes 
    + analyze a running process, mode 1, umdh.exe will capture all heaps 
    
    + analyze umdh log files, mode 2, the log file is previous created by umdh.exe 

- commands 
...

### USBView, universal serial bus viewer, usbview.exe, is a window graphical user interface application that enables you to browse all USB controlelrs and connected USB devices on your computer 

## Tools related to debugging tools for windows 
- application verifier 
- window error reporting 
...

## Source code

## security considerations 

## processor architecture 
- x86 architecture 
...
- x86 instructions 
...

- annotated x86 disassembly 
...

- the x64 processor 
- x64 architecture 
- x64 instructions 
- annotated x64 disassembly 

## Debugger engine and extension APIs 
- introduction 

### Debugger engine overview 

### Using the debugger engine API 

### writing DbgEng Extensions 

### Writing WdbgExts Extensions 

### Writing Custom Analysis Debugger Extensions 

### Glossary 

# Debugger Operation
## Debugging using VIsual Studio 

## Debugging Using Windbg 
### Debugging a User mode process using WinDbg 
- attach to a running process 
    + from menu 
    + from command 
$windbg -p ProcessID 
$windbg -pn ProcessName 

    + debugger command window 
if windbg already attach to a process you could use command .attach attach a running process in the command window 

debugger always starts multiple target processes simultaneously, unless some of their threads are frozen or suspended 

- attaching to a running process noninvasively 

    + menu, File|Attach to Process select Noninvasive 
    + commandline 
    $ windbg -pv -p <process-id>
    $ windbg -pv -pn <process-name>
    
    + debugger command window 
    .attach -v  
    if debugger is already active. the debugger can not noninvasive debug more than one process at a time 
    
- spawning a new process, the process that debugger create is behave slight different. It use the heap which is created by debugger. Force the process use the standard heap by NO_DEBUG_HEAP environment variable or the -hd command-line option
    
because the process is a child process which inherit the debugger permission may also influence the action 

    + menu 
    + command line 
    $ windbg [-o] ProgramName [Arguments]
    
    $ windbg .create 
    
    control the process start directory by .createdir (set created proces directory) before call the .create command. You can use the .createdir -I command or the -noinh command-line option to control whether the target application inherits the debugger's handles
    
    active or deactive child debugging by .childdbg 

### Open a dump file using windbg 
- menu 
- commandline 
$ windbg -y SymbolPath -i ImagePath -z DumpFileName
- already open then use 
.opendump ( open dump file ) follow by g (go)

### live kernel-mode debugging using windbg 

### Ending a debug session in windbg 
- menu File|Exit 
unless use user-mode debugging with -pd option or kernel mode. if in kernel debugging mode then the target computer may in frozen state or running, if frozen then could reconnect to resume the debugging state 

- ending a user-mode session without existing 

    + .kill command 
    + q command unless you start debugger with -pd option 
    + choose stop debugging from debug menu 
    + shift+f5 
    + toolbar stop debugging button 
    
- end a user-mode debugging session to dormat mode and set the target running again 
    + enter .detach command 
    + choose Debug|Detach Debugee 
    + qd command 
    + q command if you started the debugger with the -pd option 
    
- end a user-mode debugging return the debugger to dromant mode but leave the target in debugging state with .abandoned command 

- ending a kernel-mode session without exiting. end a kernel mode debugging session. leave the target computer frozen 
    + q command 
    + menu 
    + shift+f5 
    + toolbar 
    
### Setting Symbol and executable image paths in windbg 
- use the symbol server by srv* or symsrv* string 
- control the symbol path in windbg 
    + set from menu in windbg
File|Symbol File Path 

    + use command .sympath, use using a symbol server. .symfix is similar to .sympath but saves typing 
    
    + start debugger with -y to specify the symbol path 
    
    + use  _NT_SYMBOL_PATH and _NT_ALT_SYMBOL_PATH environment variables to set the path

- executable image path, executable is a binary file that the processor can run. typically have the .exe, .dll or .sys extension 

before os run an executable it loads it into memory. the copied file in memory is called image in window 

- most of the time debugger knows the executable file location, but small memory dump files in kernel-mode don't contain the info 

user-mode minidump do not contain the application binaries 
The debugger's executable image path is a string that consists of multiple directory paths, separated by semicolons. 

- control the executable image path in windbg 
    + File|Image File Path 
    + use command .exepath 
    + use commandline option -i 
    + use environment variable _NT_EXECUTABLE_IMAGE_PATH 
    
### Remote debugging in windbg 

### Entering debugger commands in windbg 
- 


## Debugging Using KD and NTKD 
## Debugging Using CDB and NTSD 

## Local Kernel-mode Debugging 
## Conrolling the target 
## Enabling Postmortem debugging 

## Using the debugger command window 
## Using the WinDbg Graphical Interface 
### Using debugging information windows 
- windbg has ten kinds of debugging information windows, you can have only one instance of the following windows open at the same time 
    + debugger command window 
    + watch window 
    + locals window 
    + register window 
    + calls window 
    + disassembly window 
    + processes and threads window 
    + scratch pad 
    + can display multiple source window and memory window at the same time 
    
### Opening a window 
- use accelerate key alt+1~9 to open the relative window 
command alt+1
watch alt+2 
locals alt+3
registers alt+4 
memory alt+5 
calls alt+6 
disassembly alt+7 
scratch pad alt+8 
processes and threads alt+9 
source window ctrl+O

- configuring a window, each debugging information window has a shortcut menu that you can access by right-click the title bar of the window or by clicking the icon near the upper-right corner of the title bar 
such as quick access to the relative help page 

- moving through a window 
some window support the find, go to address or go to line command they only change the windbg display but not affect the execution of the target 

    + find command
    ctrl+f, enter the text you want to find 
    
    + go to address 
    ctrl + g 
    when the view code offset dialog box appears enter the address that you want to search. debugger moves the cursor to the begging of the function or address in the disassembly window or a source window 
    
    + moving a specific line, go to line command search for a line in the active source widnow, if the active window is not a source window you cannot use the go to line command. to active this option click go to line on the edit menu or press ctrl+L 

- changing text properties, setting the font, font style and font size. all debugging information windows hare the same font. click Font on the View menu 

change tab width by Options|View in the tab width enter the number of spaces 

- positioning the windows 
...

- using workspaces 

    
    
# Debugger Reference 
...
##windbg commandline options 
windbg [ -server ServerTransport | -remote ClientTransport ] [-lsrcpath ]
   [ -premote SmartClientTransport ] [-?] [-ee {masm|c++}] 
   [-clines lines] [-b] [-d] [-a Extension] [-e Event] 
   [-failinc] [-g] [-G] [-hd] [-j] [-n] [-noshell] [-o] 
   [-Q | -QY] [-QS | -QSY] [-robp] [-secure] [-ses] [-sdce] 
   [-sicv] [-sins] [-snc] [-snul] [-sup] [-sflags 0xNumber] 
   [-T Title] [-v] [-log{o|a} LogFile] [-noinh] 
   [-i ImagePath] [-y SymbolPath] [-srcpath SourcePath] 
   [-k [ConnectType] | -kl | -kx ExdiOptions] [-c "command"] 
   [-pb] [-pd] [-pe] [-pr] [-pt Seconds] [-pv]
   [-W Workspace] [-WF Filename] [-WX] [-zp PageFile] 
   [ -p PID | -pn Name | -psn ServiceName | -z DumpFile | executable ] 

windbg -I[S] 

windbg -IU KeyString

windbg -IA[S] 

All command-line options are case-sensitive except for -j. The initial hyphen can be replaced with a forward-slash (/).

If the -remote or -server option is used, it must appear before any other options on the command line. If an executable is specified, it must appear last on the command line; any text after is passed to the executable program as its own command-line parameters.

[-b] is abandoned
[-c " command "] specifies the initial debugger command to run at start-up, commands can be separated with semicolons
[-clines lines] set the approximate number of commands in the command history which can be accessed during remote debugging 
[-d], after a reboot the debugger will break into the target computer as soon as a kernel module is loaded 
[-e] signals the debugger that the specified event has occurred 
[-ee {masm|c++}] sets the default expression evaluator, masm is the default 
[-failinc] cause the debugger to ignore any questionable symbols 
[-g] user mode only ignores the initial breakpoint in target application which will cause the target application to contitnue running after it is started or windbg attach to it 
[-G] user mode only ignores the final break point. the same effect is command sxd epr 
[-hd] window xp+ user mode specifies that the debug heap should not be used 
[-I[S]] installs windbg as the postmortem debugger 
[-IA[S]] associates windbg with the file .dmp, .mdmp and .wew in the registry 
[-IU KeyString] registers debugger remoting as an URL type so that users can ato-launch a debugger remote client with a URL KeyString format remdbgeng://RemotingOption
[-i image-path] specifies the location of the executables that generated the fault 
[-j] allow journaling 
[-k connect-type] starts a kernel debugging session 
[-kl] window xp+ starts a kernel debugging session on the same machine as the debgger 
[-kx ExdiOptions] start a kernel debug uses a EXDI driver 
[-log{o|a} LogFile] begins logging info into a log file 
[-lsrcpath] sets the local source path for a remote client 
[-n] noisy symbol load 
[-noinh]user mode only prevents processes created by the debugger from inheriting handles from the debugger 
[-noprio] prevents any priority changes from windbg 
[-o] debugs all processes launches by the target application
[-p pid]
[-pb] (Windows XP and later, user mode only) Prevents the debugger from requesting an initial break-in when attaching to a target process. This can be useful if the application is already suspended
[-pd ]
(Windows XP and later, user mode only) Causes the target application not to be terminated at the end of the debugging session. See Ending a Debugging Session in WinDbg for details.

[-pe ]
(Windows XP and later, user mode only) Indicates that the target application is already being debugged. See Re-attaching to the Target Application for details.

[-pn Name ]
Specifies the name of the process to be debugged. (This name must be unique.) This is used to debug a process that is already running.

[-pr ]
(Windows XP and later, user mode only) Causes the debugger to start the target process running when it attaches to it. This can be useful if the application is already suspended and you wish it to resume execution.

[-psn ServiceName ]
Specifies the name of a service contained in the process to be debugged. This is used to debug a process that is already running.

[-pt Seconds ]
Specifies the break timeout, in seconds. The default is 30. See Controlling the Target for details. 

[-pv ]
(User mode only) Specifies that the debugger should attach to the target process noninvasively. For details, see Noninvasive Debugging (User Mode).

[-Q ]
Suppresses the "Save Workspace?" dialog box. Workspaces are not automatically saved. See Using Workspaces for details.

[-QS ]
Suppresses the "Reload Source?" dialog box. Source files are not automatically reloaded.

[-QSY ]
Suppresses the "Reload Source?" dialog box and automatically reloads source files.

[-QY ]
Suppresses the "Save Workspace?" dialog box and automatically saves workspaces. See Using Workspaces for details.

[-robp ]
This allows CDB to set a breakpoint on a read-only memory page. (The default is for such an operation to fail.) 

[-sdce ]
Causes the debugger to display File access error messages during symbol load. For details and for other methods of controlling this, see SYMOPT_FAIL_CRITICAL_ERRORS.

[-secure ]
Activates Secure Mode.

[-ses ]
Causes the debugger to perform a strict evaluation of all symbol files and ignore any questionable symbols. For details and for other methods of controlling this, see SYMOPT_EXACT_SYMBOLS.

[-sflags 0x Number] 
Sets all the symbol handler options at once. Number should be a hexadecimal number prefixed with 0x -- a decimal without the 0x is permitted, but the symbol options are binary flags and therefore hexadecimal is recommended. This option should be used with care, since it will override all the symbol handler defaults. For details, see Setting Symbol Options.

[-sicv ]
Causes the symbol handler to ignore the CV record. For details and for other methods of controlling this, see SYMOPT_IGNORE_CVREC.

[-sins ]
Causes the debugger to ignore the symbol path and executable image path environment variables. For details, see SYMOPT_IGNORE_NT_SYMPATH.

[-snc ]
Causes the debugger to turn off C++ translation. For details and for other methods of controlling this, see SYMOPT_NO_CPP.

[-snul ]
Disables automatic symbol loading for unqualified names. For details and for other methods of controlling this, see SYMOPT_NO_UNQUALIFIED_LOADS.

[-srcpath SourcePath ]
Specifies the source file search path. Separate multiple paths with a semicolon (;). If the path contains spaces, it should be enclosed in quotation marks. For details, and for other ways to change this path, see Source Path.

[-sup ]
Causes the symbol handler to search the public symbol table during every symbol search. For details and for other methods of controlling this, see SYMOPT_AUTO_PUBLICS. 

[-T Title ]
Sets WinDbg window title.

[-v ]
Enables verbose output from debugger.

[-W Workspace ]
Loads the given named workspace. If the workspace name contains spaces, enclose it in quotation marks. If no workspace of this name exists, you will be given the option of creating a new workspace with this name or abandoning the load attempt. For details, see Using Workspaces.

[-WF Filename ]
Loads the workspace from the given file. Filename should include the file and the extension (usually .wew). If the workspace name contains spaces, enclose it in quotation marks. If no workspace file with this name exists, you will be given the option of creating a new workspace file with this name or abandoning the load attempt. For details, see Using Workspaces.

[-WX ]
Disables automatic workspace loading. For details, see Using Workspaces.

[-y SymbolPath ]
Specifies the symbol search path. Separate multiple paths with a semicolon (;). If the path contains spaces, it should be enclosed in quotation marks. For details, and for other ways to change this path, see Symbol Path.

[-z DumpFile ]
Specifies the name of a crash dump file to debug. If the path and file name contain spaces, this must be surrounded by quotation marks. It is possible to open several dump files at once by including multiple -z options, each followed by a different DumpFile value. For details, see Analyzing a User-Mode Dump File with WinDbg or Analyzing a Kernel-Mode Dump File with WinDbg.

[-zp PageFile ]
Specifies the name of a modified page file. This is useful if you are debugging a dump file and want to use the .pagein (Page In Memory) command. You cannot use -zp with a standard Windows page file -- only specially-modified page files can be used. 

executable 
Specifies the command line of an executable process. This is used to launch a new process and debug it. This has to be the final item on the command line. All text after the executable name is passed to the executable as its argument string. For details, see Debugging a User-Mode Process Using WinDbg.

[-? ]
Pops up this HTML Help window.
    
    