Window Debugger Help Doc;Note=Erxin

# Introduction
- window sdk 10 debugger document note 

# Getting started with windows debugging, window debug main process 
- if your code is communicate with low leve hardware then suggest not use virtual machine as target 
- determine if you are will be doing kernel or user mode debugging 
    + kernel mode 
    gain full access to system resource 
    os functionality and system driver have this privileged 
    
    + user mode for normal application process 
    
some of the debug command may have different function 

- set up debug environment 
- connect the target and host system 
    + set up kernel mode dubbging manually, over 
    
    + setup debug environment in visual studio 
    
- choose 32-bit or 64-bit debugging tool 
- configure symbols 
- configure source code 
- familiar with debugger operations 
- become familiar with debugging techniques 
- use the debugger reference commands 
- use debugging extensions for specific technologies 


# getting start with windbg(user-mode)
- launch notepad adn attach windbg 
    + attach to process 
    + specify symbol path 
    > .sympath srv* 
    Symbol search path is: srv* 
    Expanded Symbol search path is: cache*;SRV*http://msdl.microsoft.com/download/symbols

for custom build application to set symbo by 
> .sympath srv*

> .sympath+ C:\MyApp\x64\Debug

> .srcpath C:\MyApp\MyApp

    + reload to initla windbg find and loading symbol files 
    > .reload 
    
    + see symbols for the notepad.exe module 
    > x notepad!*
    
    to see symbols contain main 
    > x notepad!*main 
    
    + put a break point at notepad!WinMain enter this 
    > bu notepad!WinMain 
    
    + verify your breakpoint was set by 
    > bl 
    
    + start notepad running by 
    > g 
    
    + check all the code modules that are loaded in the notepad process 
    > lm 
    
    + check stack trace 
    > k 
    
    + list all the threads 
    > ~ 
    
    + look at the stack trace for thread 0 
    > ~0s 
    
    + quit debugging 
    > qd 
    
    + when encounter a problem, let winDbg analyze the error information by 
    > !analyze -v
    
 
# getting started with windbg (kernel-mode)
- setup a kernel-model debugging 
host computer 
target computer 

debug cable type 
ethernet 
usb 2/3 
1394 
serial(null modem)

if window 8+ then all types of cable are supported, if not the ethernet is not avalable 

- establish a kernel-mode debugging session 
    + from network cable 
    + from usb 2.0
- get started using windbg 
    + on host open windbg, establish a kernel-model debugging sessions from File|Kernel Debug menu 
    + from the windbg window cmd line enter 
    > .sympath srv* 
    
    > .reload
    
    + see a list of loaded module 
    > lm 
    
    + start target computer running 
    > g 
    
    + break again 
    
    + examine the _FILE_OBJECT data type in the nt module 
    > dt nt!_FILE_OBJECT
    
    + enter the command to examine some of the symbols in the nt module 
    > x nt!*CreateProcess* 
    
    + enter this commadn to put a breakpoint at MmCreateProcessAddressSpace 
    > bu nt!MmCreateProcessAddressSpace
    
    verify the setted breakpoints 
    > bl 
    
    > g 
    
    if target computer doesn't break into the debugger immediately, perform a few actions(such as open nodepad)
    
    + after break input 
    > .reload 
    > k 
    to check the call stack 
    
    + on the view check disassmbly, choose step over or press F10 
    
    + clear your breakpoint by entering this command 
    > bc * 
    
    + list all processes 
    > !process 0 0 
    
    + copy the address of one process and enter this command 
    > !process Address 2 
    
    + copy the address of one thread enter 
    > !thread Address 
    
    + see all the device nodes in the plug and play device tree enter 
    > !devnode 0 1 
    
    + see device nodes along their hardware resources 
    > !devnode 0 9 
    
    + see device node that has a service name of disk 
    > !devnode 0 1 disk 
    
    + output of !devnode 0 1 displays the address of the physical device object(PDO) for the node. copy address of a physical object(PDO) and enter this 
    > !devstack PdoAddress 
    
    + get information about driver disk.sys 
    > !drvobj disk 2 
    
    + output of !drvobj displays addresses of dispatch routines for example CLASSNP!ClassGlobalDispatch, to set and verify breakpoint with 
    > bu CLASSPNP!ClassGlobalDispatch
    > bl 
    after hit break point 
    > .reload 
    > k 
    
    + end debug session 
    > qd 
    
- window debug command and syntax 
https://msdn.microsoft.com/en-us/library/windows/hardware/ff540507%28v=vs.85%29.aspx


# Choosing 32bit or 64bit debugger 
- when use visual studio, you don't have to consider this 
- when use windbg, kd, cdb, or ntsd you have to make choice yourself
- when x64 base host with running 64 bit version of windows 
    + analyzing a dump file, you can ue either 32 or 64 
    
    + live kernel-mode debug, you can use either 32-bit or 64 base on target 
    
    + debugging user mode on same computer, 64 for 64, 32 for 32 
    

# debugging environment 
- contains 
vs 
windbg 
kd, kernel debugger 
ntkd 
cdb, console debugger 
ntsd, nt symbolic debugger 

- VS with integrated window debugger 
    + supported 
Configure a set of target computers for debugging. 
Configure the debugging connections to a set of target computers. 
Launch a kernel-mode debugging session between the host computer and a target computer. 
Debug a user-mode process on the host computer. 
Debug a user-mode process on a target computer. 
Connect to remote debugging sessions. 
View assembly code and source code. 
View and manipulate local variables, parameters, and other symbols. 
View and manipulate memory. 
Navigate call stacks. 
Set breakpoints. 
Execute debugger commands. 

    + also support develop and debug drivers some of the WDK capabilities are integrated into VS 
Configure a set of target computers for driver testing. 
Create and sign a driver package. 
Deploy a driver package to a target computer. 
Install and load a driver on a target computer. 
Test a driver on a target computer. 

- windbg, support user and kernel mode, use VS debug symbol format. can access any public function's name that is exposed by modules that were compiled with COFF symbol files such as *.dbg files 

- kd, character-based console program, enables in depth analysis of kernel mode activity on all nt-based operating system. debug driver or monitor os. typically you need two computer 

- ntkd, variation of kd. variation of the kd debugger. identical to kd except spawns a new text window when it is started, where as kd inherits the command prompt widnow from which it was invoked 

- cdb, character-based console program enables low-level analysis of window user-mode memory and constructs. 

powerful for debugging a program current running or has recently crashed(live analysis)

it can be used to obtain stack trace or look at the guilty parameters 

with cdb you can display and execute program code, set bp and examine change values in memory. cbd can access memory location through addresses or global symbols you can refer to data and instructions by name rather than by address 

support multiple processes can read poth paged and non-paged memory. it target is console app then will share consle with cdb also support spwan a new window 

- ntsd, it is identical to cbd in every way, except spawns a new text wndow. fully capabile of debugging consle and window program. Controlling NTSD from the kernel debugger is therefore especially useful, since it results in an extremely light-weight debugger that places almost no burden on the computer containing the target application. This combination can be used to debug system processes, shutdown, and the later stages of boot up.

check the charpter about the user-mode debugger from the kernel debugger 


# Setting up Debugging(kernel -mode and user mode)
## setup kernel-mode in VS 
### Setup kernel-mode debugging over network cable in VS 
- to use VS do kernel-mode debugging you must have Windows Driver Kit integrated with VS 
check more info from window driver development http://go.microsoft.com/fwlink/p?linkid=301383

- configure host and target 
    + on host in VS, go to the computer configuration dialog select Provision compter and choose debugger settings 
    
    + connection type select network 
    
    + port choose from 49152 through 65535 
    
    + use the automatic generated key 
    
    + set the bus paramter if target computer contain more than one network cards. if target only contain one card than keep it empty 
    Bus Parameters, enter b.d.f where b, d, and f are the bus number, device number, and function number of the adapter
    
    + configuration process takes several minutes and might automatically reboot the target computer once or twice 
    
    + enable or disable kernel debugging by command Prompt window as Administrator and enter the command bcdedit /debug off. Reboot the target computer.
    $ bcdedit /debug off 
    
    + verify dbgsettings on target 
    
    $ bcdedit /dbgsettings 
    $ bcdedit /enum 
    
    if you don't see the value entered for Bus paramters, enter this command 
    $ bcdedit /set "{dbgsettings}" busparams b.d.f

    where b, d, and f are the bus, device, and function numbers of the network adapter on the target computer that you have chosen to use for debugging
    
    Reboot the target computer.
    
    + starting the debugging session 
    on host VS|Tools | Attah to Process 
    
    from transport choose Window Kernel Mode Debugger 
    
    Qualifier select name of the target computer that your previous configured 
    
    + click attach 
    
- creating your own key, Network debugging uses a 256-bit key that is specified as four 64-bit values, in base 36, separated by periods. Each 64-bit value is specified by using up to 13 characters

- troubleshooting tips for debugging over a network cable . windbg or kd must have access through the firewall 

- change port number 
on host VS | Driver menu |Configure Computers 
select target computer click next 
select Provision computer and choose debugger settings and next 
reset the port number and next 

### setting up kernel-mode debugging of a virtual machine in VS 
- virtual machine can be located on the same physical computer as the debugger or on a different computer 

required WDK 

- in the virtual machine enter command 
> bcdedit /debug on 
> bcdedit /dbgsettings serial debugport:n baudrate:115200 
  
n is the COM port on the virtual machine 
  
reboot 

- in the VM configure the COM port to map to a named pip. check your virtual machine document for this 

- configuring the host 

    + Driver menu Test|Configure computer 
    
    + add new computer give the physical computer name contain the VM 
    + select manually configure debuggers and do not provision and click next 
    + connect type click serial 
    + check pipe and check reconnect 
    + if the debugger is running on the same computer name as VM enter this pip name 
    \\.\pipe\pip-name 
    
    on different physical computer use 
    \\vm-host\pip\pip-name 
    
    + finish 
    
- starting debugging session 
    + on host VS|Tools|Attach to process 
    + transport choose window kernel mode debugger 
    + qualifier select name of the physical computer that is running the target virtual machine 
    + attach 
- generation 2 vritual machine 
    + COM ports are not presented in generation 2 virtual machines. you can add COM ports through powershell or wmi for COM ports to be displayed 
    
        * disable secure boot by entering this powershell comand 
        Set-VMFirmware-Vmname vm-name -EnableSecureBoot Off 
        
        * add a com port to the virtual machine by 
        Set-VMFirmware-Vmname vm-name 1 \\.\pipe\PipeName 
        
        * configures the first com port on virtual machine TestVM to connect to named pipe 
        Set-VMFirmware-Vmname TestVM 1 \\.\pipe\TestPipe
    
### setting up kernel-mode debugging over a newwork cable manually 
    
### supported eithernet NICs for network kernel debugging in window 8+


### setup user mode debugging in VS 
- there are two user-mode debuggers available in VS one is the windows user-mode debugger 
    + one contain in the debuggings tools for windows 
    + VS debugger which is part of VS 
    
- debugging user-mode process on the local computer, attach process or launching process under the debugger 

- debugging a user-mode process on a target computer 
debugger runs on the host computer the code that is being debugged runs on target computer 
    + in VS use the user-mode debugger to attach process 
    + on target computer set Control Panel>Network and Internet>Network and Sharing Center>Advanced sharing settings. Under Guest or Public, select Turn on network discovery and Turn on file and printer sharing.
    + do the rest of configuration on the host 
    + VS tools > attach to process 
    + for transport choose window user mode debugger 
    + qualifier click browse 
    + click add 
    + enter target computer 
    + click Configure Target Computer
    + Click ok 
    
- if target is a VM host, requires, set up network debugging before add hyper-v role. if set debugging after added hyper-v role, must change the network settings for your virtual machines to bridge them to the microsoft kernel network debug adapter. other wise the virtual machines will not have access to the network 
    + target computer has a single network interface card 
    + install the hyper-v role on the target computer 
    + create one or more vitual machines on the target computer 
    
### configure tools.ini
- contains information to initialize the command-line debuggers 
- windbg saves initialization settings in workspaces 
- tools.ini entries are shown in the following table 

$u0:value ... $u9:value, assig values to fixed-name aliases 
DebugChildren:flag TRUE or FALSE
LazyLoad 
SetDll:filename, set extension dll. 
StopFirst:flag
StopOnProcessExit:flag 
sxd:event, sets the debugger resposne and the handling status for the specified exception or event 
sxe:event
IniFile, specifies the name of the ini file 
- section headers 
[CDB], [NTSD], and [KD].
- example 
[NTSD]
sxe: 3c
sxe: cc
$u0: VeryLongName
VerboseOutput:true

### Using KDbgCtrl
- KDbgCtrl, kernel debugging control, kdbgctrl.exe can be used to control the kernel debugging connection from the target computer
- can control five different settings 
full kernel debugging 
automatic kernel debugging 
user-mode error handling 
blocking of kernel debugging 
the size of DbgPrint buffer 

- first must enable kernel debugging  
- full kernel debugging is enable by default 
$ kdbgctrl -c 
check current settings 

$ kdbgctrl -d 
disable settings 

$ kdbgctrl -e 
enable settings 

- autoamtic kernel debugging, if full kernel debugging is not enabled then the autoamtic kernel debugging means only the target computer could init a kernel debug connection 
- user mode error handling, some user-mode events will cause the target computer to break into the kernel debugger 

- block kernel debugging, wait to enable kernel debugging until after the traget computer started 
- change the size of DbgPrint buffer 
$ kdbgctrl -sdb 0x100000 


### Debug Universal drivers, step by step lab, echo kernel-mode 

## conditional breakpoints 
- with either the j(execute if - else) command or the .if token, followed by the gc(go from conditional breakpoint) command. 

0:000> bp Address "j (Condition) 'OptionalCommands'; 'gc' "

0:000> bp Address ".if (Condition) {OptionalCommands} .else {gc}"

- base on string comparison 
break into the debugger only if a string variable matches a pattern, for example. suppose want to break at kernel32!CreateEventW only if the lpName argument points to a string that matches the pattern "global*"

bp kernel32!CreateEventW "$$<c:\\commands.txt"

the script file commands.txt contain the following statements 
.if (@r9 != 0) { as /mu ${/v:EventName} @r9 } .else { ad /q ${/v:EventName} }
.if ($spat(@"${EventName}", "Global*") == 0)  { gc } .else { .echo EventName }

The lpName argument passed to the CreateEventW function is the fourth argument, so it is stored in the r9 register (x64 processor)

If lpName is not NULL, use as and ${} to create an alias named EventName. Assign to EventName the null-terminated Unicode string beginning at the address pointed to by lpName. On the other hand, if lpName is NULL, use ad to delete any existing alias named EventName
Use $spat to compare the string represented by EventName to the pattern "Global*". If the string does not match the pattern, use gc to continue without breaking. If the string does match the pattern, break and display the string represented by EventName

$spat performs a case-insenstive match 

- conditional breakpoint base on register value 
The following command will break at the beginning of the myFunction function if the eax register is equal to 0xA3:

0:000> bp mydriver!myFunction "j @eax = 0xa3  '';'gc'" 
0:000> bp mydriver!myFunction ".if @eax = 0xa3  {} .else {gc}"
 
The following 

# Debugging Resouces 
- debugging tools for windows: new for window 10 
.settings, set debug settings set modify display load and save settings in the debugger, settings naemspace 
dx, display NatVis expression 

    + new command ofr NatVis 
    .nvlist 
    .nvload 
    .nvunload 
    .nvunloadall 
    
blueTooth extensions, Bthkd.dll 
Storage kernel debugger extensions 
    + new symproxy information inculding symProxy automated Installation 
    http symbol stores 
    symproxy 
    installing symproxy 
    configuring the registry 
    configuring iss for symproxy 
cdb commandline options 
!analyze, update to include information about using this extension with UMDF 2.15 
!wdfkd.wdfcrashdump, update to include information about using this extension with UMDF 2.15 
!irp, updated, starting with window 10 irp major and mino code text 
using debugger markup language 
crash dump analysis using windbg 
debug universal drivers 

## Tools included in debugging tools for windows 
- adplus, automatically create memory dump files and log files 
- dumpchk, validate a memory dump file 
- gflags, control registry keys and other settings 
- kill, terminate a process 
- logger and logviewer, record and display function calls and other actions of a program 
- PLMDebug, use the windows debugger to debug window store apps, support manual control suspending, resuming, and terminating a window store app 
- remote tool, any console program including, kd, cbd, and ntsd, check detail from remote debugging through remote.exe 
- tlist, list all running process 
- umdh, analyze heap allocations 
- usbview, display usb host controllers and connected devices 
- DbgRpc, display microsoft remote procedure call state information 
- KDbgCtrl, control and configure the kernel debugging connection 
- SrcSrv, a source server that can be used to deliver source files while debugging 
- SymProxy, create a single http symbol server on your network that all your debuggers can point to, Symproxy.dll is in the SymProxy folder in the installation directory 

64 bit OS installs for the debugging tools is C:\Program Files (x86)\Windows Kits\10\Debuggers\
32 bit  C:\Program Files. To determine if you should use the 32 bit or 64 bit tools

- symchk, compare executable files to symbol files to verify that the correct symbols are available 
- symstore, create a symbol store 
- agestore, removes old entries in the downstream store of a symbol server or a source server 
- dbh, display information about the contents of a symbol file 
- pdbCopy, remove private symbol information and control which public symbols are included in the file 
- DbgSrv, a process server used for remote debugging 
- KdSrv, a kd connection server 
- DbEngPrx, a repeater(small proxy server) for remote debugging 
- Breakin, causes a user-mode break to occur in a process, for help, open a command prompt window 
- list
- RTLsit, remote task lsit viewer, Rtlist.exe 

### ADPlus
- v7.0 is a total rewrite of ADPlus in manage code, allows us to eaisly add new features, add some addtional features compare to ADPlus.vbs, a new component called ADPlusManager to distributed environment such as HPC computer cluster 



### DumpChk 
- performs a quick analysis of a crash dump file 
- command 
$ DumpChk [-y SymbolPath] DumpFile

## GFlags 
- GFlags, is the global flags editor, enables and disables advanced debugging, diagostic and troubleshooting features. used to turn on indicators that other tools track, count and log 

- overview of Glags 
    + page heap verification features can help you to identify memory leaks and buffer errors in kernel-mode drivers 
    + contain dialog box and command-line interface, but some features only accessbile from one interface 
    + features 
        * page heap verification includes the functions of pageheap.exe 
        * no reboot required for the special pool feature 
        * object referece tracing, for tracing of object referencing and dereferencing in the kernel, supported vista+
        * new dialog box design 
        
- requirements administrator right 

### GFlags Overview 
### GFlags Details 
### GFlags Commands 
### GFlags and PageHeap 
### Monitoring Silent Process Exit 

## Global Flags Dialog Box 
## Global Flag Reference 
## GFlags Reference 
## GFLags Example 
- displaying global flags 
- setting a flag by using a flag abbrevation 
- setting a falg by using its hexadecimal value 
- setting multiple flags 
- clearing a flag 
- clearing all flags for an image file 
- enlarging the user-mode stack trace database 
- detecting a pool memory leak 
- detecting a heap memory leak in process 
- enable page heap verification 
- usig page heap verfication to find a bug 
- listing image files with global flags 
- configuring special pool 
- using object reference tracing 

## Kill tool 
- kill tool, kill.exe terminates one or more process and all of their threads, works only on processes running on the local computer 

$ kill [/f] {PID|Pattern*}

## Logger 
- can be activated through two different vechicles. one way is to use the stand-alone logger.exe program. the other is to start cdb or windbg use the logexts.dll debugger extensions 
logger vechicle works as well, but using the debugger gives you the full power of the debugger along with the power of logger 
- using the debugger and logexts.dll 
one way to active logger is use debugger attach the target and use !logexts.logi or !logexts.loge extesion command. this is inject logger into the target application 

there actually be two instances of logexts.dll running since this module is both a debugger extension dll and the program that is injected into the target application. they communicated through a shared section of memory 

    + using the logger extension commands 
    !logexts.logi, inject logger into target, initialize but not enable 
    !logexts.loge, enables logging 
    !logexts.logd, disable logging, API hooks to be removed in an effort to allow the program to run freely. COM hooks are not removed because they cannot be re-enabled at will 
    !logexts.logo, displays or modifies output options. there are three types of options, message to debugger, text file, or an *.lgv file which could be view by logViewer 
    if you disable the text file output, a .txt file zero also will be output which may overwrite previous-saved text 
    COM hook are not removed because they could not be reenabled 
    !logexts.logb, display or flushes the current output buffer 
    !logexts.logm, display or creates a module inclusion/exclusion list 

- using logger.exe, run the stand-alone logger program to a single target 
$ logger target-path`

after that a logger window will appear for change settings 
API setting, displays the available API categories 
logging
inclusion/exclusion list 
flush the buffer 
go, start the application 

- restrictions and limitations, logger increase stack consumption for process. can expose bugs in application that usually related to uninitialized variables. the only workarund is to try siabling categories of functions in an attempt to isolate the area that is causing the problem 

### LogViewer
- utility can manipulate an .lgv file which is a compressed log file produced by the logger tool 
...

### Logging manifest
- logging manifest is the group of "header" files that define the functions and COM interfaces that are intercepted and logged. 
designation of OUT parameter 
definition of flag masks 
definition of failure cases 
designation of parameters that can be aliased for log differencing 

- manifest file placement 
- manifest file format 

### PLMDebug 
- a tool that enables you to use the windows debugger to debug windows store app 
...

### Remote Tool 
- remote.exe is a command-line tool that lets you run and control any console program from a remote computer 
- components 
    + a server application that starts a console program and opens a named pipe for client connections 
    + a client application taht establishes a connection to a server 
    + a query feature that lists the remote sessions 
- with remote tool you could start multiple server sessions on a single computer where multiple clients can connect to each sessions 

- remote server syntax 
$ remote /s Command SessionName [/f Color] [/b] [/u User [/u User...]] [/ud User [/ud User...]] [/v | /-v]

- remote client syntax 
$  remote /c Server SessionName [/L Lines] [/f] [/b] [/k ColorFile] 

- remote server query command 
$ remote /q Computer

- remote session commands to communicate with the remote tool during the console session 
@H, displays the session commands on server and client computer 
@M message, displays the specified message on all server and client computer 
@P message, generates a popup window on the server computer 
@Q, quite 
@K, discnonects all clients and ends the remote session 

- remote tool example
...

### TList 
- tlist, task list viewer
all process running on the computer along with their process id 
a tree showing which processes created each process 
details of the process including its virtual memory use and the command that started the process 
threads running in each process, including their ids, entry points last reported error and thread state 
the modules running in each process, including the version number atributes and virtual address of the module 

- command 
$ tlist [/p ProcessName | PID | Pattern | /t | /c | /e | /k | /m [Module] | /s | /v

- example 
...


### UMDH
- user mode dump heap tool, umdh.exe, analyzes the microsoft widnows heap memory allocations for a given process. have following modes 
    + analyze a running process, mode 1, umdh.exe will capture all heaps 
    
    + analyze umdh log files, mode 2, the log file is previous created by umdh.exe 

- commands 
...

### USBView, universal serial bus viewer, usbview.exe, is a window graphical user interface application that enables you to browse all USB controlelrs and connected USB devices on your computer 

## Tools related to debugging tools for windows 
- application verifier 
- window error reporting 
...

## Source code

## security considerations 

## processor architecture 
- x86 architecture 
...
- x86 instructions 
...

- annotated x86 disassembly 
...

- the x64 processor 
- x64 architecture 
- x64 instructions 
- annotated x64 disassembly 

## Debugger engine and extension APIs 
- introduction 

### Debugger engine overview 

### Using the debugger engine API 

### writing DbgEng Extensions 

### Writing WdbgExts Extensions 

### Writing Custom Analysis Debugger Extensions 

### Glossary 

# Debugger Operation
## Debugging using VIsual Studio 

## Debugging Using Windbg 
### Debugging a User mode process using WinDbg 
- attach to a running process 
    + from menu 
    + from command 
$windbg -p ProcessID 
$windbg -pn ProcessName 

    + debugger command window 
if windbg already attach to a process you could use command .attach attach a running process in the command window 

debugger always starts multiple target processes simultaneously, unless some of their threads are frozen or suspended 

- attaching to a running process noninvasively 

    + menu, File|Attach to Process select Noninvasive 
    + commandline 
    $ windbg -pv -p <process-id>
    $ windbg -pv -pn <process-name>
    
    + debugger command window 
    .attach -v  
    if debugger is already active. the debugger can not noninvasive debug more than one process at a time 
    
- spawning a new process, the process that debugger create is behave slight different. It use the heap which is created by debugger. Force the process use the standard heap by NO_DEBUG_HEAP environment variable or the -hd command-line option
    
because the process is a child process which inherit the debugger permission may also influence the action 

    + menu 
    + command line 
    $ windbg [-o] ProgramName [Arguments]
    
    $ windbg .create 
    
    control the process start directory by .createdir (set created proces directory) before call the .create command. You can use the .createdir -I command or the -noinh command-line option to control whether the target application inherits the debugger's handles
    
    active or deactive child debugging by .childdbg 

### Open a dump file using windbg 
- menu 
- commandline 
$ windbg -y SymbolPath -i ImagePath -z DumpFileName
- already open then use 
.opendump ( open dump file ) follow by g (go)

### live kernel-mode debugging using windbg 

### Ending a debug session in windbg 
- menu File|Exit 
unless use user-mode debugging with -pd option or kernel mode. if in kernel debugging mode then the target computer may in frozen state or running, if frozen then could reconnect to resume the debugging state 

- ending a user-mode session without existing 

    + .kill command 
    + q command unless you start debugger with -pd option 
    + choose stop debugging from debug menu 
    + shift+f5 
    + toolbar stop debugging button 
    
- end a user-mode debugging session to dormat mode and set the target running again 
    + enter .detach command 
    + choose Debug|Detach Debugee 
    + qd command 
    + q command if you started the debugger with the -pd option 
    
- end a user-mode debugging return the debugger to dromant mode but leave the target in debugging state with .abandoned command 

- ending a kernel-mode session without exiting. end a kernel mode debugging session. leave the target computer frozen 
    + q command 
    + menu 
    + shift+f5 
    + toolbar 
    
### Setting Symbol and executable image paths in windbg 
- use the symbol server by srv* or symsrv* string 
- control the symbol path in windbg 
    + set from menu in windbg
File|Symbol File Path 

    + use command .sympath, use using a symbol server. .symfix is similar to .sympath but saves typing 
    
    + start debugger with -y to specify the symbol path 
    
    + use  _NT_SYMBOL_PATH and _NT_ALT_SYMBOL_PATH environment variables to set the path

- executable image path, executable is a binary file that the processor can run. typically have the .exe, .dll or .sys extension 

before os run an executable it loads it into memory. the copied file in memory is called image in window 

- most of the time debugger knows the executable file location, but small memory dump files in kernel-mode don't contain the info 

user-mode minidump do not contain the application binaries 
The debugger's executable image path is a string that consists of multiple directory paths, separated by semicolons. 

- control the executable image path in windbg 
    + File|Image File Path 
    + use command .exepath 
    + use commandline option -i 
    + use environment variable _NT_EXECUTABLE_IMAGE_PATH 
    
### Remote debugging in windbg 

### Entering debugger commands in windbg 
- use alt+1 to open the command window 

### Using the command browser window in windbg
- it is used to displays and stores the text results of a debugger command 
- support multiple instance 
- open command browser window 
- switch between different command window by alt+shift+N 
- commands enter in the command browser window are executed by the debugger engine, not by the windbg user interface. this means you can't enter user interface command like .cls 


### Setting breakpoints in windbg 
- menu Edit|Breakpoints 
- alt+F9 will display a list box contain all the break points 
- code window, the disassembly window and the source windows highlight lines that have breakpoints set. enabled breakpoints are read and disabled breakpoints are yellow 
press f9 to set breakpoint 


### Viewing the call stack in windbg 
- call stack is the chain of function calls that have led to the current location of the program counter. it is display based on the current program counter unless you change the register context 

- debugger command window 
    + command k in command window 
    + calls call stack window 
    View|Call Stack 
    
    double click a line to change the context 
    
    + near the upper right corner contain the buttons and commands 
    raw args, displays the first three parameters that are passed to the function  
    func info 
    source 
    addres 
    nonvolatile regs, displays the nonvolatile portion of the register context 
    frame nums 
    arg types 
    always floating 
    move with frame 
    
### Assembly Code Debugging in WinDbg 
- view the assembly code by enter the command u, ub, uu(Unassemble) commands in the debugger command window 

- disassembly window 
View|Disassemlby 

alt+shift+7 

    + support operation 
    disassemble different section of memory in the offset box type the memory you want to disassemble 
    
    + to see other sections of memory, click the next previous buttons or press the page up or page down keys will go to the preceding or following sections of memory. use arrow key to navigate in the current window items 
    
    + title toolbar button support 
    go to current address 
    disassemble before current instructions
    show source line for each instructions
    show source file for each instructions
    
### Source code debugging in windbg 
- control the source path in windbg 
    + menu , File|Source File Path 
    ctrl + p
    
    + command .srcpath or .srcfix 
    + use .lsrcpath (set local source path) for using a source server or .lsrcfix 
    
    + commandline -lsrcpath or -srcpath 
    + use environment variable _NT_SOURCE_PATH 
    
- opening and closing source files 
    + menu 
    + command .open 
    + lsf command (load or unload source files)
    
- windbg invoke source editor with these parameters 
$ c:\my\path\myeditor.exe -file %f -line %l
 
- source window colors and hover evaluation 
    + open source window's shortcut menu select source languge to <none> for turn off syntax collor 
    
    + the hover evaluation is equal to the command dt(display type command)


### Viewing and Editing Memory in Windbg 
- debugger command window 
    + menu View|Memory, alt+5 
    
- using a memory window, displays data in several columns, the first column display the beginning address of each line 

change the display format from the tool bar to control the format 

ascii characters will be display in the right 

by default memory window displays virtual memory. this is only avaliable in user mode. in kernel model could use memory options to display physical memory and other data spaces 

- in memory window you can do 
    + write to memory 
    + to see other sections of memory 
    + navigate within the window use the arrow keys 
    + change memory location to view use the address box 
    + change data type by display format 
    
- in the title bar click the icon to display more commands 
display format 
previous, next 
auto-fit columns 
dock 
move to new dock 
...

properties to open Memory Options 

- memory options dialog if in kernel mode there will be six memory types available such as 
virtual memory 
physical memory 
bus data 
control data 
i/o (i/o port information)
MSR(mode-specific register information)

### Viewing and editing global variables in windbg 
- debugger interprets the name of a global variable as a virtual address. you can use all the the commands iin accessing memory by virtual address to display global variables

d* command display contents of a specified memory address or range 
e* writes a value to the specified memory address 

dt find a variety of data types 
ds display string 
dl display linked list 
d*s display words and symbols 
!address extension command display information about the property of the memory 

m moves the content of one memory range to another 
f write a pattern to a memory range 
c compare contents of two memory ranges 
s search memory 
.holdmem hold and compare one memory range to another  

most of the command interpret the parameter in current radix, use 0x befre hex 
use n command to set number base 
use evalue expression ? to quickly convert numbers from one base to another or use the .formats command show number formats 

you can use any command to display the address that is associate with any symbol 

- use watch window to display and change variables alt+2 

### Viewing and editing local variables in windbg 
- use command 
dv 
dt 

- open locals window alt+3, contain four columns 
name
value, support change value  
type, also support enter a extension command in the type column. the debugger will pass the address of the symbol to this extension will display the resulting beneath the current row. if the symbol is a thread environment block you can enter !teb in the type to run the !teb extension
location, show the offset 
if a local variable is an instance of a class that contains vtables the name column display the vtables and you can expand the vtables to show the function pointers. if have a base class, _vtcast_Class is displayed to indicate the members that are being added because of the derived class 
local context determines which set of local variables will be displayed in the locals window, locals window is automatically updated 

- command in the toolbar menus 
typecast 
type 
locations 
display 16-bit values as unicode 
always display numbers in default radix 
...

### Viewing and editing registers in windbg 
- x86, x64 process have different collections of registers 

- commands 
    + r command in command window to view registers 
    
    + customize the display with command rm 
    
    + stepping through your code with p(step) or t(trace) commands you see a register display at every step 
    
    + r option also controls several one-bit register known as flags 
    
- register window 
    + menu View|Registers alt + 4 

- register window support 
value 
in user mode, registers window displays the registers that are associated with the current thread 
in kernel mode, registers window displays the registers that are associated with the current register context. only the most important registers for the specified register context are actually displayed 

- customize register list dialog box. you can't actually delete a register from the list, if do it will appear at the end 

watch window also support display registers 

### Controlling Processes and Threads in Windbg 
- display the system process and thread info also support select a new system, process, and thread to active 

- open the process and threads window alt+9, alt+shift+9 to close 
click a line in the window to active another thread or process 

### Configuration Exceptions adn Events and Windbg 
- configure windbg react to specified exceptions and events in a specific way 

for each exxception you can set the break status and handling status for each event 

    + Debug|Event Filters click event that you want from the list in the Event Filters, select enabled, disabled, output or ignore 
    
    + Use the SXE, SXD, or SXI command 
    
- configure the handling status by 
    + Debug|Event Filters and then select handled or not handled 
    + use the SXE, SXD, SXN or SXI command 

    
### Keeping a log file in windbg 
- can write a log file that records the debugging session this log file contains all of the contents of the debugger command window 

- opening a new log file in several ways
    + Edit|Open/Close Log file from Edit menu 
    
    + use -logo command line 
    
    + use command .logopen (open log file) command. if use the /t option the date and time are appended. /u then the file will writen in unicode 
    
- appending to an existing file 
    + choose Open/Close log file from the edit menu 
    + when you start windbg in a command prompt window use -loga command line option 
    + command .logappend (append log file) command 
    
- close a log 
    + menu 
    + .logclose 
    
- checking log status 
    + menu Edit|Open/Close log file 
    + .logfile will display command 

### Using the watch window 
- open watch window alt+2, for display global, local, registers 
reference previous notes ### Viewing and editing global variables in windbg 

### Using the scratch pad 
- it is a clipboard on which you can type and save text 
- open View|Scratch Pad, alt+8 
- support operations 
type in to edit 
close the window the text will remain when reopen  
    

## Debugging Using KD and NTKD 
## Debugging Using CDB and NTSD 

## Local Kernel-mode Debugging 

## Conrolling the target 
- when the debugger connects to a kernel mode target the debugger leaves the target running unles yu use the -b command line 

when debugger connect to a user-mode target it immedaitely stops the taget unless you use the -g commmand line 

- when the target is runnning 
    + issue a break command, if the application executing system code or are in wait operation it will breaks only after controls has returned to the application's code 
    
    + if certain events occur if a breakpoint is hit the application closes normally 
    
- when target is stopped 
    + continue run, by go command 
    + step through by debug command window 
    + if an excpetion occurs you can use Go With Exception Handled adn Go With Excption Not Handed commands to resume execution and control the status of exception 

    + select a source code in line support run to cursor 
    + user mode support restart command, it is only avaliable for the process which is created by debugger 
    
    + windbg only, close target application and clear the debugger, use Stop Debugging 
    
- command forms these commands also support in CDB, KD, WinDbg, in windbg the commands are in debug menu 

command         windbg command      windbg shortcut         effect 
                run to cursor       f7, ctrl+f10
                stop debugging      shift+f5            
ctrl+c          break               ctrl+break 
.restart        restart             ctrl+shift+f5 
g               go                  
gc(go with conditional breakpoint)                             
gh(go with exception handled) 
gn(go with excpetion not handled)
gu(go up)       step out            shift+f11 
p(step)         step over 
pa(step to address) 
pc(step to next call)
pct(step to next branching instruction)
pt(step to next return)
t(trace)        step into 
tb(trace to next branch)
tc(trace to next call)
tct(trace to next call or return)
th(trace to next branching instruction)
tt(trace to next return)
wt(trace and watch data)

- with command line option -g to attach user mode without stop 
- CDB and windbg also support -G which cause the debugging session end if the application completes properly 
$ cdb -g -G ApplicationName 

use -pt to set break timeout, if a break command is issued and the debugger cannot break into the target after this time the debugger display a "break-in time out" message 

default value is 30 seconds 

## Enabling Postmortem debugging 
- most application errors are called exceptions, included access violation, division-by-zero, numerical overflows. breakpoints can be inserted in to the code by a debugger, or invoked through a function such as DbgBreakPoint 

- precedence used for error handling 
    + if a user-mode debugger is attached to the faulting process, all errors will cause the target to break into this debugger. no other-handling methods will be used even if the gn(go with exception not handled) is used 
    + no user-mode debugger attached then application need handle these by it self 
    + if no user-mode debugger but a kernel model debugger is connected window will try to use it 
    if window 2003+ support prevent a user-mode interrupt from breaking into the kernel debugger, you can use the KDbgCtrl utility with -du parameter 
    
    in the kernel debugger could use the gh(go with exception handled) to disregard the error and continue the target ou can use gn(go with exception not handled) to bypass the kernel debugger and window will try t use a just-in-time debugger which referred as the postmortem debugger 
    
    + if there is no postmortem debugger than window error report will display a message box. if appropriate values are set in the registry WER will also write a dump file 
    
- specifying a postmortem debugger 
    + set the postmortem debugger to windbg run
    $ windbg -I 
    I must capitalized, then it will be active whenever an application crash 
    
    + set to cdb 
    $ cdb -ieac 
    
    + set to ntsd 
    $ ntsd -iae 
    
    when the debuggers are called the command line arguments should be 
    $ debugger -p %ld -e %ld -g [keyString]
    The -p %ld parameter specifies the process ID that will be debugged, the -e %ld parameter provides the event that caused the exception, and the -g parameter causes the debugger to skip the initial breakpoint. If the -iaec switch is used when installing CDB or NTSD as the postmortem debugger, the additional arguments specified as KeyString will then follow. 

- editing the registry key to set the postmortem debugger 
HKLM\Software\Microsoft\Windows NT\CurrentVersion\AeDebug

On a 64-bit platform, the postmortem settings for 32-bit processes are stored under this registry key:

HKLM\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug

relative registry entries 
Debugger, to the fullpath of the debugger 
Auto, set to 0 or 1, if equal to 0 a message box will be displayed first 


## Using the debugger command window 
### Using debugger commands 
- kd or cdb the debugger command window is set to the whole window 
- visual studio refer to the window which is labeled "Debugger Immediate Window" which have two panel 
    + in the small, bottom pane yu enter commands
    + large upper will view the command output 
    
- command prompt 
    + user mode 
2:005> 

the 2 is refer to the current process number and 005 is the current thread number 

    + kernel mode 
kd> 

if the target process have multiple processors then the curnt processor appears before the prompt 
0: kd> 

    + if debugger is busy there will be a message 
*BUSY*

    + use command .pcmd to add text to this prompt (set prompt command)
    
- kinds of commands 
    + some commands are available only in the live debugging and other available only in a dump debug 
    
    + user mode and kernel mode 
    
    + target is running on certain processors 
    
- editing repeating and canceling commands 

    + find previous command use arrow keys 
    
    + press ESC to clear current line 
    
    + tab to automatic complete typing 
        * start with "." dot them match to a dot command 
        * start with "!" matched to an extension command 
        * otherwise the text is matched with a symbol 
    
    + use wildcard characters in the text and press TAB to expand to the full set of text completion options 
    $ fo*!ba 
    will expend to all module start with "fo" and all symbols included all symbols that start with "bar"

    complete all extension command that have prcb in them by 
    !*prcb and then pressing TAB 
    
    + maximum command length is 4096 if controlling the user-mode debugger from kernel mode debugger the maximum length is 512 
    
    + press ENTER to repeat the previous commad by default in CDB and KD 
    
    + ctrl+c to cut of a long display in cdb or kd, in windbg use Debug|Break or Ctrl+break 
    
    + clear screen by .cls clear screen in cdb or kd, in windbg use Edit|Clear command output 
    
- expression syntax, many commands and extensions accept expressions as their argument, debugger evaluates these before executing the command 

- aliases for avoid retype complex phrases 

- self-repeating commands, to repeat an action or conditionally execute other commands 

j (execute if-else) conditional command 
z (execute while) conditional command 
~e (thread-sepcific command) command qualifier 
!list extension command 

- control scrolling, press any key or command output will auto scroll down. disable this in windbg by View|Options uncheck the Automatically scroll 

- windbg text features 
    + word wrap affects the whole window, not recommend 
    + Edit|Add to Command Output, adds a comment in the debugger command window 
    + customize the colors that are used for the text and the background of the debugger View|Options 
- remote debugging, the debugging client can access a limited number of commands to change this by use -clines command line option or the _NT_DEBUG_HISTORY_SIZE 

### Evaluating expressions 
- have two different expression 
    + MASM, all symbols are treated as address
    + c++, symbols are understood as the appropriate data types 
    
- each syntax is sued 
use _NT_EXPR_EVAL before the debugger started 
use the -ee {masm|c++} command line option 
use .expr(choose expression evaluator) command 

by default MASM is used 
    
- evalue a expression without change debugger state by ?(Evaluate expression) command 

all the debugging information window interpret their arguments throught the default expression evaluator 

    + ?? (evaluate C++ expression) 
    + watch window use the c++ expression evaluator 
    + locals window use the C++ expression evaluator 
    + some extension command use MASM evaluator 
    + if any part of an expression is enclosed in parenthese and you insert two at signs(@@) before the expression, the expression is evaluated by the expression evaluator that would not tyically be used in this case 
    
two at signs enable you to use two different evaluators of a single command. each appearance of the two at signs switches to the other expression evaluator 

c++ expression syntax is useful for manipulating structures and variables, but not well suited as a parser for the parameters of a debugger command 

- numbers in expression 
interpreted according to the current radix. the n(set number base) command can be used to set the default radix to 16, 10, or 85%29

default radix can be overridden by the 0x prefix, 0n (decimal), 0t(octal) or 0y(bynary)

number in c++ are interpreted as decimal numbers unless you specify differently 

- display numbers in serveral bases at the same time use .formats(show number formats) commads 

- symbols in expressions 

    + MASM expressions each symbol is interpreted as an address, is variable, function, seg
    + in c++ exression each symbol is interpreted according to its type
    
- is a symbol name ambiguous with the module name and an exclamation point (!). to specify a symbol is local use the $! before the symbol name. 

- operators in expressions. each expressions use different collection of operators 


### Using shell commands 
- use shell command .shell, if you are remote debugging the shell command are execute on the server 
- the .noshell(prohibit shell command) will disable all the shell command. the shell command will keep disable even use .restart(restart kernel connection) command

if you are running a debugging server you might want to disable the shell commands because remote connection can run shell on your computer 
- network driver control, File|Map network and Disconnect network driver always changes windbg is running on 

### Using aliaes
- debuggers support three kinds of aliaes 
    + user-named aliaes 
    + fixed-name aliases but they are named $u0, $u1, ...$u9 
    + set and named automatic alaes 
    
- defining a user named alias, you can set alias to string in memory, number expression, contents of a file, value of an environment variable or output of one or more debugger command 

names are case sensitive 

redefine a user-named alias used as(set alias) or aS(set Alias) command 

- remove an alias 
ad(delete alias) command 

- list all alias 
al(list aliases) command 

- defining a fixed-named alias, there are 10 fixed-name aliases $u0...$u9. their alias equivalents can be any string that does not contain the ENTER keystroke. use r(registers) command to define the alias equavalient. 

when define a fixed-name alias, you must insert a period(.) before the letter "u". the text after the equal sign(=) is the alias equivalent. should not enclose alias equivalent in quotation marks unless you want quotation mark in result 

- automatic aliases 
$ntnsym, nt symbols on the computer's native architecture, equal either ntdll or nt 
$ntwsym, nt symbols during 32-bit debugging that uses wow64, could be ntdll32 or 
$ntsym, same as $ntnsym 
$CurrentDumpFile
$CurrentDumpPath 
$CurrentDumpArchiveFile 
$CurrentDumpArchivePath 


### Using script files 
- is a text file contain a sequence of debugger command 
- execute a script file 
    + kd and cdb, create a script file named Ntsd.ini and put it in the directory where you are starting the debugger from. it will be automatic executed. use command line -cf to specify different startup file 
    
    + use -cfr option 
    + use the $<, $><, and $$>< command to execute a script file after debugger is running 
    
- supported commands 
You cannot use commands that are available only in WinDbg (such as .lsrcfix (Use Local Source Server), .lsrcpath (Set Local Source Path), .open (Open Source File), and .write_cmd_hist (Write Command History)) in script files, even if the script file is executed in WinDbg. In addition, you cannot use the .beep (Speaker Beep), .cls (Clear Screen), .hh (Open HTML Help File), .idle_cmd (Set Idle Command), .remote (Create Remote.exe Server), kernel-mode .restart (Restart Kernel Connection), user-mode .restart (Restart Target Application), or .wtitle (Set Window Title) commands in a script file

- you can only use .remote_exit command in script file that kd or cdb uses 

### Using debugger command programs 
#### Elements of a debugger command program 
- control flow tokens 
.if, .for and .while 

- use brace {} to enclose a bock of statement, bare pare of braces is not a block. it required a prefix flow control token. when enter a block all aliases with in the block are evaluated 

if you want to create a block only to evaluate aliaes, should use .block token 

- program can use user-named aliases or fixed-name aliaes. for numeric or typed variables, could use $tn pseudo-registers 

check the reference ###Pseduo-Register Syntax for more detail 

- user-named aliases are evaluated only if they are not next to other text. if you want to evaluate an alias that is next to other text, use the ${} (Alias interpreter) token. it support evaluate in variety of ways 

- add comments to a debugger command program which start with $$(comment specifier). 

- typically MASM syntax, when want to use c++ element use @@c++() token to switch to c++ syntax for that clause 

- the useful string operation tokens 
$scmp, $sicmp, $spat 

check the MASM numbers and operators for more detail 

#### Control flow tokens 
- the final command before a closing brace does not have to be followed by a semicolon 

- there is a individual reference for each tokens 
.if 
.else 
.elsif 
.foreach 
.for 
.while 
.break 
.do 
.continue 
.catch 
.leave is used to exit from .catch block 
.printf
.block, token performs no action 

- extensions tokens 
!for_each_module, !for_each_frame, !for_each_local 

#### execute a debugger command program 
- from debugger command window 
- write all the commands in a single line in a script file and execute with $<, $><, $$<, and $$>< commands 
$$><(run script file)

#### Debugger command program examples 
- .foreach
.foreach (place { s-[1]w 77000000 L?4000000 5a4d }) { dc place L8 } 

- walking the process list, save in a text file and execute with $$><(file-name)

    + The $t0, $t1, and $t2 pseudo-registers are used as variables in this program. The program also uses aliases named Procc and $ImageName.

    + This program uses the MASM expression evaluator. However, the @@c++( ) token appears one time. 

    + The ? flag is used with the r (Registers) command. This flag assigns typed values to the pseudo-register $t2
    
    + example 

$$  Get process list LIST_ENTRY in $t0.
r $t0 = nt!PsActiveProcessHead

$$  Iterate over all processes in list.
.for (r $t1 = poi(@$t0);
      (@$t1 != 0) & (@$t1 != @$t0);
      r $t1 = poi(@$t1))
{
    r? $t2 = #CONTAINING_RECORD(@$t1, nt!_EPROCESS, ActiveProcessLinks);
    as /x Procc @$t2

    $$  Get image name into $ImageName.
    as /ma $ImageName @@c++(&@$t2->ImageFileName[0])

    .block
    {
        .echo ${$ImageName} at ${Procc}
    }

    ad $ImageName
    ad Procc
}

- walking the LDR_DATA_TABLE_ENTRY list, will display full path of each list entry 

    + user-named alias $Base and $Mod are used. The ${/v:} token interprets the alias literally preventing it from being replaced if it was defined before the script is run 
    
    + .block is used to add extra lias replacement step. it is used to let .echo command recieve the value of $Mod and $Base 
    
    + example 
$$ Get module list LIST_ENTRY in $t0.
r? $t0 = &@$peb->Ldr->InLoadOrderModuleList
 
$$ Iterate over all modules in list.
.for (r? $t1 = *(ntdll!_LDR_DATA_TABLE_ENTRY**)@$t0;
 (@$t1 != 0) & (@$t1 != @$t0);
      r? $t1 = (ntdll!_LDR_DATA_TABLE_ENTRY*)@$t1->InLoadOrderLinks.Flink)
{
    $$ Get base address in $Base.
 as /x ${/v:$Base} @@c++(@$t1->DllBase)
 
 $$ Get full name into $Mod.
 as /msu ${/v:$Mod} @@c++(&@$t1->FullDllName)
 
 .block
    {
        .echo ${$Mod} at ${$Base}
    }
 
    ad ${/v:$Base}
    ad ${/v:$Mod}
}



## Using the windbg graphical interface 
- double click title to undock 
- drag and drop to position or window to dock 
...

### Using debugging information windows 
- windbg has ten kinds of debugging information windows, you can have only one instance of the following windows open at the same time 
    + debugger command window 
    + watch window 
    + locals window 
    + register window 
    + calls window 
    + disassembly window 
    + processes and threads window 
    + scratch pad 
    + can display multiple source window and memory window at the same time 
    
### Opening a window 
- use accelerate key alt+1~9 to open the relative window 
command alt+1
watch alt+2 
locals alt+3
registers alt+4 
memory alt+5 
calls alt+6 
disassembly alt+7 
scratch pad alt+8 
processes and threads alt+9 
source window ctrl+O

- configuring a window, each debugging information window has a shortcut menu that you can access by right-click the title bar of the window or by clicking the icon near the upper-right corner of the title bar 
such as quick access to the relative help page 

- moving through a window 
some window support the find, go to address or go to line command they only change the windbg display but not affect the execution of the target 

    + find command
    ctrl+f, enter the text you want to find 
    
    + go to address 
    ctrl + g 
    when the view code offset dialog box appears enter the address that you want to search. debugger moves the cursor to the begging of the function or address in the disassembly window or a source window 
    
    + moving a specific line, go to line command search for a line in the active source widnow, if the active window is not a source window you cannot use the go to line command. to active this option click go to line on the edit menu or press ctrl+L 

- changing text properties, setting the font, font style and font size. all debugging information windows hare the same font. click Font on the View menu 

change tab width by Options|View in the tab width enter the number of spaces 

- positioning the windows 
...


###Using workspaces 

####Using ThemesProvided in debugging tools 
- provided by debugging tools for window those themes are 
Standard.reg, 
Standardvs.reg, 
Srcdisassembly.reg, 
Multimon.reg

#### Using the toolbar and status bar 
- toolbar 
- statusbar 
Message 
Ln, Col, line number and column number 
Sys, shows the internal decimal number of the system that you are debugging. 
Proc, internal decimal number of the process id 
Thrd, thread id 
ASM, current debugging mode, such as ASM. if it unavaliable then windbg is running in source mode 
OVR, if overtype is active or it is insert mode 
CAPS
NUM 
...

## Using Debugger Extension 
- VS, windbg, cdb, kd all allow the use of debugger extension commands. these commands are exposed by DLLs 

### Loading Debugger extension dll 
- set the default extension DLL location 
    + use the environment variable _NT_DEBUGGER_EXTENSION_PATH, can be a number of directory paths separated by semicolons 
    
    + .load command, .unload, unloadall 
    + CDB only, use the tools.ini file to set the default extension dll 
    + use -a command-line option 
    + .extpath to set the extension search path 
    + .setdll set default extension dll 
    + .chain(list debugger extensions) display all the loaded debugger exntesion modules in their default search order
    
- load a extension dll by use the full !module.extension syntax to issue a command from that module 

- the extension dlls ship with the debugging tools for windows package are each placed in different subdirectory 
    + winxp dir contain xp+ extensions 
    + winext contains extension for any version of window. dbghelp.dll module located in the base directory of the debugging tools for windows 
    
### Using debugger extension commands 
### Writing new debugger extensions 

##Remote debugging 
## Debugging Previous versions of windows 

# Debugging Techniques 
## Standard debugging techniques 
## Writing new debugging extensions 

    
# Debugger Reference 
...
##windbg commandline options 
windbg [ -server ServerTransport | -remote ClientTransport ] [-lsrcpath ]
   [ -premote SmartClientTransport ] [-?] [-ee {masm|c++}] 
   [-clines lines] [-b] [-d] [-a Extension] [-e Event] 
   [-failinc] [-g] [-G] [-hd] [-j] [-n] [-noshell] [-o] 
   [-Q | -QY] [-QS | -QSY] [-robp] [-secure] [-ses] [-sdce] 
   [-sicv] [-sins] [-snc] [-snul] [-sup] [-sflags 0xNumber] 
   [-T Title] [-v] [-log{o|a} LogFile] [-noinh] 
   [-i ImagePath] [-y SymbolPath] [-srcpath SourcePath] 
   [-k [ConnectType] | -kl | -kx ExdiOptions] [-c "command"] 
   [-pb] [-pd] [-pe] [-pr] [-pt Seconds] [-pv]
   [-W Workspace] [-WF Filename] [-WX] [-zp PageFile] 
   [ -p PID | -pn Name | -psn ServiceName | -z DumpFile | executable ] 

windbg -I[S] 

windbg -IU KeyString

windbg -IA[S] 

All command-line options are case-sensitive except for -j. The initial hyphen can be replaced with a forward-slash (/).

If the -remote or -server option is used, it must appear before any other options on the command line. If an executable is specified, it must appear last on the command line; any text after is passed to the executable program as its own command-line parameters.

[-b] is abandoned
[-c " command "] specifies the initial debugger command to run at start-up, commands can be separated with semicolons
[-clines lines] set the approximate number of commands in the command history which can be accessed during remote debugging 
[-d], after a reboot the debugger will break into the target computer as soon as a kernel module is loaded 
[-e] signals the debugger that the specified event has occurred 
[-ee {masm|c++}] sets the default expression evaluator, masm is the default 
[-failinc] cause the debugger to ignore any questionable symbols 
[-g] user mode only ignores the initial breakpoint in target application which will cause the target application to contitnue running after it is started or windbg attach to it 
[-G] user mode only ignores the final break point. the same effect is command sxd epr 
[-hd] window xp+ user mode specifies that the debug heap should not be used 
[-I[S]] installs windbg as the postmortem debugger 
[-IA[S]] associates windbg with the file .dmp, .mdmp and .wew in the registry 
[-IU KeyString] registers debugger remoting as an URL type so that users can ato-launch a debugger remote client with a URL KeyString format remdbgeng://RemotingOption
[-i image-path] specifies the location of the executables that generated the fault 
[-j] allow journaling 
[-k connect-type] starts a kernel debugging session 
[-kl] window xp+ starts a kernel debugging session on the same machine as the debgger 
[-kx ExdiOptions] start a kernel debug uses a EXDI driver 
[-log{o|a} LogFile] begins logging info into a log file 
[-lsrcpath] sets the local source path for a remote client 
[-n] noisy symbol load 
[-noinh]user mode only prevents processes created by the debugger from inheriting handles from the debugger 
[-noprio] prevents any priority changes from windbg 
[-o] debugs all processes launches by the target application
[-p pid]
[-pb] (Windows XP and later, user mode only) Prevents the debugger from requesting an initial break-in when attaching to a target process. This can be useful if the application is already suspended
[-pd ]
(Windows XP and later, user mode only) Causes the target application not to be terminated at the end of the debugging session. See Ending a Debugging Session in WinDbg for details.

[-pe ]
(Windows XP and later, user mode only) Indicates that the target application is already being debugged. See Re-attaching to the Target Application for details.

[-pn Name ]
Specifies the name of the process to be debugged. (This name must be unique.) This is used to debug a process that is already running.

[-pr ]
(Windows XP and later, user mode only) Causes the debugger to start the target process running when it attaches to it. This can be useful if the application is already suspended and you wish it to resume execution.

[-psn ServiceName ]
Specifies the name of a service contained in the process to be debugged. This is used to debug a process that is already running.

[-pt Seconds ]
Specifies the break timeout, in seconds. The default is 30. See Controlling the Target for details. 

[-pv ]
(User mode only) Specifies that the debugger should attach to the target process noninvasively. For details, see Noninvasive Debugging (User Mode).

[-Q ]
Suppresses the "Save Workspace?" dialog box. Workspaces are not automatically saved. See Using Workspaces for details.

[-QS ]
Suppresses the "Reload Source?" dialog box. Source files are not automatically reloaded.

[-QSY ]
Suppresses the "Reload Source?" dialog box and automatically reloads source files.

[-QY ]
Suppresses the "Save Workspace?" dialog box and automatically saves workspaces. See Using Workspaces for details.

[-robp ]
This allows CDB to set a breakpoint on a read-only memory page. (The default is for such an operation to fail.) 

[-sdce ]
Causes the debugger to display File access error messages during symbol load. For details and for other methods of controlling this, see SYMOPT_FAIL_CRITICAL_ERRORS.

[-secure ]
Activates Secure Mode.

[-ses ]
Causes the debugger to perform a strict evaluation of all symbol files and ignore any questionable symbols. For details and for other methods of controlling this, see SYMOPT_EXACT_SYMBOLS.

[-sflags 0x Number] 
Sets all the symbol handler options at once. Number should be a hexadecimal number prefixed with 0x -- a decimal without the 0x is permitted, but the symbol options are binary flags and therefore hexadecimal is recommended. This option should be used with care, since it will override all the symbol handler defaults. For details, see Setting Symbol Options.

[-sicv ]
Causes the symbol handler to ignore the CV record. For details and for other methods of controlling this, see SYMOPT_IGNORE_CVREC.

[-sins ]
Causes the debugger to ignore the symbol path and executable image path environment variables. For details, see SYMOPT_IGNORE_NT_SYMPATH.

[-snc ]
Causes the debugger to turn off C++ translation. For details and for other methods of controlling this, see SYMOPT_NO_CPP.

[-snul ]
Disables automatic symbol loading for unqualified names. For details and for other methods of controlling this, see SYMOPT_NO_UNQUALIFIED_LOADS.

[-srcpath SourcePath ]
Specifies the source file search path. Separate multiple paths with a semicolon (;). If the path contains spaces, it should be enclosed in quotation marks. For details, and for other ways to change this path, see Source Path.

[-sup ]
Causes the symbol handler to search the public symbol table during every symbol search. For details and for other methods of controlling this, see SYMOPT_AUTO_PUBLICS. 

[-T Title ]
Sets WinDbg window title.

[-v ]
Enables verbose output from debugger.

[-W Workspace ]
Loads the given named workspace. If the workspace name contains spaces, enclose it in quotation marks. If no workspace of this name exists, you will be given the option of creating a new workspace with this name or abandoning the load attempt. For details, see Using Workspaces.

[-WF Filename ]
Loads the workspace from the given file. Filename should include the file and the extension (usually .wew). If the workspace name contains spaces, enclose it in quotation marks. If no workspace file with this name exists, you will be given the option of creating a new workspace file with this name or abandoning the load attempt. For details, see Using Workspaces.

[-WX ]
Disables automatic workspace loading. For details, see Using Workspaces.

[-y SymbolPath ]
Specifies the symbol search path. Separate multiple paths with a semicolon (;). If the path contains spaces, it should be enclosed in quotation marks. For details, and for other ways to change this path, see Symbol Path.

[-z DumpFile ]
Specifies the name of a crash dump file to debug. If the path and file name contain spaces, this must be surrounded by quotation marks. It is possible to open several dump files at once by including multiple -z options, each followed by a different DumpFile value. For details, see Analyzing a User-Mode Dump File with WinDbg or Analyzing a Kernel-Mode Dump File with WinDbg.

[-zp PageFile ]
Specifies the name of a modified page file. This is useful if you are debugging a dump file and want to use the .pagein (Page In Memory) command. You cannot use -zp with a standard Windows page file -- only specially-modified page files can be used. 

executable 
Specifies the command line of an executable process. This is used to launch a new process and debug it. This has to be the final item on the command line. All text after the executable name is passed to the executable as its argument string. For details, see Debugging a User-Mode Process Using WinDbg.

[-? ]
Pops up this HTML Help window.
    
    