XAML pattern=Michael L Perry;Note=Erxin

# introduction
- pattern structure
problem, goals, framework, steps
- pattern languages
Composition, Animations, View Models, Behavioral, Design-Time Data
- course structure
    + basic understanding xaml
    + pattern modules (3-7)
    beginning to end
    skip around
    refer back
    grouped by usage
    source code available
    + introductory modules (1 and 2)
    deconstruct your basic understanding 
    buidling blocks
- object graphs xaml to codes
xmlns:hw="clr-namespace:HelloWord"      using hw = HellowWorld;

<TextBlock                              var textBlock = new TextBlock();
    Text="Hello".>                      textBlock.Text = "Hello";
    
<Border>                                var border = new Border();
    <Border.Background>                 border.Background = 
        <LinearGradientBrush>                  new LinearGradientBrush();
        </LinearGradientBrush>
    </Border.Background>
</Border>

<Border>                                var border = new Border();
    <TextBlock/>                        border.Child = new TextBlock();
</Border>

<StackPanel>                            var sp = new StackPanel();
    <Border/>                           sp.Children.Add(new Border());
    <TextBlock/>                        sp.Children.Add(new TextBlock());
</StackPanel>

- Dependency Properties can be set by external forces
    + data binding
    + styles
    + animations
    
    + dependency property is register as the static property of a dependency object
    
    public static DependencyProperty AwesomenewssProperty = DependencyProperty.Register(
        "AwesomenewssProperty",
        typeof(Awesomenewss),
        typeof(AwesomeControl));

    public double Awesomenewss
    {
        get { return (double)GetValue(AwesomenewssProperty);}
        set { SetValue(AwesomenewssProperty, value);}
    }
    
    the property use the base class's GetValue SetValue to allow XAML access the property without access the real object

    + Misnomer of the dependency property, no dependency tracking for the dependency property value
        * see stateless view models
        * better names may be
        bindable properties
        stylable properties
        animatable properties
        
        * the reason why named dependency property may be used to mark the property is dependable by the XAML
- styles, xaml != css, differences
    + css have selectors
    span, type
    .my-class,  class
    #my-id, id
    div .inner-class, structure
    a:hover{}, states
    
    + xaml styles have key but don't have selectors, apply manually to a individual element or implicitly to all of a element type
    <Style x:Key="MyStyle"></Style>
    
    if you want to apply a style with a give state, you have to combine style with a trigger, behaviour or a visual state
    
    + cascading css, css style will overwrite each other follow the over right rules
    
    + xaml style can't be overwrite, each element can only have one style, style can inherit from each other
    
    <Style x:Key="BlueBorder" TargetType="Border">
        <Setter Property="Background" Value="Blue"/>
    </Style>
    <Style x:Key="GreenBorder" TargetType="Border">
        <Setter Property="Background" Value="Green"/>
    </Style>
    
    <Border Style="{StaticResource BlueBorder}">
        <TextBlock Text="What color am I?"/>
    </Border>
    
    + properties, css can only set simple properties which is predefined by browsers
    .my-class
    {
        background-color:green;
        margin:4px;
    }
    
    + properties, xaml can set complex properties, there are entire structured properties including visual state managers, template and behaviors
    xaml style can also used to set custom properties, can be used to set control state and list of animations
    
    <Style x:Key="MyStyle" TargetType="AwesomeButton">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate>
                    ...
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Setter Property="Awesomeness" Value="11.0"/>
    </Style>

# Blend Techniques
- Blend for Visual Studio 2012, apply update 2 for 2012
    + download blend
    dev.windows.com
- getting around
ctrl+0, pop the window to full screen into art screen
use scroll to zoom
h, to move user interface
v, ...
check the toolbox tooltip accelerate keys
- layout properties
    + click on size to add rows and columns
    + view source to check the source from the left visual tree
    + right click a element and fill a element
    + link or unlink the margin and padding
- grid properties
    + use grid 1* and 2* to give the proportion 
    + change the pixel size to exact value to set fixed pixel
    + right click the content menu to select relative methods

    
# Composition Patterns
- composability
    + use a construct in different places
    + a component is independent of its container
    + leave holes inside a component
    behavior is inject when needed
    + xaml contain
    grid, stackPanel, userControl, DataTemplate, ControlTemplate, ContentControl
- compoasition patter
    + isolation
    easy to change
    developer/designer
    components
    + organization
    easy to navigate
    resources
    views
    + extensibility
    easy to build upon
    forms, extensible forms
    controls
- grid layout
    + to prevent blend create usercontrol in the wrong namespace, create the usercontrol in VS and set the namespace and open in blend
    + create grid basic layout rows and columsn
    + drag and drop required user control to the space where they should be
    + right click the control and select Reset Layout|All to fill the control to all of the grid, if the control crossover more rows or columns. it will auto set row or column span
    
- balanced whitespace
    + set control's white space to border and each other
    + decide a desire adjoin controls, then allocate half space to the leaf controls the this will fit
    
    and add half of the margin to the container of the user controls
    
    then the margin will be come to the required size
    
    + margin different in HTML
    the margin of html element will pick the max value from adjacent elements
    
    the margin in xaml will add all the margin together
    
- overflow, let control fill into the previous created white spaces, adjust the white space at the leaf control. such as set negative margin
the list box have a default 1 pixel border

- Justified ListBox, the item in the list box, the item content is background is not grow to fill all the list container
    + use HorizontalContentAligment to Strength in wpf
    +  set item container style, as JustifiedItemStyel to set HorizontalContentAligment to Stretch
    
    <Style x:Key="JustifiedItemStyle" TargetType="ListViewItem">
        <Setter Property="HorizontalContentAligment" Value="Stretch"

    then set the list item container style to this static resource
    <ListView
        ItemContainerStyle="{StaticResource JustifiedItemStyle}"/>
    
- Extension Grid, optimize the contained controls to fit grid size
    + auto-sized controls, determine their own size by their content
    check box
    button
    single-line text box
    
    + container-sized controls
    multi-line text box
    list box
    
    + stack panel, is a container for the controls could determine their own height
    
    + grid, control need to take the container size like to add on a grid
    use star size to autosize column or row
    
    + best practise for this is use grid to layout and use stack panel to contain the control which may add new controls
    set the stack panel to auto size in the container grid then whenever add new controls to the stack panel. The container grid will not need to add column or rows
    
    + use reset layout in the blend to clear the mess layout settings
    + the layout panel of a control could use to set control to auto size by the button neary by the right of height or width text
    
    + add new control a container
        * select the container
        * click the required control in the toolbox
    
- assets, design asset resources
    + xaml resource website
    xamalot.com
    syncfusion.com/download/metriostudio
    
    + use other tools by 
    inkscape with adobe.com/products/illustrator
    
    + separate assets independence
    
    + resource dictionary
    prefix keys
    load dictionary by merge dictionary
    
    + each asset should be a path inside a canvas, canvas is the container, the canvas don't extend it's size by the content because the path may draw out of the canvas in sometimes
    the canvas need to set explicitly
    
    + you can never sure the designer use the same pixel size as your application
    in order to reuse the asset, the canvas should be put into a viewbox, the viewbox will resize it's content to match it's container
    
    + use your asset to application by add a content control into desire location then use the layout tools to place the content control
    
    set content property of the content control to static resource of the asset
    
    + add icons buttons for example
        * download icons from the resource website as resource dictionary
        * load resource dictionary into the blend solution
        add existing item
        * the blend will automatic add it into the merge dictionary in the app
    
        * in visual studio with ctrl+e+d to reformat the xaml
        * the viewbox will be automatic into the resource dictionary to container the icons
        * add x:Key to prefix with the resource file name such as IconButtons.UserGroup
        
        * add content control to the desire place
        * choose the content for the control from the blend panel and select it from the static resource
        
        * check if the download resources is contain in a viewbox, add x:Key for the viewbox
        
- control template
    + in previous window development the appearience of a application will be two kinds
        * classical 
        * completely custom
    
    + in xaml, controls are lookless, control only specifies behavior
        * template determines appearance
        * choose control based on desired behavior
        such as change the menu control to look like text box
        * custom the template to make them looks like what they want
        
        * template relative items
        content presenter, which is used to display default user control
        content control which is used to display custom view
        
        set template binding by the item's right rectangle button to set binding
        
- control extension
    + control template could control the display of a control,      
    + a control extension is a sub class of a control and use container merge this elements together. 
    add dependency property for the specifiy property and let the container fill in the property
    the dependency property could be bind to the template properties
    such as bing string to text, bind double to position, even create framework element to bind any UI into the control
    
    + steps
        * create custom control
        * make the control derive from the aim behavior control
        * visual studio will automatic generate a generic.xaml file as resource dictionary for the custom control as control template
        * copy the previous control template into the generaic.xaml could accelerate the creating steps
        * update the target type for the custom control and remote the previous created key or just create the template from blend
        * the generic.xaml is created in a theme folder. the generic style could be used to quickly switch the theme of a application
    
        * use code snippet mvvmpropdp to create a dependency property as framework element named icon used to bind any icon
        
        * use content control or content presenter to set the 
        content control need to use the content property and use the template binding bind to the icon property
        
        use content presenter binding the content source to the icon property
        
        * create icon custom control and set the icon to the static resource
        
- implicit data template, composing items into list
    + listbox, show activity and activity could be multiple kinds
    + each activity could contain their specify user control
    + each control also have control background color for setting themes
    + platform support
        * wpf, directly support, by setting datatype property into the <DataTemplate DataType="{x:Type ...}"/> 
        * indirect support in windows 8 by DataTemplateSelector
        * silverlight and windows phone have to simulate the behavior by content control
    + wpf example
        * add datatemplate as resources
        <DataTempalte DataType="{x:Type m:BussinessDevelopmentActivity}">
            <c:BusinessDevelopmentActivityControl/>
        </DataTemplate>
         <DataTempalte DataType="{x:Type m:RecruityActivity}">
            <c:RecruityActivityControl/>
        </DataTemplate>
         <DataTempalte DataType="{x:Type m:UserGroupActivity}">
            <c:UserGroupActivityControl/>
        </DataTemplate>
        
        * binding ItemSource of the list control to Activities which is the base class of all the three activities
        <ListBox ItemSource="{Binding Activites}"/>

    + window 8 example
        * create resource with key for the specify data template
        <DataTempalte x:Key="BussinessDevelopmentActivity">
            <c:BusinessDevelopmentActivityControl/>
        </DataTemplate>
         <DataTempalte x:Key="RecruityActivity">
            <c:RecruityActivityControl/>
        </DataTemplate>
         <DataTempalte x:Key="UserGroupActivity">
            <c:UserGroupActivityControl/>
        </DataTemplate>
        
        * create a selector class t select the data template for the listbox
        
        public class ImplicitDataTemplateSelector: DataTemplateSelector
        {
            protected override DataTemplate SelectTemplatCore(object item, DependencyObject container)
            {
                string key = item.GetType().Name;
                
                FrameworkElement element = container as FrameworkElement;
                while(element != null)
                {
                    if(element.Resources.ContiansKey(key))
                        return element.Resource[key] as DataTemplate;
                    element = VisualTreeHelper.GetParent(element) as FrameworkElement;
                }
                return Application.Current.Resource[key] as DateTemplate;
            }
        }
        
        * create a instance for the implicityDataTemplate selector into the resources
        <s:ImplicitDataTemplateSelector x:Key="ImplicitDataTemplateSelector"/>
        
        <ListBox ItemTemplateSelector="{StaticResource ImplicitDataTemplateSelector}" ItemSource="{Binding Activities}"/>
        
    + silverlight and windows phone
        * put the named dictionary data template as resource
        <DataTempalte x:Key="BussinessDevelopmentActivity">
            <c:BusinessDevelopmentActivityControl/>
        </DataTemplate>
         <DataTempalte x:Key="RecruityActivity">
            <c:RecruityActivityControl/>
        </DataTemplate>
         <DataTempalte x:Key="UserGroupActivity">
            <c:UserGroupActivityControl/>
        </DataTemplate>
        
        * use content control for display the data template, content control can compose item from outside such as asset into a template
        
        public class ImplicitDataTemplateControl:ContentControl
        {
            protected override void OnContentChanged(object oldContent, object container)
            {
                ContentTemplate = SelectTemplateCore(newContent, this);
                
                base.OnContentChanged(oldContent, newContent);
            }
            
            protected DataTemplate SelectTemplateCore(object item, DependencyObject container)
            {
                string key = item.GetType().Name;
                FrameworkElement element = container as FrameworkElement;
                while(element != null)
                {
                    if(element.Resources.ContiansKey(key))
                        return element.Resource[key] as DataTemplate;
                    element = VisualTreeHelper.GetParent(element) as FrameworkElement;
                }
                return Application.Current.Resource[key] as DateTemplate;
            }
        }
        
        * add ImplicityDataTemplateControl into resource, the {Binding} expression by default will binding the control's DataContent property to Content property this will trigger the data content change event of the implicit data template control
        <DataTemplate x:Key="ActivityItemTemplate">
            <s:ImplicityDataTemplateControl Content="{Binding}"/>
        </DataTemplate>
        <DataTempalte x:Key="BussinessDevelopmentActivity">
            <c:BusinessDevelopmentActivityControl/>
        </DataTemplate>
        ...
        
        * set the item template to the activity item template
        <ListBox ItemSource="{Binding Activities}" ItemTemplate="{StaticResource ActivityItemTemplate}"/>
        
        
# View Model Patterns
- Introduction
    + Presentation Model
        * Martin Fowler, 2004
        * Separation Pattern
        * Remove state and behavior from the view
        
    + Model View VIewModel
        * John Gossman 2005
        * Presentation Model for XAML
        * CLR data binding, wpf data binding is powerful to data binding to a clr object not just database object
    + family of Patterns
        * opinions based on constraints
        how to respond to events
        how to communicate among view models
        how to pair a view model with a view
    + goals
    isolation, testability, resiliency to change
    
- stateful view models
    + remove state and data from UI into view model
    + problems with data in the UI
        * hard to test
        can't create an instance of form
        
        * couples business logic to UI
        business logic depends up on UI
        UI invokes business logic
        
    + stateful view model libraries
        * mvvm light toolkit
        * Calibrun micro
        * symbol mvvm
    
    + demo mvvm toolkit
- reactive view model
    + tools
    reactive ui pattern
    
    + do a search, and automatic fire search from a text box without search button
    
- stateless view models
    + move data from view model to model, to free models from sync same data for each other

    + state is a field of a class and a auto property, readonly property is not a state
    
    + use INotifyPropertyChanged with stateless pattern, the model cant directly call the property changed method. several ways to walk around this is 
        * dependency tracking
        knock out
        update controls, library to does dependency tracking
    
    + stateless pattern is only container readonly model without fields

- Message bus
    + use message bus to connect with view model
    + libraries with message bus to communicate between view model
        * mvvm light
        MessengerInstance.Send

- Selection Model, keep different parts of selection sync, use to assign a selected view model to a content detail page
- View model locator, avoid add view model initialize code into the view
    + each view use view model locator to locate view mode
    + use IoC container common implement this pattern
    
- view model first, view model can be initialize with parameter
- view services, messenger and view services
    + don't look up rule for mvvm pattern
    + use view service interface for the view model which need to display dialog or message box during their work on their business logic
    
    + use view model locator to register the iview service with the view when the view is loaded
    unregister the service when the view is unloaded
    
    the view model use the viewModel locator to get the relative iview service from their code

- view model events, is a variation of view model locator service, which use event to isolate view model and view, view model define event and the view subscribe relative event


# Design-Time data patterns
- outline
    + patterns
    in-place data
    in-place child items
    sample data
    + design-mode view models
    + design mode models
    + shadow types
    + goals
    visualize application data
    stay in flow, we think in designer
    evolve with the application
- in-place data pattern
    + stay in the designer
    + freedom to brainstorm
    + design realistic data
    + paste into xaml and value with
    weight, emphasis, relationships, size, colors, proximity
    + blend support copy html code directly into the designer

- in-place child items
    + in-place strings, use .net string object for simple data
    xmlns:core="clr-namespace:System;assembly=mscorlib"
    
    <DataTemplate x:Key="SessionItemTemplate">
        <TextBlock Text="{Binding}"/>
    </DataTemplate>
    
    <ListBox ItemTemplate="{DynamicResource SessionItemTemplate}">
        <core:String>...</s:String>
        <core:String>...</s:String>
    </ListBox>
    
    + complex types
        * define data types
        * auto properties
        * set attributes
        * bind to attributes
        * not a real view model!
- sample data, remove data from xaml 
    + stored in a separate xml file
    + bound to views at design time
    + does not work in windows store apps
    + generate Loren lpsum by default
        * name
        * phone
        * address
        * email
    + not representative of domain

    + generated based on view model
    + regenerate sample data by change the generate rules or delete the sample data files
        * delete the sample data
        rebind the container
    + do not edit the xaml
        * easy to regenerate
    
    + use sample data
        * create required view
        * open data panel in blend by the window menu
        * select the right corner button, select create sample data from a class, and select the relative view model
        * drag and drop to the to level container of the visual tree container
        * drag drop the property to the aim view element to make a data binding
        directly drag drop a complex type will make the iterate container regenerate the template
        use property data context to select the specify data will not rewrite the data template
    
- design-mode view models, different from sample data
    + designer executes the code
    + stateful view models
    + steps
        * create design-mode data source
        * resource dictionary
        * data bind the instance to the data context in the d namespaces
    + view mode locator for the designer
    + trade off
        * more realistic not lorum ipsum
        * more expensive, wait until view models stablize
        
    + create a design model data source
        * create trac view model
        
        public class DesignModelDataSource
        {
            public TrackViewModel Track
            {
                get
                {
                    return new TrackViewModel
                    {
                        Name="Web",
                        Sessions = new List<SessionHeaderViewModel>{
                            ...
                        }
                    }
                }
            }
        }
        
        create the design view model instance as application resources and give it a x:Key 
        xmlns:ds="clr-namespace:...."
        
        <Application.Resources>
            <ds:DesignModelDataSource x:Key="DS"/>
        </Application.Resources>
        
        then go to the view bind the view to the design model data context
        d:DataContext = "{Binding Track, Source={StaticResource DS} }"
    
- Design-Model Models, Stateless view models, populate stateless models design model for the design model data
    + benefits
    fewer degrees of freedom
    data can't get out-of-sync
    less plumbing
    
    + cost
    design-mode data is harder for stateless view model
    no state: reference to model
    create a design-model model
    
    + create models in constructor
    store model in fields
    inject models into the stateless view models
    
    + tradeoff
    harder to maintain
    reuse model
    expose view model behavior, data formatting
    
- shadow types, avoid view model dependencies, xaml doesn't check type
    + no type declaration on datacontext
    + walks the path
    + same shape as view model
        * shadow types
        * make shadow types have same properties with view model
        * realistic data fill into the shadow typs and bind to the view as design model data context

    
# behavioral patterns
- introduction
    + decisions for 
    separation for coder
    freedom for designer

    + separatio commands
    stateful -> relay command
    stateless -> dependent command
    reactive -> reactive command
    
    + freedom behaviors
    attached behaviors
    blend behaviors
    trigger actions
    targeted trigger actions

- relay command
    + commands without classes
    + command in xaml which impliment the ICommand interface
    public interface ICommand
    {
        //when the command invoke will call this method
        void Execute(object parameter);
        
        //enable or disable command
        bool CanExecute(object parameter);

        //the view subscribe to figure out when to call the CanExecute again
        event EventHandler CanExecuteChanged(); 
    }
    
    + Josh Smith offer a relay command pattern to reduce write codes for creating command objects
    mvvmlight toolkit also implement the relay command pattern
    
    + relay command is use delegates as parameter for the execute, canexecute, and canExecuteChange. 
    
    this will avoid rewrite all the command classes
    
- dependent command, express the dependent property once
    + conditions
    + a improved relay command with dependency
    + use dependency tracking to track the properties
    InstallCommand, canExecute, use .net expression for runtime create dependency tracking
    
    + example
    MakeCommand.When(()=>{ !string.IsNullOrEmpty(Property);})
               .Do(()=>{func();}); 
               
    the dependent command will automatic use expression to auto generate method to call the CanExecuteChange for the properties which the command depends on
    
- reactive command, reactive pattern is treat events as stream, the reactive command combine with reactive view model pattern, and it will turn a stream event to another stream events
reactive command pattern turn a stream of properties changes event to command can execute events

    + example
    private ReactiveCommand _installCommand;
    
    var locationEvents = this.ObservableForProperty(_=> _.location)
                             .Value();
    var agreeEvents = this.ObservableForProperty(_ => _.Agree)
                          .Value();
    var canExecuteStream = locationEvents.CombineLatest(agreeEvent, (l, a)=>!string.IsNullOrEmpty(l) && a)
    
    _installCommand = new ReactiveCommand(
        canExecute:canExecuteStream,
        initialCondition:false
    );
    _installCommand.Subscribe(e => Install());
    
- attached behaviors, extend existing controls, attached property is a property 
    + Nikhil Kothari, attached behavior
    + dependency property is used to property binding
    + attached property is a property with could be attached from parent element to the child elements
    <Grid>
        <TextBlock Grid.Row="1">Text</TextBlock>
    </Grid>
    
    the grid.Row is a attached property which could be attached to any child element of the grid
    
    + attached behavior pattern is used the attach property to implement the behavior pattern. 
    
    use a static class to create a attached property for the component element and the attached property will be set to the view mode's clr property
    when the attached property changed the static class will automatic all the property changed event by clr and the component could subscribe this event and call the relative event handler to allow the static class hand both component and view model logic
    
    + implement attach behavior, create a d
    public static class ClickBehavior
    {
        public static DependencyProperty CommandProperty = DependencyProperty.RegisterAttached(
            "Command",
            typeof(ICommand),
            typeof(ClickBehavior),
            new PropertyMetadata(CommandPropertyChanged));
            
        public static ICommand GetCommand(DependencyObject obj)
        {
            return obj.GetValue(CommandProperty) as ICommand;
        }
        
        public static void SetCommand(DependencyObject obj, ICommand value)
        {
            obj.SetValue(CommandProperty, value);
        }
        
        //register the dependecy object that the command apply to
        private static void CommandPropertyChanged(
            DependencyObject d,
            DependencyPropertyChangedEvent e)
        {
            var uiElement = d as UIElement;
            if(uiElement != null)
            {
                uiElement.MouseDown += UIElement_MouseDown;
            }
        }
        
        private static void UIElement_MouseDown( object sender, MouseDOwnEventArgs e)
        {
            var command = GetCommand((DependencyObject) sender);
            if (command != null && command.CanExecute(null))
                command.Execute(null);
        }
    }
    
    then in the xaml file add the relative namespace to the xaml
    xmlns:b="clr-namespace..."
    
    then any ui element could be bound with this attached property
    <Rectangle b:ClickBehavior.Command="{Binding IncrementCommand}"/>
    
    + this is used to add behaviors to existed UI element
- Blend behavior
    + attached behaviors
    no encapsulation
    memory leask
    no designer support
    
    + blend behaviors
    components
    attach to object
    designer support
    
    + design a blend behavor is used to inherite from abstract class Behavior<T>
    public abstract class Behavior<T> where T: DependencyObject
    {
        protected T AssociatedObject {get;}
        protected virtual void OnAttached();
        protected virtual void OnDetaching();
    }
    plus dependency property
    
    + open the ui elmenet in blend, attach the behavior in side the blend
    + example to create IncreamentBehavior with blend behavior
    public class IncreamentBehavior: Behavior <UIElement>
    {
        public static DependencyProperty CountProperty = DependencyProperty.Register(
            "Count",
            typeof(int),
            typeof(IncreamentBehavior));
            
        public static DependencyProperty IncrementProperty = DependencyProperty.Register(
            "Increment",
            typeof(int),
            typeof(IncreamentBehavior));
        
        public int Count
        {
            get {return (int)GetValue(CountProperty);}
            set {SetValue(CountProperty, value);}
        }
        
        public int Increment
        {
            get {return (int)GetValue(IncrementProperty);}
            set {SetValue(IncrementProperty, value);}
        }
        
        protected override void OnAttached()
        {
            AssociatedObject.MouseDown += AssociatedObject_MouseDown;
            base.OnAttached();
        }
        
        protected override void OnDetaching()
        {
            AssociatedObject.MouseDown -= AssociatedObject_MouseDown;
            base.OnDetaching();
        }
        
        void AssociatedObject_MouseDown(object sender, MouseButtonEventArgs args)
        {
            Count += Increment;
        }
    }
    
    after rebuild the blend behavior will become available in the asset panel of Blend(at the left top corner with projects and states panel), to the projects tab will display the new added blend behavior
    drag and drop the behavior to the uielment, and binding the relative data context
    
- Trigger Actions, most behaviors are simple triggers action by events
    + trigger action pattern define simple reusable event handlers, trigger action is 
    + similar like the behavior pattern creation
    + just for handling events
    
    public abstract class TriggerAction<T>: where T:DependencyObject
    {
        protected T AssociatedObject {get;}
        protected virtual void OnAttached();
        protected virtual void OnDetaching();
        protected abstract void Invoke(object parameter);
    }
    
    only need to handle the invoke method
    
    use the pervious Blend IncrementBehavior class and change the base class from Behavior to TriggerAction, overwrite the OnAttached
    
    public class IncreamentBehavior: TriggerAction <UIElement>
    {
        public static DependencyProperty CountProperty = DependencyProperty.Register(
            "Count",
            typeof(int),
            typeof(IncreamentBehavior));
            
        public static DependencyProperty IncrementProperty = DependencyProperty.Register(
            "Increment",
            typeof(int),
            typeof(IncreamentBehavior));
        
        public int Count
        {
            get {return (int)GetValue(CountProperty);}
            set {SetValue(CountProperty, value);}
        }
        
        public int Increment
        {
            get {return (int)GetValue(IncrementProperty);}
            set {SetValue(IncrementProperty, value);}
        }
        
        void Invoke(object parameter)
        {
            Count += Increment;
        }
    }
    
    removed the Mouse_Down event handler to let the designer to choose which kinds of trigger event will trigger the TriggerAction
    
    use the new builded behavior from the asset page tab of blend, drag the behavior to the aim uielement, then there will be a trigger panel at the right of the designer to let designer to set which kinds of trigger event should be used to trigger the invoke method of IncreamentBehavior
    
    make sure the property with setter function binded with two way binding
    
- Targeted Trigger Actions, define reusable interaction between components, trigger from one component and invoke event from another
    + this pattern likes the message bus and selection model pattern
    + this pattern is only used for the component sites on the same view other wise use the message bus or selection model 
    
    add target trigger dependency property
    + example
    public class MultipleClickBehavior: TargetedTriggerAction <UIElement>
    {
        public static DependencyProperty CountProperty = DependencyProperty.Register(
            "Times",
            typeof(int),
            typeof(MultipleClickBehavior));
            
        public int Times
        {
            get {return (int)GetValue(TimesProperty);}
            set {SetValue(TimesProperty, value);}
        }
        
        protected override void Invoke(object parameter)
        {
            var button = Target as ButtonBase;
            if( button != null )
            {
                var command = button.Command;
                if( command != null && command.CanExecute(null) )
                {
                    for( int i = 0; i < Times; i ++ )
                    {
                        command.Execute(null);
                    }
                }
            }
        }
    }
    
    this pattern is used to make the designer have more control
    

# Animation Patterns
- surprise by application changes
- animation is used to digital object to operate like real object, 
reference plural sight courses creating user experiences Fundamental Design Principle
- separation
    + visual state manager
        * visual state binding
        * circular animations
        * control states
    + triggers
        * list animations
    + theme transitions

- visual state binding, view model is separate the state
    + separate state from presentation
    + xaml controls (code behind) <- visual states manager <- events transitions
    + in MVVM
    controls <-properties-> view model 
         ^                         ^
         |                         |
         visual states manager <- behavior
    
    + create a class Bind Visual State Behavior in Mvvm
    State Name, determine current state, binded to view model property
    the behavior set the visual state manager to new state
    
    Visual state manager <- Bind Visual State Behavior <- View Model
    the view model use the property and will be transfered to state name
    
    Visual State is a class of xaml to contain a set of uielement states
    
    + implement
        * create a visual state group from the blend top left panel
        * set the desire state for each control in the current view 
        change the right panel of the property of the control, use render transform to set animation
        * set default animation time for the state groups and turn on transition preview from the right top of the panel
        * change easing function by the button at right of each state to define the animation function 
        
        * the view model should define a enum type or somethong to map to the visual states
        
        * create BindingVisualStateBehavior inherite from the Blend Behavior which define a dependency class called state name to save which state will be transformed to. 
        add state name property changed handler to update the visual state
    
        just drag and drop the behavior to any control of the view to assign behavior, by default the behavior will bind to the top container
        
        after compile the behavior will display at the top left corner of the asset tab
        
        implemented codes
        public class BindVisualStateBehavior : Behavior<FrameworkElement>
        {
            public static DependencyProperty StateNameProperty = DependencyProperty(
                "StateName",
                typeof(string),
                typeof(BindVisualStateBehavior),
                new PropertyMetadata(StateNamePropertyChanged));
                
            public string StateName
            {
                get {return (string)GetValue(StateNameProperty);}
                set {SetValue(StateNameProperty);}
            }
            
            //set parameter use transitions to true to use the animation
            private static void StateNamePropertyChanged(DependencyObject obj, object args)
            {
                ((BindVisualStateBehavior)obj).UpdateVisualState(
                    (string)args.NewValue,
                    useTransitions:true);
            }
            
            //when the uielement initialized should prevent animation
            protected override void OnAttached()
            {
                ((BindVisualStateBehavior)obj).UpdateVisualState(
                    StateName,
                    useTransitions:false);
                base.OnAttached();
            }
            
            private void UpdateVIsualState(
                string visualState,
                bool useTransitions)
            {
                if(AssociatedObject != null)
                {
                    FrameworkElement stateTarget;
                    if(VisualStateUtilities.TryFindNearestStatefulControl(AssociatedObject, out stateTarget))
                    {
                        VisualStateUtitlies.GotToState(
                            stateTarget,
                            visualState,
                            useTransitions);
                    }
                }
            }
        }
    
        bind the state name of the BindVisualStateBehavior to the view model's property which define the current state
   
- Circular Animations, set and wrap around simply 
    + automatic create states and wrap end to start
    + use the tail state just like the start state and reset the visual state 
    + for example create a compass in blend
        * create several states
        * create start end state transformation from click add transform button at the right side of the state bar. the button with a arrow and plus symbol
        * specify transform parameter from the panel
    
- Control States, customize the feedback to the user
    + silverlight control states, visual state manager is used to manage control state, the default template are
        * common states
        normal, mouse over, disabled, read only
        
        * focus states
        unfocused, focused
        
        * validation states
        valid, invalid unfocused, invalid focused
        
    + the template could be overwrite, each visual state group could have his home current state
    
    + button visual state groups
    common state + focus states  
    
    + the states are several layers above the real control, when trigger a state the relative layer is show and the other is hidden
    
    + edit the template with blend and create a template will overwrite the default states group
    each state control the button template's state layer
    
- List item animations
    + rounded event is bubbles ups along the visual tree
    
    + animation is used to inform the user where and how the UI changes
    
    + edit the listbox style and select edit additional templates (on the top of the window)| edit generated item container, edit create a copy(will copy the default list style)
    
    add a trigger from the left top panel
    select the trigger event
    add a story board, change the time line and adjust the state, and play the animation
    
    + example
    add load animation and unload animation(the unload animation is hard to add animation, because the relative item is removed from immediately)
    
- Theme transition, theme animation, window 8 theme transitions, mechanism for manage animation
    + EntranceThemeTransisiton
        * fly in from the right
        * individual component
        transitions
        * container
        childrenTranstions for the children
        isStaggeringEnable, cause a slight delay for the children
        manually apply to nested containers, otherwise the container will animated in but the children will directly in
        
    + AddDeleteThemeTransition
        * moves items out of the way when new item added
        * handles exit animation
        * automatically applied to listView controls
    
    + example add transitions for the containers, search the property with key word transitions, will list all supported transitions
    list box need to add addDeleteThemeTransition
    listview is a new control of windows 8 which automatic added AddDeleteThemeTransition

    
    
    
    
    
    
    
    