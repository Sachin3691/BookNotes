设计模式解析

2016/1/17
14:40

Author=Alan Shallowway James R.Thrott 

#面向对象开发简介
#UML
-类图
-交互图

# 标准的面向对象解决方案

#设计模式
-观察解决问题的不同结构，可以缩小关注的范围，从而看清优秀设计之间的相似之处。这中相似之处称之为模式
每个模式都是在我们环境中不断出现的问题，并叙述了这个解决方案的要素，可以被反复的应用

# Façade
-为子系统提供一个统一接口,Facade定义了一个更高层次的接口
意图，希望简化原有系统的使用方式
Facade简化了所有子系统的使用过程，但是Facade并不完成客户可能不能使用某些原有的功能
实现，定义多个新类，让新类使用原有接口

#Adaptor
-定义，将一个类的接口转换为客户希望的另一个接口
-特征
意图，使控制范围外的一个原有对象与某个接口匹配
问题，系统的数据和行为都正确，但是接口不符合
解决，Adapter提供了具有需要接口的包装类
Adapter 继承自客户希望的接口并使用了现有类来实现


#开拓视野
-敏捷编程
无冗余
可读
可测试

内聚，代码只负责一项责任
松耦合
可读性
封装性好

#Strategy
-定义，定义一个算法，将其封装起来，并使它们可以相互替换
-特征
意图，根据上下文使用不同的业务规则或算法
解决方案，将实现与算法请求分离，允许根据上下文进行选择
选择由client承担并传递给strategy的context对象

#Bridge模式
-定义，将抽象与实现结构，使得他们都可以独立的变化
-特征
意图，将一组实现与另一组使用它们的对象分离
问题，一个抽象的派生类必须使用多个实现，但不能出现类数量爆炸性增长
实现，将实现分装在一个抽象类中，要在抽象类的基类中包含一个实现的句柄
-模式并不完美，但是通常优于在有限时间内给出的解决方案

#Abstract Factory模式
-定义，为了创建一组相关或相互依赖对象提供一个接口，而且无需指定他们的具体类，是为了根据不同上下文来调用不同的对象
常讲adapter模式和abstract factory模式组合使用
-特征
意图，需要为特定的用户提供对象组
解决方案，协调对象组的创建，提供一种方式将如何执行对象实力化的规则同使用对象的客户对象提取出来
参与与协作者，AbstractFactory和ConcreteFactory

#decorator 模式
-动态的给一个对象添加额外的职责，就添加功能来说，decorator模式比生成子类更灵活
-特征
意图，动态的给对象添加职责
解决方案，无需扩展子类，而扩展对象增加功能
效果，添加的功能放在小的对象中，好处在ConcreteComponent后动态加载，在装饰器类中奖对象新功能的调用放在对象调用之前或之后以获得正确的顺序

#Observer模式
-定义，对象间的一种一对多的依赖关系，当一个对象的状态发生改变时所有依赖于它的对象都将得到通知并自动更新
通常含有的方法
Attach(observer)
Detach(observer)

目标Subject将实现一个notify方法来便利所有observer

Observer定义update方法
-特征
意图，对象之间定义一种一对多的依赖关系，这样当一个对象的状态变化的时候，所有依赖者都将得到通知并自动更新


#Template Method模式
-定义，在帮助我们在抽象层从一组不同的步骤概括出一个通用的过程模式，定义一个操作中算法的骨架，而将但是一些步骤延迟到子类中不改变算法的结构二重新定义它的步骤
-特征
意图，定义一个操作中算法的骨架，将yi xie bu zhouyixiebuzhou 推迟到子类中实现。可以不改变算法的结构二重新定义该算法的步骤
解决方案，可以定义可变的子步骤
实现，在抽象类中定义template method和需要的接口函数，在具体实现类中实现接口函数的细节

#Factory methods 
-Singleton and double check locking 
定义，保证一个类只有一个实例
-特征
意图，希望一个类只有一个实例，没有控制对象实力化的全局对象，确保所有其他对象引用唯一的实例

-Object Pool
意图，创建对象的过程比较昂贵，或者对特定类型能够创建的对象数目有限时，管理对象的重用

-Factory method
定义，一个用于创建对象的接口，让子类决定实力化那个类，使得实力化延迟到子类
例如Iterator, IEnumerable接口就是工厂方法，C++中的begin，end
-意图，定义一个用语创建对象的接口，让子类决定实例化那一个类
实现，抽象类中使用抽象方法，来实例化对象，实际中抽象类并不知道实际使用的具体对象
