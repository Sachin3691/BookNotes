Enterprise library validation application block=Jhon Sonmez;Note=Erxin

# introduction
- validation block
- validation components
	+ validator
	+ rule
	+ result
- validation workflow
	+ rulesets
	annotations, configuration, programmatic
	+ validation factory
	+ validator
	+ results
	message, key target tag
- validators
	+ kinds
	values, types, composite, single member
- what can you validate	
	+ field
	+ property
	+ method with no parameters
	+ class
	+ wcf parameter
	+ intercepted method parameters
- configuration
	+ get the package by nuget
	+ add application configuration file
	+ use the enterprise configuration tool to configure the validation configuration
		* pick clr types
		* select from file support custom class
		* operation
		add type
		add rule set
		add fields, methods, composite validator...
		add validators

# simple validation
- setup 
var container = new UnityContainer();
container.AddNewExtension<EnterpriseLibraryCoreExtension>();
var factory = container.Resolve<ValidatorFactory>();
var personValidator = facotory.CreateValidator<Person>();
var person = new Person();
var results = personValidator.Validate(person);
if(!result.IsValid)
{
	foreach(var r in results)
	{
		console.WriteLine(validation.Message);
	}
}
- data annotations
public class Person
{	
	[NotNullValidator(<plenty of choices such as Negate, ruleset, tag>)]
	[StringLengthValidator(2, RangeBoundaryType.Inclusive, 50, RangeBoundaryType.Inclusive, MessageTemplate="String length check")]
	public string FirstName;
	[NotNullValidator(MessageTemplate="Last name can't be null!")]
	public string LastName;
	[RangeValidator(1, RangeBoundaryType.Inclusive, 120)]
	public int Age;
}
- configuration based, change the validation block into configuration file could make the class code simple and change the validation logic without recompile the code
- format message, the message and detail specification could be found from msdn, such as {1} is the property name at string length property validator
- collection validation, some times class may contain other class need to be validate, collection validation is fit for nested class
	+ support add validator in annotation or configure file
	+ add object collection validator for planet class witch contain the validated class person
	public class Planet
	{
		[ObjectCollectionValidator(typeof(Person))]
		public List<Person> People {get; set;}
	}
	+ use the validator 
	var planet = new Planet();
	planet.People = new List<Person>
							{
								new Person<Age = 10},
								new Person();
								new Person{FirstName = "Joe", LastName = "Developer"}
							};
	var planetValidator = factory.CreateValidator<Planet>();
	var result = planetValidator.Validator(planet);
- composite validator
	+ some thing need to combine together to determine a instance is validate or not
	+ add composite validator
	+ composite validator support to add other kinds of validator into it
		* domain validator could check a value is it in a set
	+ composite operations
		* and, is default
- nested results
	+ validationresult.NestedValidationResults.Count > 0, then it means there are some other nested in class message
- self validation, manually add validation method into a custom class, the method will be automatic called during the instance of the class validation
[HasSelfValidation]
public class Person
{
	[SelfValidation]
	public void Valide(ValidationResults result)
	{
		if(Age * Age > 10)
		{
			result.AddResult(new ValidationResult(...));
		}
	}
}

# advanced validation
- data annotations, in .net framework there is a component model of data annotation
System.ComponentModel.DataAnnotations
there are several attribute to help validate data,  but there are several difference between enterprise validation block, it doesn't support combine validate attribute
[StringLength(500, ErrorMessage="String was too short", MinimumLength=5)]
public string FirstName {get; set;}
the enterprise validate library could use this attribute to help validate, the use is same as other validator
- metadata classes, is used to contain the validate information for the classes which are generated by some tools which is not easy to add validate annotations
[MetadataType(typeof(PersonMeta))]
public class Person
{
	public string FirstName {get; set;}
}
public class PersonMeta
{
	[StringLengthValidator(5, 500, MessageTemplate="string was ..")]
	public string FirstName {get; set;}
}
the metadata class also support partial class, could add the attribute to the parial class and then keep the auto generated class file clean
public partial class Person
{
	public string FirstName {get; set;}
}
[MetadataType(typeof(PersonMeta))]
public partial class Person
{
}
- using rulesets, ruleset could be inject by the class constructor
	+ adding ruleset
	[StringLengthValidator(5, 500, MessageTemplate="string was ..", ruleset="A")]
	[StringLengthValidator(5, 500, MessageTemplate="string was ..", ruleset="B")]
	public string FirstName {get; set;}
	+ using ruleset
	var planetValidator = factory.CreateValidator<Planet>(["A"|"B"]);
- changing factories, there are several kinds of validator factory which will load the validate information from the specify location
var factory = container.Resolve<ValidatorFactory>();
	+ Validator Factory, will load all the validate information from the configuration file, data annotation and system component model validation
	+ AttributeValidatorFactory, will load the data annotation
	+ ConfigurationValidatorFactory, will only load the configuration validate information
	+ ValidationAttributeValidatorFactory, will only load the system component model validate attribute setting
- individual validators, create a isolate validator and use it to validate other class
var strValidator = new StringLengthValidator(5, 10);
strValidator.MessageTemplate = "string was invalid";
var ret = strValidator.Validate("Hi");
- value validator, property validator
var propertyValidator = new PropertyValueValidator<Person>("AimPropertyName", someValidatorInstance);
var ret = propertyValidator.Validate(someClassInstance);
the property validator will automatic find the property name and use the validator instance to check the property value
- WCF validations, the validation block also could be used with asp.net, wpf, but the frameworks are all contain some built-in validation class which is a little adapter.	
	+ use the nuget package to add the validation block into wcf
	+ add wcf validation block 
	+ add validation behaviour to service contract
	+ add the validator to the input value
	[ServiceContract]
	[ValidationBehavior]
	public interface ITestService
	{
		[OperationContract]
		[FaultContract(typeof(ValidationFault))]
		string GetData(
			[DomainValidator("Value not in range", new []{50, 100})]
			int value
		);
	}
	+ add endpoint behavior to enable validation in the service web.config
	<system.serviceModel>
		<behaviors>
			<serviceBehaviors>
			</serviceBehaviors>
			<endpointBehaviors>
				<behavior name="ValidationBehavior">
					<validation enable="true" ruleset="MyRuleset"/>
				</behavior>
			</endpointBehaviors>
		</behaviors>
		<extensions>
			<behaviorExtensions>
				<add name="validation" type="Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.Validation"/>
			</behaviorExtensions>
		</extensions>
		<services>
			<service name="WcfValidationDemo.TestService">
				<endpoint address="" behaviorConfiguration="ValidationBehavior" binding="wsHttpBinding" contract="WcfValidationDemo.ITestService">
					<identity>
						<dns value="localhost"/>
					</identity>
				</endpoint>
			</service>
		</services>
	</system.serviceModel>
- Custom Validators, create a class and inherit from validation such as ValueValidatorAttribute
public class AppCapsValidatorAttribute:ValueValidatorAttribute
{
	protected override Validator DoCreateValidator(Type TargetType)
	{
		return new AllCapValidator("...", "");
	}
}
public class AllCapValidator:Validator<String>
{
	public AllCapValidator(string messageTemplate, string tag):base(messageTemplate, tag)
	{
	}
	
	protected override string DefaultMessageTemplate
	{
		get {return "NOT ALL CAPS";}
	}
	
	protected override void DoValidate(string objectToValidate, object currentTarget, string key, ValidationResult validationResult)
	{
		if(objectToValidate.ToUpper()!=objectToValidate)
		{
			validationResults.AddResult(new ValidationResult(MessageTemplate, currentTarget, key, Tag, this));
		}
	}
}
//use the validator
[AllCapValidator(MessageTemplate="First name was not all up letters")]
public object FirstName {get; set;}






