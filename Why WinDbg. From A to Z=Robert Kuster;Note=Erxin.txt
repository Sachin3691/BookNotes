Why WinDbg. From A to Z=Robert Kuster;Note=Erxin

# Why windbg?
- used by window product team 
- much more powerfull than VS debugger 
- extensible through extension dlls 
- its debug engine is part of the window OS 
- windbg learning curve is very steep 
- contents 
    + using windbg 
    + global flags 
    + application verifier 
    + process dumps 
    
- debugging tools for window xp 
    + reference the dbgeng.dll 
windbg.exe 
ntsd.exe 
cdb.exe 
kd.exe 
dbgsrv.exe 
userdump.exe 
drwtsn32.exe 

    + dbghelp.dll included starting with win 2000
livekd.exe 
OlyDbg.exe 
ProcessExplorer.exe 
...

dbghelp.dll contain support process dumping, obtaining stack traces, symbol handling, obtaining info about executable images 

- dbghelp!ImageNtHeader vs imagehlp!ImageNtHeader 
$ uf dbgHelp!ImageNtHeader 

- ImageHlp Dependencies 
- Debugger Engine API: dbgeng.dll 
documented in windbg's documentation 

check dependency for DbgEng 

- debug symbols 
executable are just sequences of raw bytes 
symbols help the debugger to 
    + map raw addresses in the executable to source-code lines 
    + analyze internal layout and data of applications 
    + program database -> pdb files 
    the newest microsoft debug information format 
    pdb's are stored in a file separately from 
    there are special APIs to work with it DbgHelp.dll and MsDiaXY.dll 
- kinds of debug information 
public functions and variables, across several compilation units(source files)
FPO information, additional information needed for retrieving stack-frames when compiling with FPO optimiztion 
private functions and variables
souce file and line information 
type information 

public symbols for MS modules (kernel32.dll, user32.dll, ..) are always stripped 

- generating debug infromation 
    + build process 
    compiler, generates machine instructions stored into .OBJ files 
    liner, combines all available .OBJ and .LIB files into the final executable 
    
    + for debug information we also need two steps 
    compiler generates debug information for every source file 
    linker, combines available debug information into the final ste of debug information for the executable 
    
    compiler options: /Z7, /Zi, /ZI 
    linker options, /debug, /pdb, /pdbstripped 
    
- machine debug information 
    + signature stored into executable and PDB file during build 
    + for a debugger match this signature must be the same 
    + algorithm to search PDB files 
    try module EXE or DLL folder 
    try name and path specified in the PE file 
    try environment variables, _NT_SYMBOL_PATH, _NT_ALT_SYMBOL_PATH 
- call stack 
    + without valid symbols 
002df550 MFC80UD!AfxDlgProc+0x3e
002df57c USER32!InternalCallWinProc+0x28
002df5f8 USER32!UserCallDlgProcCheckWow+0x102
002df648 USER32!DefDlgProcWorker+0xb2
002df668 USER32!DefDlgProcW+0x29
002df694 USER32!InternalCallWinProc+0x28
002df70c USER32!UserCallWinProcCheckWow+0x16a
...
    + with valid symbols 
002df350 ntdll!DbgBreakPoint
002df43c TestApplication!CMyDlg::PreInit+0x3b [MyDlg.cpp @ 75]
002df544 TestApplication!CMyDlg::OnInitDialog+0x52 [MyDlg.cpp @ 91]
002df550 MFC80UD!AfxDlgProc+0x3e
002df57c USER32!InternalCallWinProc+0x28
002df5f8 USER32!UserCallDlgProcCheckWow+0x102
...

- invasive noninvasive debugging and attaching 
    + invasive attach 
    DebugActiveProcess is called 
    break-in thread is created 
    prior to window xp, target application is killed on debugger exit or detach 
    there can be only one invasive debugger attached to a process at any time 
    
    + noninvasive attach 
    OpenProcess is called 
    no break-in thread i created 
    we don't attach to the processes as a debugger 
    all threads of the traget application are frozen 
    can change and examine memory 
    cannot set breakpoint 
    cannot step through the application 
    can attach several noninvasive debuggers to a process(+ one invasive debugger )
        * target application is attached by VS then we could still attach noninvasive debugger 
        * the target application is completely frozen and cannot lauch the break-in thread necessary for a true attach 
        
- exceptions 
    + a system mechanism that isn't language specific 
    + exceptions are made accessible through language extensions 
    + don't use try-catch-except for condition checking in time critical parts of your application. for every exceptions the system creates an exception record, searches for frame based exception handlers(catch-except) through all stack frames in reverse order, and finally continues with program execution. 
    
- exception dispatching 
exception dispatcher|=> debugger first chance 
                                    |=> frame-based handlers (__try, __except) =not handlered?
                                    |                                                                                  |
                                    |                                                                                  V 
                                    |                                                                                  UnhandledExceptionFilter 
                                    |                                                                                  |
                                    |                                                                                  V
                                    |                                                                                  Debugger present?
                                    |                                                                                  |
                                    |                                                                    +--Yes--+--No--> postmortem debugger 
                                    |                                                                    |                                             |
                                    |                                                                    V                                            V
                                    |                                                                   RaiseException(second chance) 
                                    |=> Debugger (second chance) 
                                    
the postmortem debugger is the AeDebug

- Exception Dispatching and SetUnhandleExceptionFilter 

    
    
    
    
    
    
    
    
    
    
    
    
    


