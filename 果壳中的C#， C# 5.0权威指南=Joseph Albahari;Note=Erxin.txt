果壳中的C#， C# 5.0权威指南=Joseph Albahari;Note=Erxin

# C# 语言基础
- 外部命名空间
extern alias W1;

class Test
{
    W1.Widgets.Widget w1;
}

使用全局命名空间关键字global指定

# C# 中创建类
- get和set权限访问器
public class Foo
{
    public decimal x
    {
        get { return x;}
        private set 
        {
            x = value;
        }
    }
}

CLR内部实现中实际编译为 public int get get_XXX和set_XXX的方法

- 索引器
class Sentence
{
    string[] words = "the quick brown fox".Split();
    public string this [int wordNum]
    {
        get {return words[wordNum];}
        set {words[wordNum] = value;}
    }
}

var s = new Sentence();
s[3] = "x";

一个索引器可以有多个参数

CLR内部实现索引器的时候实际命名为get_Item和set_Item方法

- 类对象继承的转换使用as操作符，出错误异常但返回null
- is操作符检测一个对象是否为制定类的派生对象
- 隐藏继承的类父类成员使用new关键字
public class A {public int counter;}
public class B:A {public new int counter;}

- sealed 
- base 引用基类实现
- GetType and typeof operator to get the type which are in the System.Type namespace 
- 结构体和类相似，不同之处
值类型
不支持继承

结构体可以包含类的所有成员
无参数的构造方法
析构函数
虚成员
不能在结构体定义时初始化字段

- 友元程序集，System.Runtime.CompilerServices.InternalsVisibleTo属性可以把internal成员提供给其他友元程序集

[assembly:InternalsVisibleTo("Friend")]

可以使用强命名程序集名

- 虚方法实现接口成员，默认情况下接口成员是隐式定义为sealed的，需要使用virtual关键字

- 结构体转换成接口会触发装箱操作，调用结构体的隐式实现接口成员不会引发装箱

- 类与接口
    + 当可以自然的共享实现的时候使用类和子类
    +　当实现是独立的时候使用接口
－　标志枚举
[Flags]
public enum BorderSide
{
    left = 0,
    right = 2, 
    top = 4, 
    bottom = 8
}

- 泛化，C#中的模板
class Foo<T>
{
}

- 无绑定泛型
Type a = typeof(A<>);
Type a2 = typeof(A<,>);

- 调用泛型默认值
default(T)

- 自引用泛型， 用于关闭类型参数
public interface IEqutable<T> {bool Equals(T obj);}

public class Ballon:IEqutable<Ballon>
{
    ...
}

- 协变， 假定S是B的子类，如果X<S>允许转化成X<B>,那么称为协变类
协变例子
IFoo<string> b = ...;
IFoo<object> s = b; 

泛化接口支持协变， 但泛化类不支持，数组也支持， 使用out修饰符表示泛化支持协变
public interface IPoppable<out T>{ T pop();}

- 逆变是协变的反向关系使用in来修饰
- C#泛化与C++模板的区别，C#泛化可以被编译到程序库中dll而C++是在编译时进行的，所以C#可以使用dll泛型而C++不能 

# C#高级特性
- 委托delegate,函数指针,将调用者和目标方法关联起来
delegate type foo(...);

- 委托支持多播 +=, -=
- Func和Action委托，委托中的泛型方法
- C#5.0中加入了委托参数的协变与逆变，同样适用out，in关键字
- 事件，是封装的委托隐藏了实际的委托对象
public delegate void PriceChangeHandler();

public class Broadcaster
{
    public event PriceChangeHandler PriceChangedEvent; 
}

事件访问其add remove方法

- lambda表达式，匿名方法
delegate(x){}

- try catch finally 
throw;
throw ex;
区别是throw ex会改变异常生成的call stack 

- 迭代器
yield return value;

yield break; //表示不返回后面的元素而提前结束

- 可空类型
type? name;

Nullable<T>

允许使用as操作符对可空对象拆箱

- 运算符提升，对于可空类型的变量直接使用在关系运算符时会自动提升运算符

- 运算符重载
    + 可以重载的
    +, -, !, ~ ++ -- * / % & | ^ << >> == != > < >= <= 
    
    implicit, explicit 
    
    true, false 
    
    + 间接重载
    复合赋值， 通过重载+，= 
    条件运算符， && || 可以通过重载为运算符& 和|
    
    + 运算符函数必须标记为static 和public
    
    public static Node operator +();
    
- 自定义隐式转换
    + 具有转换类型的参数构造函数
    + 便携ToXXX和FromXXX方法
    
- 扩展方法，允许对一个现有实现类型增加新的方法而不需要修改原始类型, 定义在静态类型和静态方法中
public static class StringHelper{
    pubilc bool IsCapitalized(this string s){
    }
}

任何兼容的实力方法总是优先于定义的扩展方法

- 匿名类型
new {prop=1, prop1=2};

可以创建匿名类型数组

- 动态绑定，将解析类型和成员操作的过程延迟到运行时，特别用于实现.net的脚本语言如ironpython
dynamic d = GetSomeObject()
d.Quack();

如果一个动态对象实现了IDynamicMetaObjectProvider那么这个接口将用来执行绑定

- 自定义绑定 System.Dynamic






















