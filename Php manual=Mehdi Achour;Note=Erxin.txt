Php manual=Mehdi Achour;Note=Erxin

# Preface 

# introduction 
- what is php 
PHP (recursive acronym for PHP: Hypertext Preprocessor），can be embeded into html 

<?php
            echo "Hi, I'm a PHP script!";
?>

- what can php do? 
    + server side script 
    collect data, generate dynamic html, send receive cookies etc 
    
    + command line scripting, executed on *nix or linux, or task scheduler on windows 
    
    + writing desktop app, php gtk 
    
    + wide range of database support, PDO, ODBC, cURL, sockets
    http://php.net/manual/en/book.pdo.php
    http://php.net/manual/en/book.uodbc.php
    http://php.net/manual/en/book.curl.php
    http://php.net/manual/en/book.sockets.php
    
- php extension list 
http://php.net/manual/en/extensions.alphabetical.php

example, xdebug 
https://xdebug.org/

- HHVM
open source virtual machine designed for executing programs written in Hack and PHP. used just-in time compilation 
https://github.com/facebook/hhvm

- download window php interpretor 
http://windows.php.net/download


# Getting started 
- a simple tutorial 
    + check guest browser 
    $_SERVER['HTTP_USER_AGENT']
    
    + dealing with form 
    $_POST['name']
    $_GET superglobal instead
    You may also use the $_REQUEST superglobal contain the merged GET, POST and COOKIE data 
    
    + global variables 
     $_GET, $_POST, $_COOKIE, $_SERVER, $_FILES, $_ENV, $_REQUEST, and $_SESSION. 
     
apache 
php 
mysql 

reference, http://php.net/manual/en/install.php

reference wamp amp packages, https://en.wikipedia.org/wiki/List_of_Apache%E2%80%93MySQL%E2%80%93PHP_packages

- your first php enabled page 
phpinfo();

- predefined variables 
Superglobals — Superglobals are built-in variables that are always available in all scopes
$GLOBALS — References all variables available in global scope
$_SERVER — Server and execution environment information
$_GET — HTTP GET variables
$_POST — HTTP POST variables
$_FILES — HTTP File Upload variables
$_REQUEST — HTTP Request variables
$_SESSION — Session variables
$_ENV — Environment variables
$_COOKIE — HTTP Cookies
$php_errormsg — The previous error message
$HTTP_RAW_POST_DATA — Raw POST data
$http_response_header — HTTP response headers
$argc — The number of arguments passed to script
$argv — Array of arguments passed to script

- dealing with forms 
    + print variable from forms 
    <form action="action.php" method="post">
     <p>Your name: <input type="text" name="name" /></p>
     <p>Your age: <input type="text" name="age" /></p>
     <p><input type="submit" /></p>
    </form>
    
    
    Hi <?php echo htmlspecialchars($_POST['name']); ?>.
    You are <?php echo (int)$_POST['age']; ?> years old.

    htmlspecialchars() makes sure any characters that are special in html are properly encoded

    
# Installation and configuration 
- reference 
http://php.net/manual/en/install.php

different os 

    + installation on cloud 
    http://php.net/manual/en/install.cloud.azure.php
    http://php.net/manual/en/install.cloud.ec2.php
    
    + fastcgi process manager fpm 
    http://php.net/manual/en/install.fpm.php
    
    + install pecl extensions 
    http://php.net/manual/en/install.pecl.php
   
- runtime configuration 
    + the configuration file, The configuration file (php.ini) is read when PHP starts up.
        search order 
        * SAPI module specific location
        * registry, s of PHP 5.2.0, the location of the php.ini file can be set for different versions of PHP. The following registry keys are examined in order: [HKEY_LOCAL_MACHINE\SOFTWARE\PHP\x.y.z], [HKEY_LOCAL_MACHINE\SOFTWARE\PHP\x.y] and [HKEY_LOCAL_MACHINE\SOFTWARE\PHP\x]
        
        * [HKEY_LOCAL_MACHINE\SOFTWARE\PHP], value of IniFilePath (Windows only).
        * current working dir 
        * web server's directory for SAPI or directory of php 
        * window dir (c:\windows/winnt)
    + .user.ini files, In addition to the main php.ini file, PHP scans for INI files in each directory, starting with the directory of the requested PHP file, and working its way up to the current document root 
    
    + where a configuration setting may be set 
     For example, some settings may be set within a PHP script using ini_set()
     
     For example, the output_buffering setting is PHP_INI_PERDIR therefore it may not be set using ini_set(). However, the display_errors directive is PHP_INI_ALL therefore it may be set anywhere, including with ini_set().
     
     PHP_INI_USER	Entry can be set in user scripts (like with ini_set()) or in the Windows registry. Since PHP 5.3, entry can be set in .user.ini
    PHP_INI_PERDIR	Entry can be set in php.ini, .htaccess, httpd.conf or .user.ini (since PHP 5.3)
    PHP_INI_SYSTEM	Entry can be set in php.ini or httpd.conf
    PHP_INI_ALL	Entry can be set anywhere
    
    + how to change configuration settings 
    When using PHP as an Apache module, you can also change the configuration settings using directives in Apache configuration files (e.g. httpd.conf) and .htaccess files.You will need "AllowOverride Options" or "AllowOverride All" privileges to do so.

    For a listing of which directives are PHP_INI_ALL, PHP_INI_PERDIR, or PHP_INI_SYSTEM, have a look at the List of php.ini directives appendix
    
    + changing php configuration via windows registry 
    When running PHP on Windows, the configuration values can be modified on a per-directory basis using the Windows registry. The configuration values are stored in the registry key HKLM\SOFTWARE\PHP\Per Directory Values, in the sub-keys corresponding to the path names. 
    
- install php on window 
    + reference 
    http://php.net/manual/en/install.windows.php
    + requirements 
    php 7.0+, crt 14  https://www.microsoft.com/en-us/download/details.aspx?id=48145
    
    + pecl extensions are pre-built for windows and available from 
    http://windows.php.net/downloads/pecl/releases/
    
    + php installer tools on windows 
    Microsoft's Web Platform Installer (WebPI).
    XAMPP
    WAMPP
    bitnami, https://bitnami.com/stack/wamp
    
    + recommended configuration 
    Opcache, compiles and optimizes php scripts and caches them in memory 
        * in php.ini 
        zend_extension=php_opcache.dll
        opcache.enable=On
        opcache.cli_enable=On
    
        * WinCache for iis . especially if in a shared whosting environment or using networked file storage(NAS)
        http://pecl.php.net/package/WinCache, download and copy to php extension dir 
        
        setting in php.ini 
        extension=php_wincache.dll
        wincache.fcenabled=1
        wincache.ocenabled=1

        * IIS configuration 
        In IIS Manager, Install FastCGI module and add a handler mapping for `.php` to the path to PHP-CGI.exe
        
        use the APPCMD command line tool to script IIS configuration
        
        * database 
        PHP includes mysqli and pdo_mysql extensions.
        mysql https://dev.mysql.com/downloads/windows/
        
    + manual php installation on windows 
        * reference 
        http://php.net/manual/en/install.windows.manual.php
        http://php.net/manual/en/install.windows.legacy.index.php#install.windows.legacy.iis7
        * choose web server 
        iis, add server role 
        
        * command line to configure iis and php 
        @echo off

        REM download .ZIP file of PHP build from http://windows.php.net/downloads/
        REM
        REM path to directory you decompressed PHP .ZIP file into
        set phpdir=c:\php
        set phppath=php-5.6.19-nts-Win32-VC11-x86

        REM Clear current PHP handlers
        %windir%\system32\inetsrv\appcmd clear config /section:system.webServer/fastCGI
        %windir%\system32\inetsrv\appcmd set config /section:system.webServer/handlers /-[name='PHP_via_FastCGI']

        REM Set up the PHP handler
        %windir%\system32\inetsrv\appcmd set config /section:system.webServer/fastCGI /+[fullPath='%phpdir%\%phppath%\php-cgi.exe']
        %windir%\system32\inetsrv\appcmd set config /section:system.webServer/handlers /+[name='PHP_via_FastCGI',path='*.php',verb='*',modules='FastCgiModule',scriptProcessor='%phpdir%\%phppath%\php-cgi.exe',resourceType='Unspecified']
        %windir%\system32\inetsrv\appcmd set config /section:system.webServer/handlers /accessPolicy:Read,Script

        REM Configure FastCGI Variables
        %windir%\system32\inetsrv\appcmd set config -section:system.webServer/fastCgi /[fullPath='%phpdir%\%phppath%\php-cgi.exe'].instanceMaxRequests:10000
        %windir%\system32\inetsrv\appcmd.exe set config -section:system.webServer/fastCgi /+"[fullPath='%phpdir%\%phppath%\php-cgi.exe'].environmentVariables.[name='PHP_FCGI_MAX_REQUESTS',value='10000']"
        %windir%\system32\inetsrv\appcmd.exe set config -section:system.webServer/fastCgi /+"[fullPath='%phpdir%\%phppath%\php-cgi.exe'].environmentVariables.[name='PHPRC',value='%phpdir%\%phppath%\php.ini']"
        
        * configuration for iis 7.0 and later
        window server 2008 r2+ http://php.net/manual/en/install.windows.legacy.index.php#install.windows.legacy.iis7
        
        enable fastCGI support in IIS 
            start menu -> run -> CompMgmtLauncher 
            add role iis and enable CGI 
            
        configure iis to process php requests 
            download php http://windows.php.net/download/
            Thread-Safe(TS) - use for single process web serves, like Apache with mod_php

            Non-Thread-Safe(NTS) - use for IIS and other FastCGI web servers (Apache with mod_fastcgi) and recommended for command-line scripts

            x86 - production use of PHP 5.5 or 5.6 or 7.0.

            x64 - production use of PHP 7.0+ unless its a 32-bit only version of Windows. 5.5 and 5.6 x64 are expiremental.
            
            configure php.ini 
            fastcgi.impersonate = 1
            fastcgi.logging = 0
            cgi.fix_pathinfo=1
            cgi.force_redirect = 0
            
            configure iis manager user interface to create a handler mapping for php 
            run -> inetmgr 
            select server node in connections tree 
            feature view page open the handler mappings feature 
            actions pane click "add module mapping..."
            add module mapping dialog enter the following 
                request path: *.php 
                module: FastCgiModule 
                executable: c:\[path to php installation]\php-cgi.exe 
                name: PHP_via_FastCGI
            click request restrictions button and then configure the mapping to invoke handler only if request is mapped to a file or a folder 
            
            configure iis with command for handler mapping for php 
            %windir%\system32\inetsrv\appcmd set config /section:system.webServer/fastCGI ^/+[fullPath='c:\PHP\php-cgi.exe']
            
            createting handler mapping for php request 
            %windir%\system32\inetsrv\appcmd set config /section:system.webServer/handlers ^
            /+[name='PHP_via_FastCGI', path='*.php',verb='*',modules='FastCgiModule',^
            scriptProcessor='c:\PHP\php-cgi.exe',resourceType='Either']
            
        impersonation and file system access 
        
- install php on azure app services 
http://php.net/manual/en/install.cloud.azure.php

- install on old window 98 etc 
http://php.net/manual/en/install.windows.legacy.index.php#install.windows.legacy.commandline

- install php with webinstaller 
    + install microsoft web platform installer 
    + search php 
    + install php 
    + install php manager 
    + install database 
    mysql, etc 
    
- install FastCGI process manager(FPM), FPM (FastCGI Process Manager) is an alternative PHP FastCGI implementation with some additional features (mostly) useful for heavy-loaded sites.

    + advanced process managemement with graceful stop/start 
    + start works with different uid/gid/chroot/environment 
    + stdout and stderr 
    + emergency restart in case of accidental opcode cache destruction 
    + accelerated upload support 
    + 'slowlog' - logging scripts 
    + fastcgi_finish_request() special function 
    + dynamic/static child spawning 
    + basic SAPI status informa similar to apache mode_status 
    + php.ini based config file 
    
- instruction to PECL installations,    PECL is a repository of php extensions, http://pecl.php.net/, via the pear packaging system, http://pear.php.net/

    + pear command, http://pear.php.net/manual/en/guide.users.commandline.cli.php
    
    + load the extension by add extension directory in php.ini file through the dl() function 
    
    + check more detail from the help to install a php extension 
    on window we could use php manager from the IIS manager page to control the php extensions 
    
- anonymous git instructions http://www.php.net/git.php
- runtime configuration 
    + the configuration file (php.ini), is searched for locations 
    SAPI module specific location (phpIniDir), PHP_INI_PATH environment variable 
    as php5.2.0 the location of the php.ini file can be set for different versions of PHP, [HKEY_LOCAL_MACHINE\SOFTWARE\PHP\x.y.z], [HKEY_LOCAL_MACHINE\SOFTWARE\PHP\x.y] and [HKEY_LOCAL_MACHINE\SOFTWARE\PHP\x
    Current working dir 
    Web server's directory (SAPI modules) or directory of php in windows 
    Window directory (c:\windows or c:\winnt) or --with-config-file-path compile time option
    
    + .user.ini files , 5.3.0 php support for configuration ini files on per-directory basis
        PHP_INI_PERDIR and PHP_INI_USER will be recognized in .user.ini-style INI files
        
        two new ini directives user_ini.filename and user_ini.cache_ttl control 
        
    + where a configuration setting may be set using ini_set() 
    
    + who to change configuration settings 

    running php as an apache module, in apache configuration files (httpd.confg) and .htaccess files 
    PHP_INI_ALL, PHP_INI_PERDIR or PHP_INI_SYSTEM have a look at the list of php.ini directives appendix 
    
    php_value name value 
    Sets the value of the specified directive

    php_flag name on|off 
    Used to set a boolean configuration directive

    php_admin_value name value 
    Sets the value of the specified directive. 

    php_admin_flag name on|off 
    Used to set a boolean configuration directive. 

    + changing php configuration via the windows registry 
    configuration values for the directory c:\inetpub\wwwroot would be stored in the key HKLM\SOFTWARE\PHP\Per Directory Values\c\inetpub\wwwroot. 
    
    php constants in the values are not parsed, However, only configuration values changeable in PHP_INI_USER can be set this way, PHP_INI_PERDIR values can not. 
    
    
# Language reference 
## basic syntax 
- php tags 
<?php[whitespace] ... ?>

If a file is pure PHP code, it is preferable to omit the PHP closing tag at the end of the file. This prevents accidental whitespace or new lines being added after the PHP closing tag

- escaping from html 
Everything outside of a pair of opening and closing tags is ignored by the PHP parser which allows PHP files to have mixed content

    + advance escape 
<?php if ($expression == true): ?>
  This will show if the expression is true.
<?php else: ?>
  Otherwise this will show.
<?php endif; ?>

    + asp style tags are not recommanded 
 Two of these, <?php ?> and <script language="php"> </script>, are always available. There is also the short echo tag <?= ?>, which is always available in PHP 5.4.0 and later.

The other two are short tags and ASP style tags. As such, while some people find short tags and ASP style tags convenient

    + contrl the tag style in php.ini 
Short tags (example three) are only available when they are enabled via the short_open_tag php.ini
ASP style tags (example five) are only available when they are enabled via the asp_tags php.ini

- instruction separation

The closing tag of a block of PHP code automatically implies a semicolon; 

in some cases omitting it is helpful when using include or require, so unwanted whitespace will not occur at the end of files

- comments 
<?php
    echo 'This is a test'; // This is a one-line c++ style comment
    /* This is a multi line comment
       yet another line of comment */
    echo 'This is yet another test';
    echo 'One Final Test'; # This is a one-line shell-style comment
?>

- openining and closing tags, required short_open_tag in php.ini, --enable-short-tags options 
1.  <?php echo 'if you want to serve PHP code in XHTML or XML documents,
                use these tags'; ?>

2.  You can use the short echo tag to <?= 'print this string' ?>.
    It's always enabled in PHP 5.4.0 and later, and is equivalent to
    <?php echo 'print this string' ?>.

3.  <? echo 'this code is within short tags, but will only work '.
            'if short_open_tag is enabled'; ?>

4.  <script language="php">
        echo 'some editors (like FrontPage) don\'t
              like processing instructions within these tags';
    </script>
    This syntax is removed in PHP 7.0.0.

5.  <% echo 'You may optionally use ASP-style tags'; %>
    Code within these tags <%= $variable; %> is a shortcut for this code <% echo $variable; %>
    Both of these syntaxes are removed in PHP 7.0.0. 
    
- instruction separation, ; 

    

## Types 
- example 
<?php
$a_bool = TRUE;   // a boolean
$a_str  = "foo";  // a string
$a_str2 = 'foo';  // a string
$an_int = 12;     // an integer

echo gettype($a_bool); // prints out:  boolean
echo gettype($a_str);  // prints out:  string

// If this is an integer, increment it by four
if (is_int($an_int)) {
    $an_int += 4;
}

// If $a_bool is a string, print it out
// (does not print out anything)
if (is_string($a_bool)) {
    echo "String: $a_bool";
}
?>

- boolean 
$isTrue = True;

    + convert to boolean 
    To explicitly convert a value to boolean, use the (bool) or (boolean) casts. 
    
    + values are consider false 
the boolean FALSE itself
the integer 0 (zero)
the float 0.0 (zero)
the empty string, and the string "0"
an array with zero elements
the special type NULL (including unset variables)
SimpleXML objects created from empty tags    

    + value consider to true, 
   Every other value is considered TRUE (including any resource and NAN)
- integer  can be specified in decimal (base 10), hexadecimal (base 16 0x1234), octal (base 8, 0123) or binary (base 2 0b1234) notation, optionally preceded by a sign (- or +).

    + about two billion is the usual value (that's 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18, except on Windows prior to PHP 7, where it was always 32 bit. PHP does not support unsigned integers. Integer size can be determined using the constant PHP_INT_SIZE
    
    Prior to PHP 7, if an invalid digit was given in an octal integer (i.e. 8 or 9), the rest of the number was ignored
    
    + To explicitly convert a value to integer, use either the (int) or (integer) casts. However, in most cases the cast is not needed, since a value will be automatically converted if an operator, function or control structure requires an integer argument. intval()
    
    + If a resource is converted to an integer, then the result will be the unique resource number assigned to the resource by PHP at runtime
    
    If the float is beyond the boundaries of integer (usually +/- 2.15e+9 = 2^31 on 32-bit platforms and +/- 9.22e+18 = 2^63 on 64-bit platforms other than Windows), the result is undefined, 
    
Never cast an unknown fraction to integer, as this can sometimes lead to unexpected results.
<?php
echo (int) ( (0.1+0.7) * 10 ); // echoes 7!
?>

    + integer overflow, php encounters a number beyond the bounds of the integer type, it will be interpreted as a float instead 
    
- float aka double 
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;

    + compare float numbers 
    testing floating point values for equality is problematic, due to the way that they are represented internally. However, there are ways to make comparisons of floating point values that work around these limitations.
    
    $a and $b are equal to 5 digits of precision.
<?php
$a = 1.23456789;
$b = 1.23456780;
$epsilon = 0.00001;

if(abs($a-$b) < $epsilon) {
    echo "true";
}
?>
    
    + NaN, Some numeric operations can result in a value represented by the constant NAN. This result represents an undefined or unrepresentable value in floating-point calculations. 
    
    Any loose or strict comparisons of this value against any other value, including itself, but except TRUE, will have a result of FALSE.
    
    + floating point precision 
    This can lead to confusing results: for example, floor((0.1+0.7)*10) will usually return 7 instead of the expected 8,
    
    + reference 
    http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
- string 
    + php only support 256 character set 
    
    + syntax 
        * single quoted string, no furture interpretation 
        echo 'this is a string';
        
        // Outputs: You deleted C:\*.*?
        echo 'You deleted C:\\*.*?';

        // Outputs: You deleted C:\*.*?
        echo 'You deleted C:\*.*?';

        // Outputs: This will not expand: \n a newline
        echo 'This will not expand: \n a newline';

        // Outputs: Variables do not $expand $either
        echo 'Variables do not $expand $either';
        
        * double quoted string 
        php will interpret the following escape sequences for special characters, The most important feature of double-quoted strings is the fact that variable names will be expanded.
        \n	linefeed (LF or 0x0A (10) in ASCII)
        \r	carriage return (CR or 0x0D (13) in ASCII)
        \t	horizontal tab (HT or 0x09 (9) in ASCII)
        \v	vertical tab (VT or 0x0B (11) in ASCII) (since PHP 5.2.5)
        \e	escape (ESC or 0x1B (27) in ASCII) (since PHP 5.4.4)
        \f	form feed (FF or 0x0C (12) in ASCII) (since PHP 5.2.5)
        \\	backslash
        \$	dollar sign
        \"	double-quote
        \[0-7]{1,3}	the sequence of characters matching the regular expression is a character in octal notation, which silently overflows to fit in a byte (e.g. "\400" === "\000")
        \x[0-9A-Fa-f]{1,2}	the sequence of characters matching the regular expression is a character in hexadecimal notation
        \u{[0-9A-Fa-f]+}	the sequence of characters matching the regular expression is a Unicode codepoint, which will be output to the string as that codepoint's UTF-8 representation (added in PHP 7.0.0)      

        * A third way to delimit strings is the heredoc syntax: <<<. After this operator, an identifier is provided, then a newline. The string itself follows, and then the same identifier again to close the quotation.
        
<?php
class foo {
    public $bar = <<<"EOT" //optional close with double quote 
bar
    EOT;//error 
}
// Identifier must not be indented
?>

        * nowdoc the variable will not be interpret
        A nowdoc is identified with the same <<< sequence used for heredocs, but the identifier which follows is enclosed in single quotes, e.g. <<<'EOT'
<?php
$str = <<<'EOD'
Example of string
spanning multiple lines
using nowdoc syntax.
EOD;
        
    + variable parsing 
        * simple syntax, If a dollar sign ($) is encountered, the parser will greedily take as many tokens as possible to form a valid variable name.
        $variable_name 
        * complex syntax, curly syntax 
        ${variable_name}
        
        It is also possible to access class properties using variables within strings using this syntax.
        echo "{$foo->{$baz[1]}}\n";
        
         Functions, method calls, static class variables, and class constants inside {$} work since PHP 5. However, the value accessed will be interpreted as the name of a variable in the scope in which the string is defined. 
         class beers {
            const softdrink = 'rootbeer';
            public static $ale = 'ipa';
        }
        $rootbeer = 'A & W';
        $ipa = 'Alexander Keith\'s';
        // This works; outputs: I'd like an A & W
        echo "I'd like an {${beers::softdrink}}\n";
        // This works too; outputs: I'd like an Alexander Keith's
        echo "I'd like an {${beers::$ale}}\n";
    + negative number indices 
    <?php
    $string = 'string';
    echo "The character at index -2 is $string[-2].", PHP_EOL;
    $string[-3] = 'o';
    echo "Changing the character at index -3 to o gives $string.", PHP_EOL;
    ?> 
        
    + Accessing variables of other types (not including arrays or objects implementing the appropriate interfaces) using [] or {} silently returns NULL.
    
    + convert to string 
    value converted to a string using strval(). 
    
    a boolean TRUE is converted to string "1", false is "", which allowed convert back and forth 
    
    The decimal point character is defined in the script's locale (category LC_NUMERIC).
    
    Arrays are always converted to the string "Array"; because of this, echo and print can not by themselves show the contents of an array.
    
    in order to convert objects to string magic method __toString must be used
    
    NULL is always convert to an empty string 
         
    See the functions print_r() and var_dump() for more effective means of inspecting the contents of these types(array, object or resource)
    
    serialize php object to string by serialize() function 
    
    If the string does not contain any of the characters '.', 'e', or 'E' and the numeric value fits into integer type limits otherwise convert to float 
    
    If the string starts with valid numeric data, this will be the value used. Otherwise, the value will be 0 (zero).
    
    $foo = 1 + "10.5";                // $foo is float (11.5)
    $foo = 1 + "-1.3e3";              // $foo is float (-1299)
    $foo = 1 + "bob-1.3e3";           // $foo is integer (1)
    $foo = 1 + "bob3";                // $foo is integer (1)
    $foo = 1 + "10 Small Pigs";       // $foo is integer (11)
    $foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
    $foo = "10.0 pigs " + 1;          // $foo is float (11)
    $foo = "10.0 pigs " + 1.0;        // $foo is float (11) 
    
    Use the ord() and chr() functions to convert between ASCII codes and characters.
    
    + details of the string type 
    The string in PHP is implemented as an array of bytes such as network socket – will still return strings.
    
    string will be encoded in whatever fashion it is encoded in the script file. 
        * Some functions assume that the string is encoded in some (any) single-byte encoding, but they do not need to interpret those bytes as specific characters. 
        * Other functions are passed the encoding of the string, possibly they also assume a default
        * Others use the current locale (see setlocale()), but operate byte-by-byte. This is the case of strcasecmp(), strtoupper() and ucfirst(). they can be used with syngle byte encoding 
        * they may just assume the string is using a specific encoding, usually UTF-8. 
- array, An array in PHP is actually an ordered map. 
    + it can be treated as an array, list (vector), hash table (an implementation of a map), dictionary,
    * An array can be created using the array() language construct. 
array(
    key  => value,
    key2 => value2,
    key3 => value3,
    ...
);

// as of PHP 5.4
$array = [
    "foo" => "bar",
    "bar" => "foo",
];
    + key cast will occur 
        * Strings containing valid decimal integers, unless the number is preceded by a + sign, will be cast to the integer type.
        * Floats are also cast to integers,
        * Bools are cast to integers
        * Null will be cast to the empty string 
        * Arrays and objects can not be used as keys
        
    + key is optional,  If it is not specified, PHP will use the increment of the largest previously used integer key.
    $array = array("foo", "bar", "hello", "world");//zero based index 
    
    $array = array(
         "a",
         "b",
    6 => "c",
         "d",
    );
    
    + array access, accessed using the array[key] syntax.
<?php
function getArray() {
    return array(1, 2, 3);
}

// on PHP 5.4
$secondElement = getArray()[1];

// previously
$tmp = getArray();
$secondElement = $tmp[1];

// or
list(, $secondElement) = getArray();

access an array key which has not been defined is the same as accessing any other undefined variable: an E_NOTICE-level error message will be issued, and the result will be NULL.

    + creating/modifying with square bracket
    This is done by assigning values to the array, specifying the key in brackets. The key can also be omitted, resulting in an empty pair of brackets ([]).
    
    $arr[key] = value;
    $arr[] = value;
    
    To change a certain value, assign a new value to that element using its key. To remove a key/value pair, call the unset() function on it.
    
    unset($arr[5]); // This removes the element from the array

    unset($arr);    // This deletes the whole array
    
    + remove element from array 
    To remove a key/value pair, call the unset() function on it.
    unset($arr[5]);
    
// Create a simple array.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Now delete every item, but leave the array itself intact:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Append an item (note that the new key is 5, instead of 0).
$array[] = 6;
print_r($array);

// Re-index:
$array = array_values($array);
$array[] = 7;
print_r($array);

output:
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
    + can be reindexed using the array_values() function.
    + Always use quotes around a string literal array index. For example, $foo['bar'] is correct, while $foo[bar] is not. 

    + For any of the types integer, float, string, boolean and resource, converting a value to an array results in an array 
    
    If an object is converted to an array, the result is an array whose elements are the object's properties. The keys are the member variable names, with a few notable exceptions: integer properties are unaccessible; private variables have the class name prepended to the variable name; protected variables have a '*' prepended to the variable name. These prepended values have null bytes on either side
    
    class A {
        private $A; // This will become '\0A\0A'
    }

    class B extends A {
        private $A; // This will become '\0B\0A'
        public $AA; // This will become 'AA'
    }

    var_dump((array) new B());
    The above will appear to have two keys named 'AA', although one of them is actually named '\0A\0A'.
    
    converting Null to array get empty array 
    
    + comparing, It is possible to compare arrays with the array_diff() function and with array operators.
    
    + reference operator to copy an array by reference. assignment always involves value copying 
    <?php
    $arr1 = array(2, 3);
    $arr2 = $arr1;
    $arr2[] = 4; // $arr2 is changed,
                 // $arr1 is still array(2, 3)
                 
    $arr3 = &$arr1;
    $arr3[] = 4; // now $arr1 and $arr3 are the same
    ?>
    
    + short array sort($files);
    
    + changing element in loop 
    foreach ($colors as &$color) {
        $color = strtoupper($color);
    }
    + useful function 
    unset() removing keys from an array. be aware that the array will not be reindexed if a true "remove and shift" behavior is desired, reindexed array with array_values() function 
    
    // Show all errors
    error_reporting(E_ALL);
    
    $arr = array('fruit' => 'apple', 'veggie' => 'carrot');
    //assigned to a constant named fruit.
    define('fruit', 'veggie');
    // The following is okay, as it's inside a string. Constants are not looked for
    // within strings, so no E_NOTICE occurs here
    print "Hello $arr[fruit]";      // Hello apple
    // With one exception: braces surrounding arrays within strings allows constants
    // to be interpreted
    print "Hello {$arr[fruit]}";    // Hello carrot
    print "Hello {$arr['fruit']}";  // Hello apple
    
    + compare array with array_diff()
    
    + convert to array 
    If an object is converted to an array, the result is an array whose elements are the object's properties.
    
    integer properties are unaccessible; private variables have the class name prepended to the variable name; protected variables have a '*' prepended to the variable name. These prepended values have null bytes on either side
    class A {
        private $A; // This will become '\0A\0A'
    }

    class B extends A {
        private $A; // This will become '\0B\0A'
        public $AA; // This will become 'AA'
    }
    
    + collection 
    $colors = array('red', 'blue', 'green');
    foreach($colors as $color){
        echo "do you like $color?\n";
    }
    
    + sort an array 
    sort($ary);
    
    + change array element by pass reference 
    foreach ($colors as &$color) {
        $color = strtoupper($color);
    }
    unset($color); /* ensure that following writes to
    $color will not modify the last array element */

    + fill in items from a directory 
    // fill an array with all items from a directory
    $handle = opendir('.');
    while (false !== ($file = readdir($handle))) {
        $files[] = $file;
    }
    closedir($handle);
- iterable 
iterable is a pseudo-type introduced in php 7.1. it accepts any array or object implementing the traversable interface. be used with foreach and yield from within a generator 

function foo(iterable $iterable) {
    foreach ($iterable as $value) {
        // ...
    } 
}

    + iterable parameter 
function foo(iterable $iterable = []) {
    // ...
}

    + iterable return value 
function bar(): iterable {
    return [1, 2, 3];
}

    + generator 
function gen(): iterable {
    yield 1;
    yield 2;
    yield 3;
}

    + iterable type variable 
interface Example {
    public function method(array $array): iterable;
}

class ExampleImplementation implements Example {
    public function method(iterable $iterable): array {
        // Parameter broadened and return type narrowed.
    }
}

- object 
    + create a new object use the new statement to instantiate a class 
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
    + converting to object 
    object -> object unchange 
    other type -> object a new instance of the stdClass built-in class is created 
    NULL -> object, new instance will be empty 
    array -> object properties named by keys. numeric keys will be only accessible by iterated 
    
    $obj = (object) array('1' => 'foo');
    var_dump(isset($obj->{'1'})); // outputs 'bool(false)'
    var_dump(key($obj)); // outputs 'int(1)'
    
    + any other value a member value named scalar will contain the value 
    $object = (object) 'ciao';
    echo $object->scalar; //'ciao'
    
- resource 
a special variable, holding a reference to an external resource. get_resource_type() 
    + converting to resource 
    resource hold opened files, database connections, image canvas etc 
    other type convert resource is not needed 
    + auto free resource. persistent dabase links are an exception to this rule. they are not destroyed by the garbage collector. 
    + the resources such as db connection DOM handle etc. 
    
- NULL 
represent no value. NULL is the only possbile valueo f type null 
    + value consider to be null 
t has been assigned the constant NULL.

it has not been set to any value yet.

it has been unset().
    + syntax 
$var = NULL;   
    + empty array is converted to null by non-strict equal '==' comparison. Use is_null() or '===' if there is possible of getting empty array.

    $a = array(); 

    $a == null  <== return true
    $a === null <== return false 
    is_null($a) <== return false 
    
    + depericated casting to NULL 
    Casting a variable to null using (unset) $var will not remove the variable or unset its value. It will only return a NULL value. 
    
- callable, callbacks 
callable type hint as of php5.4 not only could be a function but also could be a object 

Some functions like call_user_func() or usort() accept user-defined callback functions as a parameter.

A PHP function is passed by its name as a string. Any built-in or user-defined function can be used, except language constructs such as: array(), echo, empty(), eval(), exit(), isset(), list(), print or unset().

A method of an instantiated object is passed as an array containing an object at index 0 and the method name at index 1. Accessing protected and private methods from within a class is allowed.

Static class methods can also be passed without instantiating an object of that class by passing the class name instead of an object at index 0. or ClassName::methodName 5.3+

use defined function and anonymous functions are also ok

examples:
<?php

// An example callback function
function my_callback_function() {
    echo 'hello world!';
}

// An example callback method
class MyClass {
    static function myCallbackMethod() {
        echo 'Hello World!';
    }
}

// Type 1: Simple callback
call_user_func('my_callback_function');

// Type 2: Static class method call
call_user_func(array('MyClass', 'myCallbackMethod'));

// Type 3: Object method call
$obj = new MyClass();
call_user_func(array($obj, 'myCallbackMethod'));

// Type 4: Static class method call (As of PHP 5.2.3)
call_user_func('MyClass::myCallbackMethod');

// Type 5: Relative static class method call (As of PHP 5.3.0)
class A {
    public static function who() {
        echo "A\n";
    }
}

class B extends A {
    public static function who() {
        echo "B\n";
    }
}

call_user_func(array('B', 'parent::who')); // A

// Type 6: Objects implementing __invoke can be used as callables (since PHP 5.3)
class C {
    public function __invoke($name) {
        echo 'Hello ', $name, "\n";
    }
}

$c = new C();
call_user_func($c, 'PHP!');
?>

// Our closure
$double = function($a) {
    return $a * 2;
};

// This is our range of numbers
$numbers = range(1, 5);

// Use the closure as a callback here to
// double the size of each element in our
// range
$new_numbers = array_map($double, $numbers);

print implode(' ', $new_numbers);

    + Callbacks registered with functions such as call_user_func() and call_user_func_array() will not be called if there is an uncaught exception thrown in a previous callback.
    
    + calling callbacks as variable 
A note on differences when calling callbacks as "variable functions" without the use of call_user_func() (e.g. "<?php $callback = 'printf'; $callback('Hello World!') ?>"):

    Using the name of a function as string has worked since at least 4.3.0
    Calling anonymous functions and invokable objects has worked since 5.3.0
    Using the array structure [$object, 'method'] has worked since 5.4.0
    
- Pseudo-types and avraibles used in this document. are keywords used in php documentation to specify the types or values an argument can have 

mixed, accept multiple types 
number, integer or float 
callback, callable type 
array|object
void, in return means return value is useless, used in parameter means the function doesn't required any parameter 

$... in function prototypes means so on. means accept endless number of arguments 

- convert variable types 
    + mixed indicates that a parameter may accept multiple (but not necessarily all) types.
    getype() accept all types 
    str_replace() will accept strings and arrays 
    
    + number intecate integer or float 
    + callback callable type 
    + array|object indicates that a parameter can be either array or object
    + void as a return type means that the return value is useless 
    + $... in function prototypes means and so on. means take endless number of arguments 
    
- forcibly convert a variable to a certain type, either cast the variable or use the settype() function on it.
- type juggling
    + auto type converson in php variable name 
    + auto type conversion * number to float 
    + force type conversion with settype() function 
    + type case is similar to C 
    $foo = 10;
    $bar = (boolean) $foo;

(int), (integer) - cast to integer
(bool), (boolean) - cast to boolean
(float), (double), (real) - cast to float
(string) - cast to string
(array) - cast to array
(object) - cast to object
(unset) - cast to NULL (PHP 5)

    + casting literal string to binary strings 
$binary = (binary) $string;
$binary = b"binary string";

    + check string is numeric by 
    is_numeric()
    
    + converting to boolean 
the boolean FALSE itself  
  the integer 0 (zero)  
  the float 0.0 (zero)  
  the empty string, and the string "0"  
  an array with zero elements  
  the special type NULL (including unset variables)  
 SimpleXML objects created from empty tags 
    
    + PHP type comparison tables
        * Simply doing if ($x) while $x is undefined will generate an error of level E_NOTICE. Instead, consider using empty() or isset() and/or initialize your variables
        * Some numeric operations can result in a value represented by the constant NAN. Any loose or strict comparisons of this value against any other value, including itself, but except TRUE, will have a result of FALSE.
        * HTML Forms do not pass integers, floats, or booleans; they pass strings. To find out if a string is numeric, you may use is_numeric(). 
        
    + comparisons of $x with php functions 
Comparisons of $x with PHP functions
Expression          gettype()   empty() is_null()   isset() boolean : if($x)
$x = "";            string      TRUE    FALSE       TRUE    FALSE 
$x = null;          NULL        TRUE    TRUE        FALSE   FALSE 
var $x;             NULL        TRUE    TRUE        FALSE   FALSE 
$x is undefined     NULL        TRUE    TRUE        FALSE   FALSE 
$x = array();       array       TRUE    FALSE       TRUE    FALSE 
$x = array('a', 'b'); array     FALSE   FALSE       TRUE    TRUE 
$x = false;         boolean     TRUE    FALSE       TRUE    FALSE 
$x = true;          boolean     FALSE   FALSE       TRUE    TRUE 
$x = 1;             integer     FALSE   FALSE       TRUE    TRUE 
$x = 42;            integer     FALSE   FALSE       TRUE    TRUE 
$x = 0;             integer     TRUE    FALSE       TRUE    FALSE 
$x = -1;            integer     FALSE   FALSE       TRUE    TRUE 
$x = "1";           string      FALSE   FALSE       TRUE    TRUE 
$x = "0";           string      TRUE    FALSE       TRUE    FALSE 
$x = "-1";          string      FALSE   FALSE       TRUE    TRUE 
$x = "php";         string      FALSE   FALSE       TRUE    TRUE 
$x = "true";        string      FALSE   FALSE       TRUE    TRUE 
$x = "false";       string      FALSE   FALSE       TRUE    TRUE 


Loose comparisons with ==
TRUE    FALSE   1   0   -1  "1" "0" "-1"    NULL    array() "php"   ""
TRUE TRUE FALSE TRUE FALSE TRUE TRUE FALSE TRUE FALSE FALSE TRUE FALSE 
FALSE FALSE TRUE FALSE TRUE FALSE FALSE TRUE FALSE TRUE TRUE FALSE TRUE 
1 TRUE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE 
0 FALSE TRUE FALSE TRUE FALSE FALSE TRUE FALSE TRUE FALSE TRUE TRUE 
-1 TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE 
"1" TRUE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE 
"0" FALSE TRUE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE 
"-1" TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE 
NULL FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE TRUE TRUE FALSE TRUE 
array() FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE 
"php" TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE 
"" FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE 

Strict comparisons with ===
TRUE    FALSE   1   0   -1  "1" "0" "-1"    NULL    array() "php"   ""
TRUE    TRUE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
FALSE   FALSE TRUE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
1       FALSE FALSE TRUE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
0       FALSE FALSE FALSE TRUE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
-1      FALSE FALSE FALSE FALSE TRUE  FALSE FALSE FALSE FALSE FALSE FALSE FALSE 
"1"     FALSE FALSE FALSE FALSE FALSE TRUE  FALSE FALSE FALSE FALSE FALSE FALSE 
"0"     FALSE FALSE FALSE FALSE FALSE FALSE TRUE  FALSE FALSE FALSE FALSE FALSE 
"-1"    FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE  FALSE FALSE FALSE FALSE 
NULL    FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE  FALSE FALSE FALSE 
array() FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE  FALSE FALSE 
"php"   FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE  FALSE 
""      FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE 



## Variables 
- variable start with $, case-sensitive 
- $this is a special variable that can't be assigned.
- basics 
    + By default, variables are always assigned by value.
    + assign value by reference, prepend with an ampersand(&) to the beginning 
$foo = 'Bob';              // Assign the value 'Bob' to $foo
$bar = &$foo;              // Reference $foo via $bar.
$bar = "My name is $bar";  // Alter $bar...
echo $bar;
echo $foo;                 // $foo is altered too.

only named variable could be assigned by reference 

    + isset() language construct can be used to detect if a variable has been already initialized.
    
- predefined variables 
Superglobals — Superglobals are built-in variables that are always available in all scopes
$GLOBALS — References all variables available in global scope
$_SERVER — Server and execution environment information
$_GET — HTTP GET variables
$_POST — HTTP POST variables
$_FILES — HTTP File Upload variables
$_REQUEST — HTTP Request variables
$_SESSION — Session variables
$_ENV — Environment variables
$_COOKIE — HTTP Cookies
$php_errormsg — The previous error message
$HTTP_RAW_POST_DATA — Raw POST data
$http_response_header — HTTP response headers
$argc — The number of arguments passed to script
$argv — Array of arguments passed to script
    + super global arrays are built-in variables that are always available in all scopes 
$GLOBALS
$_SERVER
$_GET
$_POST
$_FILES
$_COOKIE
$_SESSION
$_REQUEST
$_ENV


    + $_SERVER['PHP_SELF'] can include arbitrary user input. The documentation should be updated to reflect this.
    
- variable scope, is the context within which it is defined 
    + the scope is the context within which it is defined. all php variables only have a single scope. This single scope included and required files as well 
    <?php 
    $a = 1;
    include 'b.inc';
    ?>
    
    
    + variable reference inside a function is by default limited to the local function scope 
$a = 1; /* global scope */ 

function test()
{ 
    echo $a; /* reference to local scope variable */ 
} 

it will ouput nothong which is different from C; php have to explicit claim reference global variable 

    + global keyword
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

second way to access global variale is use the $GLOBALS array 
    + Notice how $GLOBALS exists in any scope, this is because $GLOBALS is a superglobal.
    
    + using static variables 
    A static variable exists only in a local function scope, but it does not lose its value when program execution leaves this scope. 
    
<?php
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?> 
    
    + references with global and static varialbes, a true global variable imported inside a function scope with the global statement actually creates a reference to the global variable
    
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
    + output 

NULL
object(stdClass)(0) {
}

    + static statement, references are not stored statically 
function &get_instance_ref() {
    static $obj;

    echo 'Static object: ';
    var_dump($obj);
    if (!isset($obj)) {
        // Assign a reference to the static variable
        $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo 'Static object: ';
    var_dump($obj);
    if (!isset($obj)) {
        // Assign the object to the static variable
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();

    + output 
Static object: NULL
Static object: NULL

Static object: NULL
Static object: object(stdClass)(1) {
["property"]=>
int(1)
}

when assigning a reference to a static variable, it's not remembered when you call the &get_instance_ref() function a second time. 

    + static class method variable, these are class-methods. Having an object is just a collection of properties, the functions remain at the class. So if you declare a variable as static inside a function, it's static for the whole class and all of its instances, not for each object
class sample_class
{
  public function func_having_static_var($x = NULL)
  {
    static $var = 0;
    if ($x === NULL)
    { return $var; }
    $var = $x;
  }
}

$a = new sample_class();
$b = new sample_class();

echo $a->func_having_static_var()."\n";
echo $b->func_having_static_var()."\n";
// this will output (as expected):
//  0
//  0

$a->func_having_static_var(3);

echo $a->func_having_static_var()."\n";
echo $b->func_having_static_var()."\n";
// this will output:
//  3
//  3
// maybe you expected:
//  3
//  0
- variable variables, takes the value of a variable and treats that as the name of a variable with two dollar signs. like a c pointer 
<?php 
$var_name = 'value';
$$vv = 'var_name';

    + variable variables with arrays, you have to resolve an ambiguity problem. That is, if you write $$a[1] then the parser needs to know if you meant to use $a[1] as a variable, or if you wanted $$a as the variable and then the [1] index from that variable. The syntax for resolving this ambiguity is: ${$a[1]} for the first case and ${$a}[1] for the second. 
    
    + Class properties may also be accessed using variable property names. The variable property name will be resolved within the scope from which the call is made. For instance, if you have an expression such as $foo->$bar, then the local scope will be examined for $bar and its value will be used as the name of the property of $foo
    $foo->$bar 
    
    + Curly braces may also be used, to clearly delimit the property name. 
<?php
class foo {
    var $bar = 'I am bar.';
    var $arr = array('I am A.', 'I am B.', 'I am C.');
    var $r   = 'I am r.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo $foo->$bar . "\n";
echo $foo->{$baz[1]} . "\n";

$start = 'b';
$end   = 'ar';
echo $foo->{$start . $end} . "\n";

$arr = 'arr';
echo $foo->{$arr[1]} . "\n";

?> 

- variables from external sources 
    + html forms, GET and POST 
    
    when a form is submitted to a php script the information from that form is automatically made avaliable to the script 
    
    <form action="foo.php" method="post">
        Name:  <input type="text" name="username" /><br />
        Email: <input type="text" name="email" /><br />
        <input type="submit" name="submit" value="Submit me!" />
    </form>
    
    //access data from a POST html form 
    <?php
        echo $_POST['username'];
        echo $_REQUEST['username'];
    ?> 
    
    + Using a GET form is similar except you'll use the appropriate GET predefined variable instead. GET also applies to the QUERY_STRING (the information after the '?' in a URL).
    
    + Dots and spaces in variable names are converted to underscores. For example <input name="a.b" /> becomes $_REQUEST["a_b"]. 
    
    + MORE complex form example 
<?php
if ($_POST) {
    echo '<pre>';
    echo htmlspecialchars(print_r($_POST, true));
    echo '</pre>';
}
?>
<form action="" method="post">
    Name:  <input type="text" name="personal[name]" /><br />
    Email: <input type="text" name="personal[email]" /><br />
    Beer: <br />
    <select multiple name="beer[]">
        <option value="warthog">Warthog</option>
        <option value="guinness">Guinness</option>
        <option value="stuttgarter">Stuttgarter Schwabenbräu</option>
    </select><br />
    <input type="submit" value="submit me!" />
</form> 

//post to the current file 

    + image submit variable names 

    When submitting a form, it is possible to use an image instead of the standard submit button with a tag like: 

    <input type="image" src="image.gif" name="sub" />

    When the user clicks somewhere on the image, the accompanying form will be transmitted to the server with two additional variables, sub_x and sub_y.

    + HTTP cookies, You can set cookies using the setcookie() function. Cookies are part of the HTTP header, so the SetCookie function must be called before any output is sent to the browser.
    
    This is the same restriction as for the header() function. Cookie data is then available in the appropriate cookie data arrays such as $_COOKIE as well in $_REQUEST 
    

<?php
if (isset($_COOKIE['count'])) {
    $count = $_COOKIE['count'] + 1;
} else {
    $count = 1;
}
setcookie('count', $count, time()+3600);
setcookie("Cart[$count]", $item, time()+3600);
?> 
    
    + determining variable types,  PHP includes several functions which find out what type a variable is, such as: gettype(), is_array(), is_float(), is_int(), is_object(), and is_string(). 
    
    
    
# Constants 
-  While define() allows a constant to be defined to an arbitrary expression, the const keyword has restrictions as outlined in the next paragraph

You can also use the function constant() to read a constant's value 

Use get_defined_constants() to get a list of all defined constants

-  Constants and (global) variables are in a different namespace

- difference between constant and variable 
    + Constants do not have a dollar sign ($) before them
    + Constants may be defined and accessed anywhere without regard to variable scoping rules; 
    + Constants can not be redefined or undefined once they have been set;
    + Constants may only evaluate to scalar values
    
- magic constants, these constants are created by various extensions, they will be present when those extensions are loaded 

__LINE__, line that's used on your script 
__FILE__
__DIR__, equal to dirname(__FILE__)
__FUNCTION__
__CLASS__
__TRAIT__
__METHOD__
__NAMESPACE__, the name of the current namespace 
ClassName::class, fully qualified class name 

- expressions， anything that has a value 

most basic form of expressions are constants and variables 


# Operators 
- operators can be grouped into logical operator, increment operator, arithmetical operator, ternary operator 

- operator precedence 

Associativity
Operators
Additional Information
non-associative clone new  clone and new 
left    [ array() 
right   ** arithmetic 
right   ++ -- ~ (int) (float) (string) (array) (object) (bool) @  types and increment/decrement  
non-associative instanceof types  
right   ! logical  
left    * / %  arithmetic  
left    + - .  arithmetic and string 
left    << >>  bitwise  
non-associative < <= > >=  comparison  
non-associative == != === !== <> <=>  comparison  
left    & bitwise and references 
left    ^ bitwise  
left    | bitwise  
left    && logical  
left    || logical  
right   ?? comparison  
left    ? : ternary  
right   = += -= *= **= /= .= %= &= |= ^= <<= >>=  assignment  
left    and logical  
left    xor logical  
left    or logical  

- arithmetic operators 
+$a         Identity Conversion of $a to int or float as appropriate.  
-$a         Negation Opposite of $a. 
$a + $b     Addition Sum of $a and $b. 
$a - $b     Subtraction Difference of $a and $b. 
$a * $b     Multiplication Product of $a and $b. 
$a / $b     Division Quotient of $a and $b. 
$a % $b     Modulo Remainder of $a divided by $b. 
$a ** $b    Exponentiation Result of raising $a to the $b'th power. Introduced in PHP 5.6. 

- assignment operators, The value of an assignment expression is the value assigned. That is, the value of "$a = 3" is 3


$a = ($b = 4) + 5; // $a is equal to 9 now, and $b has been set to 4.

the assignment copied the original to the new one. assign object is assigned by  reference in php5+, to assign by value required to used clone keyword 

- assignment by reference, if the right expression is reference then an error will be occoured 
$a = 3;
$b = &$a;

the new operator returns a reference automatically

- bitwise operators, evaluation and manipulation of specifc bits within an integer 
$a & $b     And Bits that are set in both $a and $b are set. 
$a | $b     Or (inclusive or) Bits that are set in either $a or $b are set. 
$a ^ $b     Xor (exclusive or) Bits that are set in $a or $b but not both are set.  
~ $a        Not Bits that are set in $a are not set, and vice versa.  
$a << $b    Shift left Shift the bits of $a $b steps to the left (each step means "multiply by two")  
$a >> $b    Shift right Shift the bits of $a $b steps to the right (each step means "divide by two")  

If both operands for the &, | and ^ operators are strings, then the operation will be performed on the ASCII values 

result for the << and >> operators are always treated as integers. 

- comparison operators 
$a == $b    Equal TRUE if $a is equal to $b after type juggling. 
$a === $b   Identical TRUE if $a is equal to $b, and they are of the same type.  
$a != $b    Not equal TRUE if $a is not equal to $b after type juggling. 
$a <> $b    Not equal TRUE if $a is not equal to $b after type juggling. 
$a !== $b   Not identical TRUE if $a is not equal to $b, or they are not of the same type.  
$a < $b     Less than TRUE if $a is strictly less than $b. 
$a > $b     Greater than TRUE if $a is strictly greater than $b. 
$a <= $b    Less than or equal to  TRUE if $a is less than or equal to $b. 
$a >= $b    Greater than or equal to  TRUE if $a is greater than or equal to $b. 
$a <=> $b   Spaceship An integer less than, equal to, or greater than zero when $a is respectively less than, equal to, or greater than $b. Available as of PHP 7.  


null or string  string Convert NULL to "", numerical or lexical comparison 
bool or null    anything Convert both sides to bool, FALSE < TRUE 
object object   Built-in classes can define its own comparison, different classes are uncomparable, same class - compare properties the same way as arrays (PHP 4), PHP 5 has its own explanation  
string, resource or number string, resource or number Translate strings and resources to numbers, usual math 
array array     Array with fewer members is smaller, if key from operand 1 is not found in operand 2 then arrays are uncomparable, otherwise - compare value by value (see following example) 
object anything object is always greater 
array anything  array is always greater 

- error control operators 
the at sign (@). When prepended to an expression in PHP, any error messages that might be generated by that expression will be ignored. 

set custom error handler function with set_error_handler() then it will still get called, but this custom error handler can (and should) call error_reporting() which will return 0 when the call that triggered the error was preceded by an @. 

If the track_errors  feature is enabled, any error message generated by the expression will be saved in the variable $php_errormsg.
<?php 

/* Intentional file error */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// this works for any expression, not just functions:
$value = @$cache[$key];
// will not issue a notice if the index $key doesn't exist.

?>

    + The @-operator works only on expressions. A simple rule of thumb is: if you can take the value of something, you can prepend the @ operator to it

    You cannot prepend it to function or class definitions, or conditional structures such as if and foreach, and so forth. 
    
    + Currently the "@" error-control operator prefix will even disable error reporting for critical errors that will terminate script execution. the script will die right there with no indication as to why. 
    
- Execution operators, PHP supports one execution operator: backticks (``). Note that these are not single-quotes! PHP will attempt to execute the contents of the backticks as a shell command; the output will be returned 
    
- incrementing/decrementing operators 
++$a Pre-increment Increments $a by one, then returns $a. 
$a++ Post-increment Returns $a, then increments $a by one. 
--$a Pre-decrement Decrements $a by one, then returns $a. 
$a-- Post-decrement Returns $a, then decrements $a by one. 

PHP and Perl $a = 'Z'; $a++; turns $a into 'AA', while in C a = 'Z'; a++; turns a into '[' (ASCII value of 'Z' is 90, ASCII value of '[' is 91). Incrementing/decrementing other character variables has no effect, the original string is unchanged. 
    
- logical operators 
$a and $b   And TRUE if both $a and $b are TRUE. 
$a or $b    Or TRUE if either $a or $b is TRUE. 
$a xor $b   Xor TRUE if either $a or $b is TRUE, but not both. 
! $a        Not TRUE if $a is not TRUE. 
$a && $b    And TRUE if both $a and $b are TRUE. 
$a || $b    Or TRUE if either $a or $b is TRUE. 

- string operators 
    + The first is the concatenation operator ('.'), which returns the concatenation of its right and left arguments.
    
    + The second is the concatenating assignment operator ('.='), which appends the argument on the right side to the argument on the left side.
        
- array operators 
$a + $b     Union Union of $a and $b. 
$a == $b    Equality TRUE if $a and $b have the same key/value pairs. 
$a === $b   Identity TRUE if $a and $b have the same key/value pairs in the same order and of the same types. 
$a != $b    Inequality TRUE if $a is not equal to $b. 
$a <> $b    Inequality TRUE if $a is not equal to $b. 
$a !== $b   Non-identity TRUE if $a is not identical to $ 

- type operators, determine whether a PHP variable is an instantiated object of a certain class: 

var_dump(!($a instanceof stdClass));


# Control structures 
- . A statement can be an assignment, a function call, a loop, a conditional statement or even a statement that does nothing (an empty statement). Statements usually end with a semicolon.

if(condition){
}
elseif(condition){
}
else{
}

- alternative syntax for control structures in php 4+ 
if, while, for, foreach, and switch. In each case, the basic form of the alternate syntax is to change the opening brace to a colon (:) and the closing brace to endif;, endwhile;, endfor;, endforeach;, or endswitch;, respectively. 

Any output (including whitespace) between a switch statement and the first case will result in a syntax error
<?php switch ($foo): ?>
    <?php case 1: ?>
    ...
<?php endswitch ?> 

- while 
- do while 
do{

}while(condition);

- for 
for (expr1; expr2; expr3)
    statement
    
- foreach 
foreach (array_expression as $value)
    statement
foreach (array_expression as $key => $value)
    statement
    
- break 

<?php
$arr = array('one', 'two', 'three', 'four', 'stop', 'five');
while (list(, $val) = each($arr)) {
    if ($val == 'stop') {
        break;    /* You could also write 'break 1;' here. */
    }
    echo "$val<br />\n";
}

/* Using the optional argument. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "At 5<br />\n";
        break 1;  /* Exit only the switch. */
    case 10:
        echo "At 10; quitting<br />\n";
        break 2;  /* Exit the switch and the while. */
    default:
        break;
    }
}
?> 

- continue 
while (list($key, $value) = each($arr)) {
    if (!($key % 2)) { // skip even members
        continue;
    }
    do_something_odd($value);
}

- switch 
switch ($i) {
    case 0:
        echo "i equals 0";
        break;
    case 1:
        echo "i equals 1";
        break;
    case 2:
        echo "i equals 2";
        break;
}

- declare 

The declare construct is used to set execution directives for a block of code. The syntax of declare is similar to the syntax of other flow control constructs: 

declare (directive)
    statement

    + Currently only three directives are recognized: the ticks directive (See below for more information on the ticks directive), the encoding directive (See below for more information on the encoding directive) and the strict_types directive 
    
    + ticks, A tick is an event that occurs for every N low-level tickable statements executed by the parser within the declare block
// these are the same:

// you can use this:
declare(ticks=1) {
    // entire script here
}

// or you can use this:
declare(ticks=1);
// entire script here

The event(s) that occur on each tick are specified using the register_tick_function().
    
        * Example 
declare(ticks=1);

// A function called on each tick event
function tick_handler()
{
    echo "tick_handler() called\n";
}

register_tick_function('tick_handler');

    + declare encoding 
<?php
declare(encoding='ISO-8859-1');
// code here
?> 

When combined with namespaces, the only legal syntax for declare is declare(encoding='...'); where ... is the encoding value. declare(encoding='...') {} will result in a parse error when combined with namespaces. 

The encoding declare value is ignored in PHP 5.3 unless php is compiled with --enable-zend-multibyte. 

    +  In strict mode, only a variable of exact type of the type declaration will be accepted, or a TypeError will be thrown. 
        
- return, If called from the global scope, then execution of the current script file is ended. If the current script file was included or required, then control is passed back to the calling file. Furthermore, if the current script file was included, then the value given to return will be returned as the value of the include call

If the current script file was named by the auto_prepend_file or auto_append_file configuration options in php.ini, then that script file's execution is ended. 

You should never use parentheses around your return variable when returning by reference, as this will not work. You can only return variables by reference
    
- require/require, require is identical to include except upon failure it will also produce a fatal E_COMPILE_ERROR level error
 include only emits a warning (E_WARNING) which allows the script to continue. 
    
the include_path specified. If the file isn't found in the include_path, include will finally check in the calling script's own directory and the current working directory before failing
    
whether absolute (starting with a drive letter or \ on Windows, or / on Unix/Linux systems) or relative to the current directory (starting with . or ..) 

- require_once php will make sure the code is imported only once 
- include_once, will not be included again, and include_once returns TRUE. As the name suggests, the file will be included just once. 

- goto,  The target label must be within the same file and context, meaning that you cannot jump out of a function or method, nor can you jump into one. You also cannot jump into any sort of loop or switch structure. You may jump out of these, and a common use is to use a goto in place of a multi-level break.

<?php
for($i=0,$j=50; $i<100; $i++) {
  while($j--) {
    if($j==17) goto end; 
  }  
}
echo "i = $i";
end:
echo 'j hit 17';
?> 


# Functions 
- user defined functions 
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Example function.\n";
    return $retval;
}

Functions need not be defined before they are referenced, except when a function is conditionally defined as shown in the two examples below. 

Both variable number of arguments and default arguments are supported in functions. See also the function references for func_num_args(), func_get_arg(), and func_get_args() for more information. 

- function arguments, which is a comma-delimited list of expressions. The arguments are evaluated from left to right. 

function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}

by default function argument is passing by value; prepend an ampersand (&) to pass by reference 

    + default argument value 

function makecoffee($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
- returning values 
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();


return by value 
function square($num)
{
    return $num * $num;
}
echo square(4);   // outputs '16'.


    + use strict types 
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5)); //error return none integer type 

- variable functions 
    +  if a variable name has parentheses appended to it, PHP will look for a function with the same name as whatever the variable evaluates
    
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// This is a wrapper function around echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // This calls foo()

$func = 'bar';
$func('test');  // This calls bar()

$func = 'echoit';
$func('test');  // This calls echoit()

    + used with class instance 
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // This calls the Bar() method
    }
    
    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // This calls $foo->Variable()

    + with static property 
<?php
class Foo
{
    static $variable = 'static property';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // This prints 'static property'. It does need a $variable in this scope.
$variable = "Variable";
Foo::$variable();  // This calls $foo->Variable() reading $variable in this scope.

?> 

    + use array variable to call function from class 
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // prints "bar"
$func = array(new Foo, "baz");
$func(); // prints "baz"
$func = "Foo::bar";
$func(); // prints "bar" as of PHP 7.0.0; prior, it raised a fatal error
?> 

- internal functions 
    + built-in 
    + some of the internal function required to load some extensions 
    
- anonymous functions 
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// outputs helloWorld

    + auto binding function 
class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();

    +  This prevents them from having the current class automatically bound to them.


# Classes and objects 
- introduction 
    + php support visibility, abstract and final classes and methods, additional magic methods, interfaces, cloning and typehinting. 
    
- the basics 
class SimpleClass
{
    // property declaration
    public $var = 'a default value';

    // method declaration
    public function displayVar() {
        echo $this->var;
    }
}

    + $this is a reference to the calling object

    + To create an instance of a class, the new keyword must be used.

    + In the class context, it is possible to create a new object by new self and new parent. 
    + create new objects 
class Test
{
    static public function getNew()
    {
        return new static;
    }
}

class Child extends Test
{}

$obj1 = new Test();
$obj2 = new $obj1;
var_dump($obj1 !== $obj2);

$obj3 = Test::getNew();
var_dump($obj3 instanceof Test);

    + Class properties and methods live in separate "namespaces", so it is possible to have a property and a method with the same name. 
    
class Foo
{
    public $bar = 'property';
    
    public function bar() {
        return 'method';
    }
}

$obj = new Foo();
echo $obj->bar, PHP_EOL, $obj->bar(), PHP_EOL; 

The above example will output:

property
method

    + calling an anonymous function which has been assigned to a property is not directly possible. 
    
    + calling an anonymous function stored in a property 
class Foo
{
    public $bar;
    
    public function __construct() {
        $this->bar = function() {
            return 42;
        };
    }
}

$obj = new Foo();

// as of PHP 5.3.0:
$func = $obj->bar;
echo $func(), PHP_EOL;

// alternatively, as of PHP 7.0.0:
echo ($obj->bar)(), PHP_EOL; 

    + extends, class can inherit the methods and properties of another class by using the keyword extends. It is not possible to extend multiple classes; a class can only inherit from one base class
    
    + the parent class has defined a method as final, that method may not be overridden. It is possible to access the overridden methods or static properties by referencing them with parent::. 
    
<?php
class ExtendClass extends SimpleClass
{
    // Redefine the parent method
    function displayVar()
    {
        echo "Extending class\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended->displayVar();
?> 

    +  class keyword is also used for class name resolution. You can get a string containing the fully qualified name of the ClassName class by using ClassName::class. 
    
    this is usefuly with namespaced classes 
    
<?php
namespace NS {
    class ClassName {
    }
    
    echo ClassName::class;
}
?>  

The above example will output:

NS\ClassName

- properties,  You may also see them referred to using other terms such as "attributes" or "fields", but for the purposes of this reference we will use "properties". They are defined by using one of the keywords public, protected, or private,

non-static properties may be accessed by using -> (Object Operator): $this->property (where property is the name of the property). Static properties are accessed by using the :: (Double Colon): self::$property

The pseudo-variable $this is available inside any class method when that method is called from within an object context. $this is a reference to the calling object


- class constants, don't use $ symbol 
class MyClass
{
    public const CONSTANT = 'constant value';

    function showConstant() {
        echo  self::CONSTANT . "\n";
    }
}

echo MyClass::CONSTANT . "\n";

- autoloading classes,  The spl_autoload_register() function registers any number of autoloaders, enabling for classes and interfaces to be automatically loaded if they are currently not defined


<?php
spl_autoload_register(function ($class_name) {
    include $class_name . '.php';
});

$obj  = new MyClass1();
$obj2 = new MyClass2(); 
?> 

- constructors and destructors 
    + constructor 
void __construct ([ mixed $args = "" [, $... ]] )

Parent constructors are not called implicitly if the child class defines a constructor. In order to run a parent constructor, a call to parent::__construct() within the child constructor is required. 

<?php
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "In SubClass constructor\n";
   }
}

class OtherSubClass extends BaseClass {
    // inherits BaseClass's constructor
}

// In BaseClass constructor
$obj = new BaseClass();

// In BaseClass constructor
// In SubClass constructor
$obj = new SubClass();

// In BaseClass constructor
$obj = new OtherSubClass();
?> 

    + destructor, will be called as soon as there are no other references to a particular object 
    
void __destruct ( void );

<?php
class MyDestructableClass {
   function __construct() {
       print "In constructor\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Destroying " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?> 

The destructor will be called even if script execution is stopped using exit(). Calling exit() in a destructor will prevent the remaining shutdown routines from executing

- visibility, Class properties must be defined as public, private, or protected. If declared using var, the property will be defined as public. 

    + method also could be add visibility
    
    + constant visiblity 
class MyClass
{
    // Declare a public constant
    public const MY_PUBLIC = 'public';

    // Declare a protected constant
    protected const MY_PROTECTED = 'protected';

    // Declare a private constant
    private const MY_PRIVATE = 'private';

    public function foo()
    {
        echo self::MY_PUBLIC;
        echo self::MY_PROTECTED;
        echo self::MY_PRIVATE;
    }
}

- Use $this to refer to the current object. Use self to refer to the current class. In other words, use $this->member for non-static members, use self::$member for static members.

- object inheritance, Unless autoloading is used, then classes must be defined before they are used. If a class extends another, then the parent class must be declared before the child class structure.

class Foo
{
    public function printItem($string)
    {
        echo 'Foo: ' . $string . PHP_EOL;
    }
    
    public function printPHP()
    {
        echo 'PHP is great.' . PHP_EOL;
    }
}

class Bar extends Foo
{
    public function printItem($string)
    {
        echo 'Bar: ' . $string . PHP_EOL;
    }
}

- scope resolution operator ::
class MyClass {
    const CONST_VALUE = 'A constant value';
}

$classname = 'MyClass';
echo $classname::CONST_VALUE; // As of PHP 5.3.0

echo MyClass::CONST_VALUE;

    + calling a parent's method 
<?php
class MyClass
{
    protected function myFunc() {
        echo "MyClass::myFunc()\n";
    }
}

class OtherClass extends MyClass
{
    // Override parent's definition
    public function myFunc()
    {
        // But still call the parent function
        parent::myFunc();
        echo "OtherClass::myFunc()\n";
    }
}

$class = new OtherClass();
$class->myFunc();
?> 

- static keyword 
    + static property 
class Foo
{
    public static $my_static = 'foo';

    public function staticValue() {
        return self::$my_static;
    }
}

class Bar extends Foo
{
    public function fooStatic() {
        return parent::$my_static;
    }
}


print Foo::$my_static . "\n";

$foo = new Foo();
print $foo->staticValue() . "\n";
print $foo->my_static . "\n";      // Undefined "Property" my_static 

print $foo::$my_static . "\n";
$classname = 'Foo';
print $classname::$my_static . "\n"; // As of PHP 5.3.0

print Bar::$my_static . "\n";
$bar = new Bar();
print $bar->fooStatic() . "\n";

    
    + static method 

class Foo {
    public static function aStaticMethod() {
        // ...
    }
}

- class abstraction
    + if the abstract method is defined as protected, the function implementation must be defined as either protected or public, but not private.
    + . For example, if the child class defines an optional argument, where the abstract method's signature does not, there is no conflict in the signature

abstract class AbstractClass
{
    // Force Extending class to define this method
    abstract protected function getValue();
    abstract protected function prefixValue($prefix);

    // Common method
    public function printOut() {
        print $this->getValue() . "\n";
    }
}


class ConcreteClass1 extends AbstractClass
{
    protected function getValue() {
        return "ConcreteClass1";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass1";
    }
}

class ConcreteClass2 extends AbstractClass
{
    public function getValue() {
        return "ConcreteClass2";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass2";
    }
}

$class1 = new ConcreteClass1;
$class1->printOut();
echo $class1->prefixValue('FOO_') ."\n";

$class2 = new ConcreteClass2;
$class2->printOut();
echo $class2->prefixValue('FOO_') ."\n";

- object interfaces 
    + Object interfaces allow you to create code which specifies which methods a class must implement
    
// Declare the interface 'iTemplate'
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}

// Implement the interface
// This will work
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this->vars as $name => $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}

// This will not work
// Fatal error: Class BadTemplate contains 1 abstract methods
// and must therefore be declared abstract (iTemplate::getHtml)
class BadTemplate implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
}

    + extend an interface 
interface a
{
    public function foo();
}

interface b extends a
{
    const b = 'Interface constant';
    public function baz(Baz $baz);
}

- traits
    + A Trait is similar to a class, but only intended to group functionality in a fine-grained and consistent way
    
    + It is not possible to instantiate a Trait on its own. It is an addition to traditional inheritance and enables horizontal composition of behavior;
    
trait ezcReflectionReturnInfo {
    function getReturnType() { /*1*/ }
    function getReturnDescription() { /*2*/ }
}

class ezcReflectionMethod extends ReflectionMethod {
    use ezcReflectionReturnInfo;
    /* ... */
}

class ezcReflectionFunction extends ReflectionFunction {
    use ezcReflectionReturnInfo;
    /* ... */
}

    + The precedence order is that members from the current class override Trait methods, which in turn override inherited methods. 

class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}

class MyHelloWorld extends Base {
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
?>  

The above example will output:

Hello World!

    + Multiple Traits can be inserted into a class by listing them in the use statement, separated by commas. 

    + Since this only allows one to exclude methods, the as operator can be used to add an alias to one of the methods. as also could be used to adjust visibility of a method 
trait A {
    public function smallTalk() {
        echo 'a';
    }
    public function bigTalk() {
        echo 'A';
    }
}

trait B {
    public function smallTalk() {
        echo 'b';
    }
    public function bigTalk() {
        echo 'B';
    }
}

class Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
    }
}

class Aliased_Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
        B::bigTalk as private talk;
    }
}

    + trait also could be composed together 
    
- anonymous classes 
// Pre PHP 7 code
class Logger
{
    public function log($msg)
    {
        echo $msg;
    }
}

$util->setLogger(new Logger());

// PHP 7+ code
$util->setLogger(new class(10) extends SomeClass implements SomeInterface {
    private $num;

    public function __construct($num)
    {
        $this->num = $num;
    }

    use SomeTrait;
});
    
    + Nesting an anonymous class within another class does not give it access to any private or protected methods or properties of that outer class
    
    + In order to use the outer class' protected properties or methods, the anonymous class can extend the outer class. 
    
    + To use private properties of the outer, they must passed throught its constructor 
    

function anonymous_class()
{
    return new class {};
}

if (get_class(anonymous_class()) === get_class(anonymous_class())) {
    echo 'same class';
} else {
    echo 'different class';
}  

The above example will output:

same class

- overloading
    + Overloading in PHP provides means to dynamically "create" properties and methods.
    + All overloading methods must be defined as public. 
    + None of the arguments of these magic methods can be passed by reference. 
    + multiple methods with the same name but different quantities and type of arguments 
    
    + property overloading 
public void __set ( string $name , mixed $value ), is run when writing data to inaccessible properties. 

public mixed __get ( string $name ), is utilized for reading data from inaccessible properties. 

public bool __isset ( string $name ),  is triggered by calling isset() or empty() on inaccessible properties. 

public void __unset ( string $name ), is invoked when unset() is used on inaccessible properties. 

    + method overloading 
public mixed __call ( string $name , array $arguments ), is triggered when invoking inaccessible methods in an object context. 

public static mixed __callStatic ( string $name , array $arguments ), is triggered when invoking inaccessible methods in a static context. 

- object iteration, provides a way for objects to be defined so it is possible to iterate through a list of items
    + default object iteration 
class MyClass
{
    public $var1 = 'value 1';
    public $var2 = 'value 2';
    public $var3 = 'value 3';

    protected $protected = 'protected var';
    private   $private   = 'private var';

    function iterateVisible() {
       echo "MyClass::iterateVisible:\n";
       foreach ($this as $key => $value) {
           print "$key => $value\n";
       }
    }
}

$class = new MyClass();

foreach($class as $key => $value) {
    print "$key => $value\n";
}
echo "\n";

$class->iterateVisible();

The above example will output:

var1 => value 1
var2 => value 2
var3 => value 3

MyClass::iterateVisible:
var1 => value 1
var2 => value 2
var3 => value 3
protected => protected var
private => private var


    + the Iterator interface may be implemented. This allows the object to dictate how it will be iterated and what values will be available on each iteration. 
    
class MyIterator implements Iterator
{
    private $var = array();

    public function __construct($array)
    {
        if (is_array($array)) {
            $this->var = $array;
        }
    }

    public function rewind()
    {
        echo "rewinding\n";
        reset($this->var);
    }
  
    public function current()
    {
        $var = current($this->var);
        echo "current: $var\n";
        return $var;
    }
  
    public function key() 
    {
        $var = key($this->var);
        echo "key: $var\n";
        return $var;
    }
  
    public function next() 
    {
        $var = next($this->var);
        echo "next: $var\n";
        return $var;
    }
  
    public function valid()
    {
        $key = key($this->var);
        $var = ($key !== NULL && $key !== FALSE);
        echo "valid: $var\n";
        return $var;
    }

}

$values = array(1,2,3);
$it = new MyIterator($values);

foreach ($it as $a => $b) {
    print "$a: $b\n";
}    
    
    + IteratorAggregate only requires the implementation of a single method
class MyCollection implements IteratorAggregate
{
    private $items = array();
    private $count = 0;

    // Required definition of interface IteratorAggregate
    public function getIterator() {
        return new MyIterator($this->items);
    }

    public function add($value) {
        $this->items[$this->count++] = $value;
    }
}

$coll = new MyCollection();
$coll->add('value 1');
$coll->add('value 2');
$coll->add('value 3');
    
foreach ($coll as $key => $val) {
    echo "key/value: [$key -> $val]\n\n";
}
    
- magic methods, The function names __construct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(), __sleep(), __wakeup(), __toString(), __invoke(), __set_state(), __clone() and __debugInfo() are magical in PHP classes. 
    
__sleep() and __wakeup() 

serialize() checks if your class has a function with the magic name __sleep(). 
    
    + If the method doesn't return anything then NULL is serialized and E_NOTICE is issued
    
    + The intended use of __sleep() is to commit pending data or perform similar cleanup tasks. Also if you have large objects do not need to be saved completely
    
    + The intended use of __wakeup() is to reestablish any database connections 
    
class Connection
{
    protected $link;
    private $dsn, $username, $password;
    
    public function __construct($dsn, $username, $password)
    {
        $this->dsn = $dsn;
        $this->username = $username;
        $this->password = $password;
        $this->connect();
    }
    
    private function connect()
    {
        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }
    
    public function __sleep()
    {
        return array('dsn', 'username', 'password');
    }
    
    public function __wakeup()
    {
        $this->connect();
    }
}
    
    + The __toString() method allows a class to decide how it will react when it is treated like a string.
    
    + The __invoke() method is called when a script tries to call an object as a function. 
    
    + static object __set_state ( array $properties )

    This static method is called for classes exported by var_export() since PHP 5.1.0. 

    + array __debugInfo ( void )

    This method is called by var_dump() when dumping an object to get the properties that should be shown

- final keyword , which prevents child classes from overriding a method by prefixing the definition with final.
    
class BaseClass {
   public function test() {
       echo "BaseClass::test() called\n";
   }
   
   final public function moreTesting() {
       echo "BaseClass::moreTesting() called\n";
   }
}

class ChildClass extends BaseClass {
   // fatal error 
   public function moreTesting() {
       echo "ChildClass::moreTesting() called\n";
   }
}

    + any class can not inherit from final class 
    
- object cloning 
    + An object copy is created by using the clone keyword, perform a shallow copy of all of the object's properties.
    + An object's __clone() method cannot be called directly. 
$copy_of_object = clone $object;

    + PHP 7.0.0 introduced the possibility to access a member of a freshly cloned object in a single expression: 
$dateTime = new DateTime();
echo (clone $dateTime)->format('Y');

- Comparing objects 
    + When using the comparison operator (==), object variables are compared in a simple manner, namely
    + When using the identity operator (===), object variables are identical if and only if they refer to the same instance of the same class.

- Late static bindings 
    + static bindings which can be used to reference the called class in a context of static inheritance. 
    
    + A "forwarding call" is a static one that is introduced by self::, parent::, static::, or, if going up in the class hierarchy, forward_static_call(). The function get_called_class() can be used to retrieve a string with the name of the called class and static:: introduces its scope. 
    
    + This feature was named "late static bindings" with an internal perspective in mind. "Late binding" comes from the fact that static:: will not be resolved using the class where the method is defined but it will rather be computed using runtime information. 
    
    + Static references to the current class like self:: or __CLASS__ are resolved using the class
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();

    + usage in a non-static context, call non-static method in static way. In non-static contexts, the called class will be the class of the object instance. Since $this-> will try to call private methods from the same scope, using static:: may give different results

class A {
    private function foo() {
        echo "success!\n";
    }
    public function test() {
        $this->foo();
        static::foo();
    }
}

class B extends A {
   /* foo() will be copied to B, hence its scope will still be A and
    * the call be successful */
}

class C extends A {
    private function foo() {
        /* original method is replaced; the scope of the new one is C */
    }
}

$b = new B();
$b->test();
$c = new C();
$c->test();   //fails
?>  

The above example will output:

success!
success!
success!

Fatal error:  Call to private method C::foo() from context 'A'

    + forwarding and non-forwarding calls 
class A {
    public static function foo() {
        static::who();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}

class B extends A {
    public static function test() {
        A::foo();
        parent::foo();
        self::foo();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}
class C extends B {
    public static function who() {
        echo __CLASS__."\n";
    }
}

C::test();

- objects and references 
    + When an object is sent by argument, returned or assigned to another variable, the different variables are not aliases: they hold a copy of the identifier, which points to the same object. Same as python 
    
- object serialization, serialize() returns a string containing a byte-stream representation of any value that can be stored in PHP. unserialize() can use this string to recreate the original variable values.

    + If an application is using sessions and uses session_register() to register objects, these objects are serialized automatically at the end of each PHP page
    
    unserialized automatically on each of the following pages, the session_register() is removed since PHP 5.4.0. 
    
    + Beyond the above advice, note that you can also hook into the serialization and unserialization events on an object using the __sleep() and __wakeup() methods. 
  

# Namespace 
- broadest definition namespaces are a way of encapsulating items
- namespace design to solve two problems 
    + name collisons 
    + ability to alias Extra_Long_Names designed to alleviate the first problem 
    
namespace my\name; // see "Defining Namespaces" section

class MyClass {}
function myfunction() {}
const MYCONST = 1;

$a = new MyClass;
$c = new \my\name\MyClass; // see "Global Space" section

$a = strlen('hi'); // see "Using namespaces: fallback to global
                   // function/constant" section

$d = namespace\MYCONST; // see "namespace operator and __NAMESPACE__
                        // constant" section
$d = __NAMESPACE__ . '\MYCONST';
echo constant($d); // see "Namespaces and dynamic language features" section

- define 
    + only the following types of code are affected by namespaces: classes (including abstracts and traits), interfaces, functions and constants. 
namespace MyProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */ }

    + The only code construct allowed before a namespace declaration is the declare statement
<html>
<?php
namespace MyProject; // fatal error - namespace must be the first statement in the script
?> 

- declaring sub-namespaces 
namespace MyProject\Sub\Level;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

- defining multiple namespaces in the same file, this is strongly discouraged 
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace AnotherProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace { // global code
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}

- using namespace, three kinds of aliasing or importing: aliasing a class name, aliasing an interface name, and aliasing a namespace name

namespace foo;
use My\Full\Classname as Another;

// this is the same as use My\Full\NSname as NSname
use My\Full\NSname;

// importing a global class
use ArrayObject;

// importing a function (PHP 5.6+)
use function My\Full\functionName;

// aliasing a function (PHP 5.6+)
use function My\Full\functionName as func;

// importing a constant (PHP 5.6+)
use const My\Full\CONSTANT;
    
$obj = new namespace\Another; // instantiates object of class foo\Another
$obj = new Another; // instantiates object of class My\Full\Classname

    + The use keyword must be declared in the outermost scope

- global space, Without any namespace definition, all class and function definitions are placed into the global space

- using namespaces: fallback to global function/constant

namespace A\B\C;
class Exception extends \Exception {}

$a = new Exception('hi'); // $a is an object of class A\B\C\Exception
$b = new \Exception('hi'); // $b is an object of class Exception

- namespace resolution rules 
    + unqualified name , such as Foo 
    + qualified name  Foo\Bar 
    + fully qualified name \Foo\Bar or \Foo 
    + relative name, identifier starting with namespace, namespace\Foo\Bar 
    
- FAQ 
    
    
# Errors 
- Every error that PHP generates includes a predefined error type 
    + In a development environment, you should always set error_reporting to E_ALL 
    + In production, you may wish to set this to a less verbose level such as E_ALL & ~E_NOTICE & ~E_STRICT & ~E_DEPRECATED
    
    + what php does with error depends on two further php.ini directives. display_errors controls whether the error is shown as part of the script's output. Disable in production 
    
    + log errors when the log_errors directive is enabled
    + control error handling.  If PHP's default error handling is inadequate, you can also handle many types of error with your own custom error handler by installing it with set_error_handler()
    
- Errors in PHP7, most errors are now reported by throwing Error exceptions. Error exceptions will bubble up until they reach the first matching catch block. If there are no matching blocks, then any default exception handler installed with set_exception_handler() will be called

As the Error hierarchy does not inherit from Exception, code that uses catch (Exception $e) { ... } blocks to handle uncaught exceptions in PHP 5 will find that these Errors are not caught by these blocks

    + Error hierarchy 
Throwable 
    \Error 
        \ArithemeticError
            \DivisionByZeroError 
        \AssertionError 
        \ParseError 
        \TypeError 
    \Exception 
        ...
        
- Extending Exceptions, user defined exception class can be defined by extending the built-in exception class 
class Exception
{
    protected $message = 'Unknown exception';   // exception message
    private   $string;                          // __toString cache
    protected $code = 0;                        // user defined exception code
    protected $file;                            // source filename of exception
    protected $line;                            // source line of exception
    private   $trace;                           // backtrace
    private   $previous;                        // previous exception if nested exception

    public function __construct($message = null, $code = 0, Exception $previous = null);

    final private function __clone();           // Inhibits cloning of exceptions.

    final public  function getMessage();        // message of exception
    final public  function getCode();           // code of exception
    final public  function getFile();           // source filename
    final public  function getLine();           // source line
    final public  function getTrace();          // an array of the backtrace()
    final public  function getPrevious();       // previous exception
    final public  function getTraceAsString();  // formatted string of trace

    // Overrideable
    public function __toString();               // formatted string for display
}

/**
 * Define a custom exception class
 */
class MyException extends Exception
{
    // Redefine the exception so message isn't optional
    public function __construct($message, $code = 0, Exception $previous = null) {
        // some code
    
        // make sure everything is assigned properly
        parent::__construct($message, $code, $previous);
    }

    // custom string representation of object
    public function __toString() {
        return __CLASS__ . ": [{$this->code}]: {$this->message}\n";
    }

    public function customFunction() {
        echo "A custom function for this type of exception\n";
    }
}

//use exception 
try {
    $o = new TestException(TestException::THROW_CUSTOM);
} catch (MyException $e) {      // Will be caught
    echo "Caught my exception\n", $e;
    $e->customFunction();
} catch (Exception $e) {        // Skipped
    echo "Caught Default Exception\n", $e;
}
    

# Generators 
- reduce memory and works with foreach 
function xrange($start, $limit, $step = 1) {
    if ($start < $limit) {
        if ($step <= 0) {
            throw new LogicException('Step must be +ve');
        }

        for ($i = $start; $i <= $limit; $i += $step) {
            yield $i;
        }
    } else {
        if ($step >= 0) {
            throw new LogicException('Step must be -ve');
        }

        for ($i = $start; $i >= $limit; $i += $step) {
            yield $i;
        }
    }
}

foreach (xrange(1, 9, 2) as $number) {
    echo "$number ";
}

- Generator syntax
    + yield statement 
    + PHP 7.0, a generator can return values, which can be retrieved using Generator::getReturn(). 
    
function gen_one_to_three() {
    for ($i = 1; $i <= 3; $i++) {
        // Note that $i is preserved between yields.
        yield $i;
    }
}

$generator = gen_one_to_three();
foreach ($generator as $value) {
    echo "$value\n";
}

    + difference between php5 and php7 
$data = (yield $value); 
But this is not, and will result in a parse error in PHP 5: 

$data = yield $value; 
The parenthetical restrictions do not apply in PHP 7. 

    + The syntax for yielding a key/value pair is very similar to that used to define an associative array

$input = <<<'EOF'
1;PHP;Likes dollar signs
2;Python;Likes whitespace
3;Ruby;Likes blocks
EOF;

function input_parser($input) {
    foreach (explode("\n", $input) as $line) {
        $fields = explode(';', $line);
        $id = array_shift($fields);

        yield $id => $fields;
    }
}

foreach (input_parser($input) as $id => $fields) {
    echo "$id:\n";
    echo "    $fields[0]\n";
    echo "    $fields[1]\n";
}

    + Yield can be called without an argument to yield a NULL 

function gen_three_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(gen_three_nulls()));
?>  

The above example will output:
array(3) {
  [0]=>
  NULL
  [1]=>
  NULL
  [2]=>
  NULL
}

    + yield by reference 
function &gen_reference() {
    $value = 3;

    while ($value > 0) {
        yield $value;
    }
}

/*
 * Note that we can change $number within the loop, and
 * because the generator is yielding references, $value
 * within gen_reference() changes.
 */
foreach (gen_reference() as &$number) {
    echo (--$number).'... ';
}

    + In PHP 7, generator delegation allows you to yield values from another generator. Traversable object, or array by using the yield from keyword. The outer generator will then yield all values from the inner generator, object

function from() {
    yield 1; // key 0
    yield 2; // key 1
    yield 3; // key 2
}
function gen() {
    yield 0; // key 0
    yield from from(); // keys 0-2
    yield 4; // key 1
}
// pass 

- comparing generators with iterator objects 
    + The primary advantage of generators is their simplicity. Much less boilerplate code has to be written compared to implementing an Iterator class
    
    + This also means that the same generator can't be iterated over multiple times: the generator will need to be rebuilt by calling the generator function again. 

# Reference explained 
- same variable content by different names, not equal to c pointer. cannot perform pointer arithemetic etc 

The closest analogy is with Unix filenames and files - variable names are directory entries, while variable content is the file itself

- what references do, using references: assigning by reference, passing by reference, and returning by reference. This section will give an introduction to these operations

    + reference global inside function 
$var1 = "Example variable";
$var2 = "";

function global_references($use_globals)
{
    global $var1, $var2;
    if (!$use_globals) {
        $var2 =& $var1; // visible only inside the function
    } else {
        $GLOBALS["var2"] =& $var1; // visible also in global context
    }
}

global_references(false);

    + pass by reference 
function foo(&$var)
{
    $var++;
}

$a=5;
foo($a);
    + return reference 
function &bar()
{
    $a = 5;
    return $a;
}

    + return references, to use return by reference must use reference assignment 
class foo {
    public $value = 42;

    public function &getValue() {
        return $this->value;
    }
}

$obj = new foo;
$myValue = &$obj->getValue(); // $myValue is a reference to $obj->value, which is 42.

- unsetting reference 
unset($a);

- spotting reference, declare a variable as global $var equal to 
<?php
$var =& $GLOBALS["var"];
?> 

    + $this is always a reference to the caller object 
    

# Predefined variables 
- superglobals, built-in variables that are always available 
$GLOBALS, all variable in global 

$_SERVER, an array containing information such as headers, paths, and script locations. The entries in this array are created by the web server.

$_GET

$_POST

$_FILES

$_COOKIE

$_SESSION

$_REQUEST

$_ENV

- cgi specification 
http://www.faqs.org/rfcs/rfc3875.html



# Predefined exceptions 
# Predefined interfaces and classes 
# Context options and parameters 
# Supported protocols and wrappers 
    
    
# Security 
- introduction 
- general considerations 
- installed as cgi binary 
    + possible attacks
    only public files served 
    using cgi.force_redirect 
    setting doc_root or user_dir 
    php parser outside of web tree 
- installed as an apache module 
- session security 
- file system security 
null types related issues 

- database security 
    + designning databases 
    + connecting to database 
    + encrypted storage model 
    + sql injection 
- error reporting 
- using register globals 
- user submitted data 
- magic quotes 
    + what are magic quotes 
    + why did we use magic quotes 
    + why not to use magic quotes 
    + disabling magic quotes 
- hiding php 
- keeping current 

# Features 
- http authentication with php 
- cookies 
- sessions 
- dealing with xforms 
- handling file uploads 
    + post method uploads 
    + error messages explained 
    + common pitfalls 
    + uploading multiple files 
    + PUT method support 
- using remote files 
- connection handling 
- persistent databse connections 
- safe mode 
    + security and safe mode 
    + functions restricted/disabled by safe mode 
- command line usage 
    + introduction 
    + differences t o other SAPIs
    + options 
    + usage 
    + i/o streams 
    + interactive shell 
    + built-in web server 
    + ini settings 
- garbage collection 
    + reference counting basiscs 
    + collecting cycles 
    + performance considerations 
- dtrace dynamic tracing 
    + introduction to php and dtrace 
    + using php and dtrace 
    + using systemTap with php dtrace static probes 


## Function reference 
- affecting php's behaviour
 APC, alternative php cache 
    
APCu, apc user cache 

APD, advanced php debugger 

bcompiler, php byte code compiler 

BLENC, blenc blowfish encoder for php source scripts 

Error Handling, error handling and logging 

htscanner, htaccess like support for all SAPIs 

included, inclusion hierarchy viewer 

Memtrack

OPcache

Output Control, output 

Php options/info 

runkit 

scream, break the silence operator 

uopz 

Weakref, weak reference 

WinCache, windows cache for php 

Xhprof, hierarchical profiler 

- Audio formats manipulation 
ID3 — ID3 Tags
KTaglib
oggvorbis — OGG/Vorbis
OpenAL — OpenAL Audio Bindings

- authentication service 
KADM5 — Kerberos V
Radius

- command line specific extensions 
Ncurses — Ncurses Terminal Screen Control
Newt
Readline — GNU Readline

- compression and archive extensions 
Bzip2
LZF
Phar
Rar — Rar Archiving
Zip
Zlib — Zlib Compression

- credit card processing 
MCVE — MCVE (Monetra) Payment

- cryptograhy extensions 
Crack — Cracklib
CSPRNG
Hash — HASH Message Digest Framework
Mcrypt
Mhash
OpenSSL
Password Hashing

- database extensions 
Abstraction Layers
Vendor Specific Database Extensions

- data and time related extensions 
Calendar
Date/Time — Date and Time
HRTime — High resolution timing

- file system related extensions 
Direct IO
Directories
Fileinfo — File Information
Filesystem
Inotify
Mimetype
Proctitle
xattr
xdiff

- human language and character encoding support 
Enchant — Enchant spelling library
FriBiDi
Gender — Determine gender of firstnames
Gettext
iconv
intl — Internationalization Functions
Multibyte String
Pspell
Recode — GNU Recode

- image processing and generation 
Cairo
Exif — Exchangeable image information
GD — Image Processing and GD
Gmagick
ImageMagick — Image Processing (ImageMagick)

- mail related  extensions 
Cyrus — Cyrus IMAP administration
IMAP — IMAP, POP3 and NNTP
Mail
Mailparse
vpopmail

- mathenmatical extensions 
BC Math — BCMath Arbitrary Precision Mathematics
GMP — GNU Multiple Precision
Lapack
Math — Mathematical Functions
Statistics
Trader — Technical Analysis for Traders

- non-text mime output 
FDF — Forms Data Format
GnuPG — GNU Privacy Guard
haru — Haru PDF
Ming — Ming (flash)
PDF
PS — PostScript document creation
RPM Reader — RPM Header Reading

- process control extensions 
Eio
Ev
Expect
Libevent
PCNTL — Process Control
POSIX
Program execution — System program execution
pthreads
Semaphore — Semaphore, Shared Memory and IPC
Shared Memory
Sync

- other basic extensions 
GeoIP — Geo IP Location
FANN — FANN (Fast Artificial Neural Network)
JSON — JavaScript Object Notation
Judy — Judy Arrays
Lua
Misc. — Miscellaneous Functions
Parsekit
SPL — Standard PHP Library (SPL)
SPL Types — SPL Type Handling
Streams
Tidy
Tokenizer
URLs
V8js — V8 Javascript Engine Integration
Yaml — YAML Data Serialization
Yaf — Yet Another Framework
Taint

- other services 
chdb — Constant hash database
cURL — Client URL Library
Event
FAM — File Alteration Monitor
FTP
Gearman
Gopher — Net Gopher
Gupnp
Hyperwave API
LDAP — Lightweight Directory Access Protocol
Memcache
Memcached
mqseries
Network
RRD — RRDtool
SAM — Simple Asynchronous Messaging
SNMP
Sockets
SSH2 — Secure Shell2
Stomp — Stomp Client
SVM — Support Vector Machine
SVN — Subversion
TCP — TCP Wrappers
Varnish
YAZ
YP/NIS
0MQ messaging — ZMQ
ZooKeeper

- search engine extensions 
mnoGoSearch
Solr — Apache Solr
Sphinx — Sphinx Client
Swish — Swish Indexing

- server specific extensions 
Apache
FastCGI Process Manager
IIS — IIS Administration
NSAPI

- sessions extensions 
Msession — Mohawk Software Session Handler Functions
Sessions — Session Handling
Session PgSQL — PostgreSQL Session Save Handler

- text processing 
BBCode — Bulletin Board Code
PCRE — Regular Expressions (Perl-Compatible)
POSIX Regex — Regular Expression (POSIX Extended)
ssdeep — ssdeep Fuzzy Hashing
Strings

- variable and type related extensions 
Arrays
Classes/Objects — Class/Object Information
Classkit
Ctype — Character type checking
Data Structures
Filter — Data Filtering
Function Handling
Quickhash
Reflection
Variable handling

- web services 
OAuth
SCA
SOAP
Yar — Yet Another RPC Framework
XML-RPC

- window only extensions 
COM — COM and .Net (Windows)
win32ps
win32service

- xml manipulation 
DOM — Document Object Model
libxml
SDO — Service Data Objects
SDO-DAS-Relational — SDO Relational Data Access Service
SDO DAS XML — SDO XML Data Access Service
SimpleXML
WDDX
XMLDiff — XML diff and merge
XML Parser
XMLReader
XMLWriter
XSL

- gui extension 
UI 


## Php at the core:  a hacker's guide 
- reference 
http://php.net/manual/en/internals2.php

## Appendices 
- reference 
http://php.net/manual/en/appendices.php

### Standard php library (SPL)
- reference 
http://php.net/manual/en/book.spl.php

































