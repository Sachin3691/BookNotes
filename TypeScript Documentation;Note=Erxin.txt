TypeScript Documentation;Note=Erxin

# Reference 
http://www.typescriptlang.org/docs/handbook/basic-types.html

# Setup vscode development environment 
- vscode type script document 
https://code.visualstudio.com/docs/languages/typescript

- typescript support operate in two different mode 
    + file scope, there is no common project context between two files 
    + explicit project, define via tsconfig.json 
    Find all references (Shift + F12) consider project scope only 
- tsconfig.json 
    + reference 
    https://www.typescriptlang.org/docs/handbook/tsconfig-json.html
    
        * using tsconfig.json 
        invoking tsc with no input files, compiler searches for tsconfig.json 
        
        * invoking tsc wih no input files and a --project (or just -p) command line option that specifies the path of directory containing a tsconfig.json 
    
        * when files specified on command line, tsconfig.json is ignore 
        
        * example 
{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "sourceMap": true
    },
    "files": [
        "core.ts",
    ]
}
compilerOptions can be ignore, reference 
https://www.typescriptlang.org/docs/handbook/compiler-options.html

files property support glob style matching, *, ?, **/ recursive matches any subdirectory
wildcard match * only match supported type (.ts, .d.ts, .tsx)

using include, exclude instead of files, "exclude". The "exclude" property defaults to excluding the node_modules, bower_components, jspm_packages and <outDir> directories when not specified
"include": [
        "src/**/*"
    ],
"exclude": [
    "node_modules",
    "**/*.spec.ts"
]
        * configuration ineritance with extends, extends value is a string point to another configuration file 
{
  "extends": "./configs/base",
  "files": [
    "main.ts",
    "supplemental.ts"
  ]
}

        * schema reference 
        http://json.schemastore.org/tsconfig
        
        * compiler options for MSBuild 
        https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html

- create task.json for gulp with Ctrl+Shift+P, type in 'configuration task runner' press 'enter' to select 'gulp'

tasks.json will be created under .vscode folder 

use ctrl+space to see intelliSense 

{
	// See https://go.microsoft.com/fwlink/?LinkId=733558
	// for the documentation about the tasks.json format
	"version": "0.1.0",
	"command": "tsc",
	"isShellCommand": true,
	"args": ["-p", "."],
	"showOutput": "silent",
	"problemMatcher": "$tsc"
}

- install typescript compiler and run build task by Ctrl+Shift+B (Run Build Task) 
$ npm install -g typescript 
$ npm install -g gulp-cli 
$ npm install gulp --D 

- check build issue from output window (Ctrl+Shift+U)
- Goto symbol & show all symbols 
Ctrl+Shift+0, list all defined symbols of the current open TypeScript and lets you navigate in it 
Ctrl+T, lets you search all symbols defined in the current project or file scope 

- format code 
Shift+Alt+F, formats document 
Ctrl+K Ctrl+F, formats current selected 

- JSDoc support 
type /** auto insert closing */ pressing enter inside a JSDoc 

- javascript source map support , in project's launch.json you can specify a typescript file with the program attribute 

- setting a different outFiles for generated files 
if transpiled javascript doesn't live next to their source, you can help VS code by setting the outFiles attribute with glob pattern 

- hiding derived javascript files, don't see generated javascript file in explorer or search results 
File> Preferences> Settings, you can create an expression to hide those derived files 
"**/*.js":{"when":"$(basename).ts"}

"**/*.js": { "when": "$(basename).ts" },
"**/**.js": { "when": "$(basename).tsx" }

- mixed typescript and javascript projects 
    + set allowJs property to true in the tsconfig.json 
    tsc compiler does not detect the presence of a jsconfig.json file automatically. use -p parameter to make tsc use your jsconfig.json 
    
- using newer typescript version, active version is displayed at the status bar 

- enable codelens, display an inline count of reference for classes interfaces methods, etc by change setting 

"typescript.referencesCodeLens.enabled": true.

# Basic types 
- boolean 
let isDone:boolean = false; 

- number 
let decimal:number = 6;
let hex:number = 0xf0d;

- string 
let color:string = 'blue';

- array 
let list:number[] = [1,3,4];

- tuple 
let x:[string,number]; 
x = ["hello", 10];

- enum 
enum Color {red, green, blue};
let c:Color = Color.green;

- any, values come from dynamic context 
let notSure:any = 4; 

difference between Object, But variables of type Object only allow you to assign any value to them - you can’t call arbitrary methods on them, even ones that actually exist

let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.

any also fit for array mixed with different types 
let list:any[];

- void, like the opposite of any, the absence of having any type at all. commonly see as the return type of functions 

define variable of void is not usefuly because you can only assigin undefined or null to them 

- null and undefined have their own types named undefined and null 
let u:undefined = undefined; 
let n:null = null; 

not much usefuly like void 

by default these types are sub types of other types which means you can assign undefined or null to other types like number 

However, when using the --strictNullChecks flag, null and undefined are only assignable to void and their respective types. you can use the union type string | null | undefined

- never, represents the type of values that never occur. mark a function return never then any type return from function will throw exception 

never type is subtype of assignable to every type 

// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error("Something failed");
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}

- type assertions, it like a cast in other languages but perform no special checkings or restructuring of data 

let someValue: any = 'this is a string';
let strLength: number = (<string>someValue).length;

other syntax is 
let strLength:number = (someValue as string).length;



# Variable declarations 
- declarations 
let and const are two relative new types of variables
var define didn't matter how many times you declared your variables you just like declare it once 

let is block scoping. let declarations have drastically different behavior when declared as part of a loop. these declarations sort of create a new scope per iteration.

const variable still modifiable for its internal state. for this kinds of issue typescript provide a readonly type

- array destructuring, similar to python 
let input = [1,2];
let [first, second] = input;

- object destructuring 
let o = {a:1, b:2};
let {c, d} = o;

also support remaining items with ... 
let {a, ...restItems} = o;

assign new name to the variable 
let { a: newName1, b: newName2 } = o;

assign default value 
let {a, b = 100} = o;

- destruturing in function declarations 
type C = { a: string, b?: number }
function f({ a, b }: C): void {
    // ...
}

- spread operator, ... 
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { ...defaults, food: "rich" };

    + Object spread also has a couple of other surprising limits. First, it only includes own, enumerable properties. Basically, that means you lose methods when you spread instances of an object:
    
class C {
  p = 12;
  m() {
  }
}
let c = new C();
let clone = { ...c };
clone.p; // ok
clone.m(); // error!


# Interfaces 
- introduction,  type-checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural subtyping”. 

interface LabelledValue {
    label: string;
}

function printLabel(labelledObj: LabelledValue) {
    console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);

- optional properties 
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    ...
}

let mySquare = createSquare({color: "black"});

- readonly property, some property should only be modifiable when an object is first created 
interface Point {
    readonly x: number;
    readonly y: number;
}

let p1:Point = {x: 10, y: 20};
p1.x = 5; //error 

- readonly and const 

The easiest way to remember whether to use readonly or const is to ask whether you’re using it on a variable or a property. Variables use const whereas properties use readonly.

interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}

- function types interface 
interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    let result = source.search(subString);
    return result > -1;
}

- indexable types 
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];

There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer.
class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// Error: indexing with a 'string' will sometimes get you a Dog!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}

interface NumberDictionary {
    [index: string]: number;
    length: number;    // ok, length is a number
    name: string;      // error, the type of 'name' is not a subtype of the indexer
}

make index signature readonly 
interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!

- class types, implementing an interface 
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}

- difference between the static and intance sides of classes 
 a class has two types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:
 interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}  //error  a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.
 
Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, ClockConstructor for the constructor and ClockInterface for the instance methods. Then for convenience we define a constructor function createClock that creates instances of the type that is passed to it.
interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick();
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);

- extending interfaces, like inherit in classes, support extend multiple interfaces 
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;

- hybrid types,  an object that works as a combination of some of the types described above. such as both a function and a object 
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;

- interfaces extending classes, When an interface type extends a class type it inherits the members of the class but not their implementations. When you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.


# Classes 
- Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach

- example, Derived classes that contain constructor functions must call super() which will execute the constructor function on the base class.
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);

- the property is public by default in typescript 
- When a member is marked private/protected, it cannot be accessed from outside of its containing class. For example
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // Error: 'name' is private;

- Readonly properties must be initialized at their declaration or in the constructor 
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs");
dad.name = "Man with the 3-piece suit"; // error! name is readonly

- parameter properties let you create and initialize a member in one place. accessors require you to set the compiler to output ECMAScript 5 or higher. Downlevelling to ECMAScript 3 is not supported.

class Octopus {
    readonly numberOfLegs: number = 8;
    constructor(readonly name: string) {
    }
    
    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}

- static property 
class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

- abstract classes, Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. 
abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log("roaming the earth...");
    }
}


# Functions 


































































