C++ 20 Quyick Syntax Reference=Mikael;Note=Erxin

# Environment 
- visual studio 2019 

# Compile and run 
- reference 
http://www.stroustrup.com/compilers.html

Apple C++. Xcode. It also comes with OS X on the developer tools CD.
Bloodshed Dev-C++. A GCC-based (Mingw) IDE.
Clang C++. A relatively very active development associated with the analysis and code generation framework, LLVM.
Cygwin (GNU C++)
Mentor Graphics - Lite edition. Sourcery CodeBench.
MINGW - "Minimalist GNU for Windows". Another GCC version for Windows including a free (non-GPL) w32api.
GNU CC source
IBM C++ for IBM power, System Z, Bluegene, and Cell.
Intel C++ and many supporting tool
Microsoft Visual C++.
Oracle C++. 

- gnu compiler 

g++ MyApp.cpp -o MyApp
./MyApp
Hello World

- msvc 


# Variable 
- data types 
    + primitive The sizes shown in the previous table are found on most 32-bit systems and are given in C++ byte
    type        size        
    char        1 
    short       2
    int         4 
    long        4 or 8 
    long long   8 
    float       4
    double      8 
    long double 8 or 16 
    bool        1

    + the int type will be 32 bits in size on 32-bit and 64-bit systems. Each integer type in the table must be at least as large as the one preceding it. 


    + declare variable 
int myInt;  // correct
int 32Int;  // incorrect (starts with number)
int Int 32; // incorrect (contains space)
int Int@32; // incorrect (contains special character)
int new;    // incorrect (reserved keyword)

    + variable scope, global variable is declared outside of any code blocks and is accessible from anywhere after it has been declared. 

int globalVar; // global variable will automatic init to 0
int main() { int localVar; } // local variable will not be inited 

cout << sizeof(myChar)  // 1 byte (per definition)
     << sizeof(myShort) // 2
     << sizeof(myInt)   // 4
     << sizeof(myLong)  // 4
     << sizeof(myL2);   // 8

//cpp11
#include <cstdint>
using namespace std;
int8_t myInt8 = 0;   // 8 bits
int16_t myInt16 = 0; // 16 bits
int32_t myInt32 = 0; // 32 bits
int64_t myInt64 = 0; // 64 bits

- numeric literals 
int myOct = 062;  // octal notation (0)
int myHex = 0x32; // hexadecimal notation (0x)
int myBin = 0b0011'0010; // binary notation (0b)

- floating point types, A float can accurately represent about 7 digits, whereas a double can handle around 15. 
float myFloat;    // ~7 digits
double myDouble;  // ~15 digits
long double myLD; // typically same as double
myFloat = 12345.678; // rounded to 12345.68

    +  C++17, the base may be specified as a hexadecimal value using the 0x prefix. For such a number, the exponent part may use p instead of e to have the significant be scaled to the power of 2
myFloat = 0xFp2; // 15*2^2 = 60

- literal suffixe, C++11 also added the LL suffix for the long long type. The order and casing of these letters do not matter.
 
int i = 10;
long l = 10L;
unsigned long ul = 10UL;
float f = 1.23F;
double d = 1.23;
long double ld = 1.23L;

float f = 1.23F;
double d = 1.23;
long double ld = 1.23L;

- char type 
char c = 'x'; // assigns 120 (ASCII for 'x')

//added in C++17 and denotes the UTF-8 (Unicode) encoding
char ascii = u8'x'; // use UTF-8 encoding

// Prints 'x'
cout << static_cast<char>(i); // C++ new-style cast
cout << (char)i; // C-style cast

UTF-16 and UTF-32 encodings can be represented using the char16_t and char32_t types, respectively, which were added in C++11. For completeness, C++20 added the char8_t type as well. The prefix U denotes a UTF-32 character and the u prefix a UTF-16 character.

- bool type 
bool b = false;
int i = false; // 0
int j = true; // 1
bool b = static_cast<bool>(32); // true


# Operators 
- arithmetic operators 
int i = 3 + 2; // 5, addition
    i = 3 - 2; // 1, subtraction
    i = 3 * 2; // 6, multiplication
    i = 3 / 2; // 1, division
    i = 3 % 2; // 1, modulus (division remainder)

float f1 = 3 / 2.0f; // specify as floating-point number
float f2 = 3 / static_cast<float>(2); // C++ new-style cast
float f3 = 3 / (float)2; // C-style cast

i += 5; // i = i+5;
i -= 5; // i = i-5;
i *= 5; // i = i*5;
i /= 5; // i = i/5;
i %= 5; // i = i%5;

int x, y;
x = 5; y = x++; // y=5, x=6
x = 5; y = ++x; // y=6, x=6

- comparison operators 

bool b = (2 == 3); // equal to (false)
     b = (2 != 3); // not equal to (true)
     b = (2 > 3);  // greater than (false)
     b = (2 < 3);  // less than (true)
     b = (2 >= 3); // greater than or equal to (false)
     b = (2 <= 3); // less than or equal to (true)

- logic operators 
bool b = (true && false); // logical and (false)
b = (true || false);      // logical or (true)
     b = !(true);         // logical not (false)
     
- bitwise operators 
int i = 5 & 4;  // 101 & 100 = 100 (4)       // and
i = 5 | 4;      // 101 | 100 = 101 (5)       // or
i = 5 ^ 4;      // 101 ^ 100 = 001 (1)       // xor
i = 4 << 1;     // 100 << 1  =1000 (8)       // left shift
i = 4 >> 1;     // 100 >> 1  =  10 (2)       // right shift
i = ~4;         // ~00000100 = 11111011 (-5) // invert

int i=5; i &= 4; // 101 & 100 = 100 (4) // and
    i=5; i |= 4; // 101 | 100 = 101 (5) // or
    i=5; i ^= 4; // 101 ^ 100 = 001 (1) // xor
    i=5; i <<= 1;// 101 << 1  =1010 (10)// left shift
    i=5; i >>= 1;// 101 >> 1  =  10 (2) // right shift

- operator precedence 
::
() [] . -> x++ x--
!~ ++x --x *x &x (type) sizeof co_await new new[] delete delete[]
.* ->*
*/%
+-
<< >>
< = > 
< <= > >=
== != 
& 
^
| 
&& 
|| 
?: = op = throw co_yield 
,


# Pointers 
- asterisk (*) is placed between the data type and the pointer’s name. The data type used determines what type of memory it will point to

int* p; // pointer to an integer
int *q; // alternative syntax
int *a, *b, *c; // multiple pointers

int i = 10;
p = &i; // address of i assigned to p

int* p2 = p; // copy of p (copies address stored in p)

-  dereference operator (*), To obtain the actual value stored in that address, the pointer must be prefixed with an asterisk, known as the dereference operator (*) .


#include <iostream>
using namespace std;
int main()
{
  int i = 10;
  int* p = &i;
  cout << "Address of i: " << p << endl; // ex. 0017FF1C
  cout << "Value of i: " << *p << endl; // 10
}

- point to another pointer 
int** r = &p; // pointer to p (assigns address of p)

cout << "Address of p: " << r << endl; // ex. 0017FF28
cout << "Address of i: " << *r << endl; // ex. 0017FF1C
cout << "Value of i: "   << **r << endl; // 20

- dynamic allocation, One of the main usages of pointers is to allocate memory during runtime—so-called dynamic allocation 

int* d = new int; // dynamic allocation

that memory will stay allocated until the program shuts down.

delete d; // release allocated memory

- null pointer 
int* g = 0; // null pointer (unused pointer)
int* h = NULL; // null pointer

C++11 introduced the now preferred keyword nullptr to specify a null pointer, in order to distinguish between zero and a null pointer.

nullptr will not implicitly convert to an integer type. The literal has its own type, std::nullptr_t, which can only be implicitly converted to pointer and bool types.
 
#include <iostream> // include nullptr_t type
int main()
{
  int* p = nullptr; // ok
  int i = nullptr; // error
  bool b = (bool) nullptr; // false
  std::nullptr_t mynull = nullptr; // ok
}

Note that trying to delete an already deleted null pointer is safe. However, if the pointer has not been set to null, attempting to delete it again will cause memory corruption and possibly crash the program.


int* m = new int; // allocate memory for object
delete m; // deallocate memory
*m = 5; // error: write access violation
delete m;
m = nullptr; // mark as null pointer
delete m; // safe
if (m != nullptr) { *m = 5; } // check for valid pointer
if (m) { *m = 5; } // alternative


# References 
- create new names for a variable. should be used in favor of pointers whenever possible.
- create 

int x = 5;
int& r = x; // r is an alias to x
int &s = x; // alternative syntax
int& t; // error: must be initialized

//become an alias for the variable and can be used exactly as though it were the original variable

r = 10; // assigns value to r/x

A reference is similar to a pointer that always points to the same thing. reference is only an alias and does not have an address of its own

int* ptr = &r; // ptr assigned address to x

- a reference is safer than a pointer since it must always refer to something. This means that there is no need to check if a reference refers to null

int* ptr = nullptr; // null pointer
int& ref = *ptr;
ref = 10; // error: invalid memory access

- rvalue reference, With C++11 came a new kind of reference called an rvalue reference. This reference can bind and modify temporary objects (rvalues), such as literal values and function return values. 

int&& ref = 1 + 2; // rvalue reference

ref += 3;
cout << ref; // "6"


# Array 
- declare 
int myArray[3]; // integer array with 3 elements

- assign 
myArray[0] = 1;
myArray[1] = 2;
myArray[2] = 3;

int myArray[3] = { 1, 2, 3 };
int myArray[] = { 1, 2, 3 };

int myArray[2][2] = { { 0, 1 }, { 2, 3 } };
myArray[0][0] = 0;
myArray[0][1] = 1;
int myArray[2][2] = { 0, 1, 2, 3 }; // alternative

- dynamic arrays 
int* p = new int[3]; // dynamically allocated array

//change pointer's address are implicityly multiplied by the size of the pionter's data type 
*(p+1) = 10; // p[1] = 10;

- array size 
int myArray[2] = { 1, 2 };
myArray[2] = 3; // error: out of bounds

int length = std::size(myArray); // 2

//The only way to determine the size of such an dyanmic array is through the variable used in its allocation.
int size = 3;
int* p = new int[size]; // dynamically allocated array
delete[] p; // release allocated array
p = nullptr; // mark pointer as unused

- vector, template class, Vectors will also implicitly deallocate themselves when they go out of scope, so there is no need to manually delete them. preferable to dynamic arrays as they have a number of advantages including the ability to grow and shrink automatically as needed. 

#include <vector> // std::vector
using namespace std;
int main()
{
  vector<int> myVector;
}

#include <vector>
using namespace std;
int main()
{
  vector<int> v;
  // Assign three elements with value two
  v.assign(3, 2); // [2, 2, 2]
  // Add 4 at last position
  v.push_back(4); // [2, 2, 2, 4]
  // Change first element
  v[0] = 1; // [1, 2, 2, 4]
  // Change second element (bound checked)
  v.at(2) = 3; // [1, 2, 3, 4]
  // Remove second element
  v.erase(v.begin()+1); // [1, 3, 4]
  // Remove last element
  v.pop_back(); // [1, 3]
  // Get vector length
  int len = v.size(); // 2
  // Print first and second elements
  cout << v.at(0) << v[1]; // "13"
}


# Strings
- store string values 

#include <string>
using namespace std;

string h = "Hello";
string w ("Hi"); // direct initialization
string u {"Hey"}; // uniform initialization

- string combining 
string a = "Hello";
string b = "World";
string c = a + " " + b; // Hello World
a += b; // HelloWorld

- string literal to instead represent it as the std::string type 

string d = "Hello" + "World"; // error, no C++ string
string e = "Hello" + "World"s; // ok
string f = e + "Again"; // ok

- escape characters 
string s = "Hello\nWorld";

\n
\t
\v, vertical tab 
\b, backspace 
\r, charriage return 
\0, null character 
\f, form feed 
\a, alert sound 
\", double quote 
\\, backslash 

string oct = "\053"; // octal '+'
string hex = "\x02B"; // hexadecimal '+'

//c++11 esacpe character can be ignored by adding an R before the string 
string escaped = "c:\\Windows\\System32\\cmd.exe";
string raw = R"(c:\Windows\System32\cmd.exe)";

- string compare 
string s = "Hello";
bool b = (s == "Hello"); // true

- string functions 
string s = "Hello";
size_t i = s.length(); // 5, length of string
i = s.size(); // 5, same as length()

s.substr(0,2); // "He"

- string encodings,  wchar_t is provided. Its size can vary between compilers so it is not platform independent. String literals of this type are created by prepending the string with a capital L. The resulting array can be stored using the wstring class.

wstring s1 = L"Hello";
wchar_t *s2 = L"Hello"; // C-style string

// C++11, namely, char16_t and char32_t. These types provide definite representations of the UTF-16 and UTF-32 encodings.  A string consisting of UTF-8 literals can be stored in the u8string type added in C++20.

string s3 = "Compiler-defined encoding";
u8string s4 = u8"UTF-8 string";
u16string s5 = u"UTF-16 string";
u32string s6 = U"UTF-32 string";

//adding special character in utf string with escape character 
u8string s7 = u8"Asterisk: \u002A"; // "Asterisk: *"

- string formatting, C++20 introduced the std::format function as a more convenient and type-safe way to format strings compare to printf 

// "1 plus 2 equals 3"
string f = std::format("1 plus 2 equals {}", 1+2);

// "5 is more than zero"
string f = std::format("{1} is more than {0}", "zero", 5);


# Conditionals 
- if statement 
if (x < 1)
  cout << x << " < 1";
else if (x > 1)
  cout << x << " > 1";
else
  cout << x << " == 1";
  
- switch 
switch (x)
{
  case 0: cout << x << " is 0"; break;
  case 1: cout << x << " is 1"; break;
  default: cout << x << " is not 0 or 1"; break;
}

- ternary operator 

x = (x < 0.5) ? 0 : 1; // ternary operator (?:)

- initializers, c++ 17 support to declare and initialize a locally scoped variable 

int a = 2, b = 3;
// ...
if (int sum = a+b; sum == 5) {
  cout << sum << " is 5";
}

switch (int sum = a+b; sum) {
  case 5: cout << sum << " is 5"; break;
}


# Loops 
- while loop 
int i = 0;
while (i < 10) {
  cout << i++; // 0-9
}

- do while loop 
int j = 0;
do {
  cout << j++; // 0-9
} while (j < 10);

- for loop 
for (int k = 0, m = 0; k < 5; ++k, m--) {
  cout << k+m; // "00000"
}

for (int k = 0, m = 0; k < 5; ++k, m--) {
  cout << k+m; // "00000"
}

for (;;) {
  // infinite loop
}
for (int i=0; i<10; ) {
  // increment i inside of loop
}
int counter = 0;
for (; counter<10; ++counter) {
  // ...
}
// make counter usable outside of loop


//c++11 introduced a ranged based for loop syntax 
int a[3] = {1, 2, 3};
for (int &i : a) {
  cout << i; // "123"
}


//C++20 extended the range-based for loop by allowing it to include an initializer. 
for (int a[3] = {1, 2, 3}; int &i : a) {
  cout << i; // "123"
}

- break and contiue 
for (int i = 0; i < 10; i++)
{
  if (i == 5) break; // end loop
  if (i == 3) continue; // start next iteration
  cout << i; // "0124"
}

- goto, uncondition jump 

goto myLabel; // jump to label
myLabel: // label declaration


# Function 
- defining functions 

#include <iostream>
using namespace std;
void myFunction()
{
  cout << "Hello World";
}

- calling functions 

int main()
{
  myFunction(); // "Hello World"
}

- function parameters 

void myFunction(string a, string b)
{
  cout << a << " " << b;
}
myFunction("Hello", "World"); // "Hello World"

- default parameter values 

void myFunction(string a, string b = "Earth")
{
  cout << a << " " << b;
}

- function overloading, a function can be defined multiple times with different parameters 

void myFunction(string a, string b) { cout << a << " " << b; }
void myFunction(string a) { cout << a; }
void myFunction(int a) { cout << a; }

- return statement 

int getSum(int a, int b)
{
  return a + b;
}

void dummy() { return; }

- forward declaration

void myFunction(int a); // prototype
int main()
{
  myFunction(0);
}
void myFunction(int a) {} // definition

- pass by value, primitive and object data types by default pass by value 

#include <iostream>
#include <vector>
using namespace std;
void change(int i) { i = 10; }
void change(vector<int> a) { a.at(0) = 5; }
int main()
{
  int x = 0; // value type
  change(x); // copy of x is passed
  cout << x; // "0"
  vector<int> v { 3 }; // reference type
  change(v); // object copy is passed
  cout << v.at(0); // "3"
}

- pass by reference, both primitive and object data types can be changed, and the changes will affect the original variable.


void change(intxs& i) { i = 10; }
int main()
{
  int x = 0; // value type
  change(x); // reference is passed
  cout << x; // "10"
}

- pass by address, arguments may also be passed by address using pointers. 
void change(int* i) { *i = 10; }
int main()
{
  int x = 0;  // value type
  change(&x); // address is passed
  cout << x;  // 10
}

- return by value, reference or address 

int byVal(int i) { return i + 1; }
int main()
{
  int a = 10;
  cout << byVal(a); // "11"
}

//Instead, return by reference is commonly used to return an argument that has also been passed to the function by reference.
int& byRef(int& i) { return i; }
int main()
{
  int a = 10;
  cout << byRef(a); // "10"
}

int* byAdr(int* i) { return i; }
int main()
{
  int a = 10;
  cout << *byAdr(&a); // "10"
}

- inline function is a recommendation, the compiler will optimiz the code 

inline int myInc(int i) { return ++i; }

- auto and decltype for type deduction during compilation 

auto i = 5;     // int
auto d = 3.14;  // double
auto b = false; // bool

//The auto keyword works as a placeholder for a type and instructs the compiler to automatically deduce the type of the variable based on its initializer. The auto keyword translates to the core type of the initializer, which means that any reference and constant specifiers are dropped

const int& iRef = i;
auto myAuto = iRef; // int
const auto& myRef = iRef; // const int&

//two ampersands can be used. This normally designates an rvalue reference, but in the case of auto, it makes the compiler automatically deduce either an rvalue or an lvalue reference
int i = 1;
auto&& a = i; // int& (lvalue reference)
auto&& b = 2; // int&& (rvalue reference)

//used in for loop iterator in C++11
#include <iostream>
#include <vector>
using namespace std;
// ...
vector<int> myVector { 1, 2, 3 };
for (auto& x : myVector) { cout << x; } // "123"

//before C++11 
for(vector<int>::size_type i = 0; i != myVector.size(); i++) {
    cout << myVector[i]; // "123"
}

    + The decltype specifier works similar to auto, except that it deduces the exact declared type of a given expression, including references.

int i = 1;
int& myRef = i;
auto a = myRef; // int
decltype(myRef) b = myRef; // int&


//c++14 support used auto with decltype
decltype(auto) c = myRef; // int&

//decltype is often used to forward function return typoes without having to consider whether it is a reference or value type 
decltype(5) getFive() { return 5; } // int

//C++11 added a trailing return type syntax, which allows a function’s return value to be specified after the parameter list following an arrow (->). The use of auto in this context just means that the trailing return type syntax is being used.
auto getValue(int x) -> decltype(x) { return x; } // int

//The ability to use auto for return type deduction was added in C++14. This enabled the core return type to be deduced directly
auto getValue(int x) { return x; } // int

//auto may used together with decltype This is mainly useful in the context of generic programming with templates, when there are types that are not known until runtime.
decltype(auto) getRef(int& x) { return x; } // int&

- returning multiple values with tuple. Tuples are objects that pack elements of different types into a single object

#include <tuple>
#include <iostream>
using namespace std;
tuple<int, double, char> getTuple()
{
  return tuple<int, double, char>(5, 1.2, 'b');
}

auto getTuple()
{
  return make_tuple(5, 1.2, 'b');
}

//Individual tuple elements can be extracted with the std::get function 
int main()
{
  auto mytuple = getTuple();
  cout << get<0>(mytuple) // "5"
       << get<char>(mytuple); // "b"
}

//unpack a tuple is with the std::tie function , which will bind one or more tuple elements to the provided arguments. The std::ignore placeholder can be used to skip certain elements of the tuple.
int main()
{
  int i;
  double d;
  // Unpack tuple into variables
  tie(i, d, ignore) = getTuple();
  cout << i << " " << d; // "5 1.2"
}

// structured bindings was added in C++17 to simplified unpacked process 
int main()
{
  auto [i, d, c] = getTuple();
  cout << i; // "5"
}

- lambda functions, C++11 adds the ability to create lambda functions, which are unnamed function objects.

auto sum = [](int x, int y) -> int
{
  return x + y;
};
cout << sum(2, 3); // "5"

//C++14 extended return type deduction to any lambda function. The arrow (->) is omitted
auto sum = [](int x, int y) { return x + y; };
auto sum = [](auto x, auto y) { return x + y; };

//lambda often by passing the function object as an argument to another function. T
#include <iostream>
#include <functional>
using namespace std;

void call(int arg, function<void(int)> func) {
    func(arg);
}

int main() {
    auto printSquare = [](int x) { cout << x*x; };
    call(2, printSquare); // "4"
}

    + lambda support capture clause. 
//by default variable is capture by value 
void call(function<void()> func) { func(); }
int main() {
    int i = 2;
    auto printSquare = [i]() { cout << i*i; };
    call(printSquare); // "4"
}

//make lambda capture by reference 
int a = 1;
[&a](int x) { a += x; }(2);
cout << a; // "3"

//the variable captured by value is constant, add mutable specifier can allow variable to be modified 
int a = 1, b = 1;
[&, b]() mutable { b++; a += b; }();
cout << a << b; // "31"

//C++14 support, variable can be initialized inside the lambda capture clause without need to the mutable specifier. the parameter list following the capture clause may be omitted
int a = 1;
[&, b = 2] { a += b; }();
cout << a; // "3"

    + A [=] means that such variables are captured by value and [&] captures them by reference.

    + stateless, a lambda does not capture any variables, added in C++20 
auto x = [] { return 3; };

// Default construct new lambda of same type
decltype(x) y;  // valid in C++20

// Make copy of lambda
auto copy = x;

// Assign copy to x since they have same type
x = copy; // valid in C++20

// Default construct inlined lambda
decltype([]{ return 3; }) a; // valid in C++20


# Classes 
- A class is a template used to create objects. the two main kinds are fields and methods. Fields are variables and they hold the state of the object. Methods are functions

class MyRectangle
{
  int x, y;
};

class MyRectangle
{
  int x, y;
  int getArea();
};
int MyRectangle::getArea() { return x * y; }

- inline member function 
inline int MyRectangle::getArea() { return x * y; }

//other way is define the method inside of the class will implicit the compiler inline compile the method 
class MyRectangle
{
  int x, y;
  int getArea() { return x * y; }
};

- object creation 

int main()
{
  MyRectangle r; // object creation
}

- accessing object members, by default members have private access right 

class MyRectangle
{
 public:
  int x, y;
  int getArea() { return x * y; }
};

r.x = 10;
r.y = 5;
int z = r.getArea(); // 50 (5*10)

//When using an object pointer, the arrow operator (->) allows access to the object’s members. 
MyRectangle r;
MyRectangle *p = &r; // object pointer
r.x = 2;
r.y = 3;
p->getArea(); // 6 (2*3)
(*p).getArea(); // alternative syntaxf

- forward declaration, a class prototype can be specified above the reference instead allows the class to be referenced in any context that does not require the class to be fully defined. we still cannot create an object of a class before it has been defined

class MyClass; // class prototype

class MyClass; // class prototype
// ...
MyClass* p; // allowed
MyClass f(MyClass&); // allowed
MyClass o; // error, definition required
sizeof(MyClass); // error, definition required


# Constructors 
- a special method always have the same name of the class and does not have a return type

class MyRectangle
{
 public:
  int x, y;
  MyRectangle();
};
MyRectangle::MyRectangle() { x = 10; y = 5; }

int main()
{
  MyRectangle s;
}

- overloading 
class MyRectangle
{
 public:
  int x, y;
  MyRectangle();
  MyRectangle(int, int);
};
MyRectangle::MyRectangle() { x = 10; y = 5; }
MyRectangle::MyRectangle(int a, int b) { x = a; y = b; }

// Calls parameterless constructor
MyRectangle r;
// Calls constructor accepting two integers
MyRectangle t(2,3);

- this keyword, instance methods a special keyword called this can be used. 

MyRectangle::MyRectangle(int x, int y)
{
  this->x = x;
  this->y = y;
}

- field initialization, alternative to assign the field in the constructor, we can init them in the constructor initializer list 

MyRectangle::MyRectangle(int a, int b) : x(a), y(b) {}

//assigned an initial value in their class definition, a convenient feature that was added in C++11
class MyRectangle
{
 public:
  int x = 10;
  int y = 5;
};

//a reference field cannot be set in the body of the constructor, but must be initilized either in the class definition or in the initializer list 
class Foo
{
 public:
  int x;
  int& ref1 = x;
  int& ref2;
  Foo();
};
Foo::Foo() : ref2(x) {}

- default constructors, fields in C++ are not automatically initialized to their default values 
- destructor, a class may only have one destructor 

class Semaphore
{
    bool *sem;
public:
    Semaphore()  { sem = new bool; }
    ~Semaphore() { delete sem; }
};

- special member functions, Four other special functions are the move constructor, the move assignment operator, the copy constructor, and the copy assignment operator. 

With the C++11 standard came ways of controlling whether to allow these special member functions through the delete and default specifiers. 

The delete specifier forbids the calling of a function, whereas the default specifier explicitly states that the compiler-generated default will be used.

class A
{
 public:
  // Explicitly include default constructor
  A() = default;
  
  // Explicitly include default destructor
  ~A() = default;
  
  // Disable move constructor
  A(A&&) noexcept = delete;
  
  // Disable move assignment operator
  A& operator=(A&&) noexcept = delete;
  
  // Disable copy constructor
  A(const A&) = delete;
  
  // Disable copy assignment operator
  A& operator=(const A&) = delete;
};

- object initialization 

class MyClass
{
 public:
  int i;
  MyClass() = default;
  MyClass(int x) : i(x) {}
};

    + direct initialization, include a set of parentheses that are used to pass arguments to a constructor in the class. If the parameterless constructor is used, the parentheses are left off.

// Direct initialization
MyClass a(5);
MyClass b;

    + value initialization, A value initialization creates only a temporary object, which is destroyed at the end of the statement. To preserve the object, it must either be copied to another object or assigned to a reference.
    
    A value-initialized object is almost identical to one created by using default initialization. A minor difference is that non-static fields will in some cases be initialized to their default values when using value initialization.
    
// Value initialization
const MyClass& a = MyClass();
MyClass&& b = MyClass(); // alternative

    + copy initialization, because of the implicit copy constructor that the compiler provides, which is called for these kinds of assignments. it is different compare to Java or C#. It allowing developer to define copy constructor to define how the members should be copied 
    
// Copy initialization
MyClass a = MyClass(); // copy temporary object to a
MyClass b = a; // copy object a to b

    + new initialization, Dynamically allocated memory must be used through a pointer or reference. the object must be explicitly deleted 
// New initialization
MyClass* a = new MyClass(); // object pointer
MyClass& b = *new MyClass(); // object reference
// ...
delete a;
delete &b;

    + aggregate initialization, This syntax allows fields to be set by using a curly bracket–enclosed list of initializers. Aggregate initialization can only be used when the class type does not include any constructors, virtual functions, or base classes. The fields must also be public, unless they are declared as static. Each field will be set in the order they appear in the class.

// Aggregate initialization
MyClass a = { 2 }; // i is 2

    + uniform initialization, The uniform initialization was introduced in C++11 to provide a consistent way to initialize types that work the same for any type. The syntax looks the same as aggregate initialization, without the use of the equals sign.
    
    This initialization syntax works not just for classes but for any type, including primitives, strings, arrays, and standard library containers such as vector.


// Uniform initialization
MyClass a { 3 }; // i is 3


#include <string>
#include <vector>
using namespace std;
int main()
{
  int i { 1 };
  string s { "Hello" };
  int a[] { 1, 2 };
  int *p = new int [2] { 1, 2 };
  vector<string> box { "one", "two" };
}

//can be used to call the constructor too, A class can define an initializer-list constructor. This constructor is called during uniform initialization and takes priority over other forms of construction,
// Call parameterless constructor
MyClass b {};
// Call copy constructor
MyClass c { b };

#include <iostream>
using namespace std;
class NewClass
{
 public:
  NewClass(initializer_list<int>);
};
NewClass::NewClass(initializer_list<int> args)
{
  for (auto x : args)
    cout << x << " ";
}
int main()
{
  NewClass a { 1, 2, 3 }; // "1 2 3"
}

    + Designed initializers, The C++20 standard introduced designated initializers, allowing any non-static field to be assigned by name in a brace-enclosed initialization list. Designated initializers can be used together with both uniform and aggregate initialization. The order should be as same as they defined in the class 
    
class TestClass
{
 public:
  int a = 1;
  int b = 2;
};
int main()
{
  TestClass o1 { .a = 3, .b = 4 }; // ok, a = 3, b = 4
  TestClass o2 { .a = 5 }; // ok, a = 5, b = 2
  TestClass o3 { .b = 6 }; // ok, a = 1, b = 6
}

int main()
{
  TestClass o4 { .b = 0, .a = 1 }; // error, out of order
  TestClass o5 { .a = 5, 3 }; // error, designated and non-designated
}


# Inheritance 
- Inheritance allows a class to acquire the members of another class. 

class Rectangle
{
 public:
  int x, y;
  int getArea() { return x * y; }
};

class Square : public Rectangle {};

- upcasting, upcast to its base class because it contains everything that the base class contains 

Square s;
Rectangle& r = s;  // reference upcast
Rectangle* p = &s; // pointer upcast

void setXY(Rectangle& r)
{
  r.x = 2;
  r.y = 3;
}
int main()
{
  Square s;
  setXY(s);
}

- downcasting, A Rectangle reference or pointer that points to a Square object can be downcast back to a Square object. may not allowed in real program 
Square& a = static_cast<Square&>(r); // reference downcast
Square* b = static_cast<Square*>(p); // pointer downcast

- constructor inheritance, the parameterless constructor of the base class is automatically called when an object of the derived class is created 

#include <iostream>
using namespace std;
class B1
{
 public:
  int x;
  B1() : x(5) {}
};
class D1 : public B1 {};
int main()
{
  D1 d; // calls parameterless constructors of D1 and B1
  cout << d.x; // "5"
}

//explicit call base class constructor 
class B2
{
 public:
  int x;
  B2(int a) : x(a) {}
};
class D2 : public B2
class D2 : public B2
{
 public:
  D2(int i) : B2(i) {} // call base constructor
}; 


//inherite all constructors from the base class in C++11, any fields declared in the derived class should initialize themselves. 
class D2 : public B2
{
 public:
  using B2::B2; // inherit all constructors from B2
  int y { 0 };
};

int main()
{
  D2 d(3); // call inherited B2 constructor
  cout << d.x; // "3"
}

- multiple inheritance, will complex the code 
class Person {};
class Employee {};
class Teacher: public Person, public Employee {};


# Overriding 
- Hiding derived members 
class Rectangle
{
 public:
  int x, y;
  Rectangle(int x, int y) : x(x), y(y) {}
  double getArea() { return x * y; }
};

class Triangle : public Rectangle
{
 public:
  Triangle(int a, int b) : Rectangle(a,b) {}
  double getArea() { return x * y / 2; }
};

Triangle t { 2,3 }; // uniform initialization
t.getArea(); // 3 (2*3/2) calls Triangle's version

//if triangle is upcast to a rectangle then rectangle's version will get called 
Rectangle& r = t; // upcast
r.getArea(); // 6 (2*3) calls Rectangle's version

- overriding derived members needs to be declared with the virtual modifier in the base class. 

class Rectangle
{
 public:
  int x, y;
  virtual int getArea() { return x * y; }
};

Triangle t { 2,3 };
Rectangle& r = t;
r.getArea(); // 3 (2*3/2) calls Triangle's version

//C++11 added the override specifier, which indicates that a method is intended to replace an inherited method. 
class Triangle : public Rectangle
{
 public:
  virtual double getArea() override { return x * y / 2; }
};

//C++11 is final. This specifier prevents a virtual method from being overridden in derived classes. final specifier can also be applied to a class to prevent any class from inheriting it.
class Base
{
  virtual void foo() final {}
};
class Derived : public Base
{
  void foo() {} // error: Base::foo marked as final
};
class B final {};
class D : B {}; // error: B marked as final

- base class scoping, allow access to redefined methods that are any number of levels deep in the class hierarchy.

class Triangle : public Rectangle
{
 public:
  Triangle(int a, int b) { x = a; y = b; }
  int getArea() override { return Rectangle::getArea() / 2; }
};

- pure virtual functions,  all derived classes must implement a certain method, but the base class cannot provide a default implementation for that method. also known as interface in other language

class Shape
{
 public:
  virtual double getArea() = 0; // pure virtual function
};

#include <iostream>
class Rectangle : public Shape
{
 public:
  int x = 1, y = 2;
  virtual int getArea() override { return x * y; }
};
void printArea(Shape& s) {
  std::cout << s.getArea();
}
int main()
{
  Rectangle r;
  printArea(); // "2"
}


# Access level 
- There are three of them available in C++: public, protected, and private. A protected member can also be accessed from inside a derived class. Public access gives unrestricted access from anywhere in the code. all members which is called the enclosing class. This is the only place where private members can be accessed


class MyClass
{
  // Unrestricted access
  public: int myPublic;
  // Defining or derived class only
  protected: int myProtected;
  // Defining class only
  private: int myPrivate;
 void test()
 {
  myPublic = 0; // allowed
  myProtected = 0; // allowed
  myPrivate = 0; // allowed
 }
};

- fields should always be private and only exposed through public or protected getter and setter methods.

class Person
{
 private:
  int age;
 public:
  // Setter
  void setAge(int a)
  {
    if (age > 200) age = 200;
    else if (age < 0) age = 0;
    else age = a;
  }
  // Getter
  int getAge()
  {
    return age;
  }
};

- friend classses and functions, A class can be allowed to access the private and protected members of another class by declaring that class a friend. This is done by using the friend modifier. It is allowed access all members in the class. 

class MyClass
{
  int myPrivate;
  // Give OtherClass access
  friend class OtherClass;
};
class OtherClass
{
  void test(MyClass& c) {
    c.myPrivate = 0; // allowed
  }
};

    + mark a method of a class as a friend method 
class MyClass;
class OtherClass
{
 public:
  void test(MyClass& c);
  void test2(MyClass& c);
};
class MyClass
{
  int myPrivate;
  friend void OtherClass::test(MyClass&);
};
void OtherClass::test(MyClass& c) {
  c.myPrivate = 0; // allowed
}
void OtherClass::test2(MyClass& c) {
  c.myPrivate = 0; // not allowed
}


//global method marked as friend 
class MyClass
{
  int myPrivate;
  // Give myFriend access
  friend void myFriend(MyClass& c);
};
void myFriend(MyClass& c) {
  c.myPrivate = 0; // allowed
}

    + does the friend method can access inherit classes? 

- public, protected and private inheritance. public inheritance is the one that is nearly always used.

class MyChild : private MyClass
{
  // myPublic is private
  // myProtected is private
  // myPrivate is private
};


# Static 
- The static keyword is used to create class members that exist in only one copy, which belongs to the class itself.
- static fields, A static field (class field) is initialized outside of the class declaration. remain initialized throughout the life of the application 

class MyCircle
{
 public:
  double r; // instance field (one per object)
  static double pi; // static field (only one copy)
};

double MyCircle::pi = 3.14159;

//does this field is accessible from outside of the source file?

//access the field 
int main()
{
  double p = MyCircle::pi;
}

- static method is not part of any instance, it cannot use instance members as it does not have an implicit this pointer. Methods should therefore only be declared static if they perform a generic function that is independent of any instance variables.


class MyCircle
{
 public:
  double r;
  static inline double pi = 3.14159;
  double getArea() { return pi * r * r; }
  static double newArea(double a) { return pi * a * a; }
};
int main()
{
  double a = MyCircle::newArea(1);
} 

- static local variable, Local variables inside a function can be declared as static to make the function remember the variable for the lifetime of the application. only initialized once when execution first reaches the declaration

void myFunc()
{
  static int count = 0; // holds # of calls to function
  count++;
}

- static global variable, This will limit the accessibility of the variable to only the current source file and can therefore be used to help avoid naming conflicts.

// Only visible within this source file
static int myGlobal;

namespace
{
  // Only visible within this source file
  int myGlobal;
}


# Enum Types 
- user-defined type consisting of a fixed list of named constants.

enum class Color { red, green, blue };

int main()
{
  Color c = Color::red;
}

switch(c)
{
  case Color::red:   break;
  case Color::green: break;
  case Color::blue:  break;
}

- enum constant values, 

enum class Color
{
  red,   // 0
  green, // 1
  blue   // 2
};

enum class Color
{
  red = 5, // 5
  green = red, // 5
  blue  = green + 2, // 7
  yellow // 8
};

- enum scope, An enum does not have to be declared globally. 
class MyClass
{
  enum class Color { red, green, blue };
};
void myFunction()
{
  enum class Color { red, green, blue };
}

- weakly typed enums, enum class was introduced in C++11 to provide alternative to weakly typed enum inherited from C. 

// Weakly typed enum
enum Speed
{
 fast,
 normal,
 slow
};


//enum constant can therefore be referenced even without qualifying it with the enum name.
Speed s1 = fast;
Speed s2 = Speed::normal;


//enum classes are strongly typed they will not implicitly convert to integer types 
// Weakly typed enum
enum Speed { fast, normal, slow };
Speed s = fast;
if (s == fast) {} // ok
if (s == 0) {} // ok
// Strongly typed enum
enum class Color { red, green, blue };
Color c = Color::red;
if (c == Color::red) {} // ok
if (c == 0) {} // error


// C++20 added the ability to import an enum class into the local scope with a using statement. This avoids needless repetition of the enum class name
#include <iostream>
using namespace std;
enum class Color { red, green, blue };
void colorPrint(Color c)
{
  // Import enum members to local scope
  using enum Color;
  switch (c)
  {
    case red: cout << "red";
    case green: cout << "green";
    case blue: cout << "blue";
  }
}

- enum constant type, enum class type can be overridden to another integer type
// Enum with constant type set to unsigned short
enum class MyEnum : unsigned short {};


# Struct and unions 
- A struct in C++ is equivalent to a class, except that members of a struct default to public access, instead of private access as in classes. 

struct Point
{
  int x, y; // public
};
class Point
{
  int x, y; // private
};

- struct initialization 

Point p, q; // object declarations


struct Point
{
  int x, y;
} r, s; // object declarations, This position is known as the declarator list and can contain a comma-separated sequence of declarators. 


int main()
{
  // Aggregate initialization, the type must not include any private or protected non-static fields.
  Point p = { 2, 3 };
}


int main()
{
  // Uniform initialization, compilers supporting C++11 or later versions
  Point q { 2, 3 };
}

- Union, the union type is different in that all fields share the same memory position. 
union Mix
{
  char c;  // 1 byte
  short s; // 2 bytes
  int i;   // 4 bytes
} m;

int main()
{
  m.c = 0xFF; // set first 8 bits
  m.s = 0; // reset first 16 bits
}

- the following union has three data members that allow access to the same group of four bytes in multiple ways.

union Mix
{
  char c[4];                  // 4 bytes
  struct { short hi, lo; } s; // 4 bytes
  int i;                      // 4 bytes
} m;

int main()
{
  // Set i = 11111111 00000000 11110000 00001111
  m.i=0xFF00F00F;
  m.s.lo; // 11111111 00000000
  m.s.hi; //                   11110000 00001111
  m.c[3]; // 11111111
  m.c[2]; //          00000000
  m.c[1]; //                   11110000
  m.c[0]; //                            00001111
}

- anonymous union,  an unnamed object whose members can be accessed directly from the scope where the object is declared. It cannot contain nonpublic members 

int main()
{
  union { short s; }; // defines an unnamed union object
  s = 15;
}

//anonymous union that is declared globally must be made static 
static union {};


# Operator overloading 
- Operator overloading allows operators to be redefined and used where one or both of the operands are of a user-defined class. 

class MyNum
{
  int val;
 public:
  MyNum(int i) : val(i) {}
  MyNum add(const MyNum &a) const {
    return MyNum( val + a.val );
  }
};

MyNum a = MyNum(10),
      b = MyNum(5);
MyNum c = a.add(b);

- binary operator overloading, simplify this syntax and thereby provide a more intuitive interface for the class.  a binary operator, programmers expect a copy of the result to be returned

MyNum operator + (const MyNum &a) const {
  return MyNum( val + a.val );
}

MyNum c = a + b;
//alternative syntax 
MyNum d = a.operator+(b);

- unary operator overloading, When overloading a unary operator, such as prefix increment (++), there is no need for a method parameter since these operators only affect the object from which they are called. programmers expect the result to return the same object and not just a copy.

// Increment prefix
MyNum& operator++()
{
  ++val;
  return *this;
}

    + Not all unary operators should return by reference. The two postfix operators—post-increment and post-decrement—should instead return by value. it is expected to return the state of the object before the increment or decrement occurs
    
// Increment postfix, Note that the postfix operators have an unused int parameter specified. This parameter is used to distinguish them from the prefix operators. 
MyNum operator++(int)
{
  MyNum t = MyNum(val);
  ++val;
  return t;
}

- copmarison operator overloading, The three-way comparison operator (<=>) was added in C++20 to provide a simple way to overload the four comparison operators <, >, <=, and >=. 


#include <compare> // std::strong_ordering
class Length
{
 public:
  int i;
  std::strong_ordering operator<=>(const Length& right) const {
    return i <=> right.i;
  }
};

//the compiler will automatic generates all four comparison operators base on 
int main()
{
  Length n1 { 1 }, n2 { 2 };
  bool b = n1 < n2; // true
}

//three way comparison operator (<=>) use case 
#include <compare>
#include <iostream>
int main()
{
  int x = 5;
  auto result = x <=> 0;
  if (result > 0) { // true
    cout << "5 > 0";
  }
}

//C++20 is that the compiler will generate the inequality operator (!=) if the equality operator (==) is defined. 
class Length
{
 public:
  int i;
  bool operator==(const Length& other) const {
    return i == other.i;
  }
};
int main()
{
  Length m1 { 1 }, m2 { 2 };
  bool b1 = m1 == m2; // false
  bool b2 = m1 != m2; // true
}

//If the operator is defaulted, as seen in the following, the compiler will generate all six of the comparison operators (<, >, <=, >=, ==, and !=). the compiler automatically implement the specified comparison method, which will compare the fields of the class in the order in which they are defined, stopping early when a non-equal result is found. 
#include <compare>
class Point
{
  int x, y;
 public:
  auto operator<=>(const Point&) const = default;
};
int main()
{
  Point p1 { 1, 10 }, p2 { 2, 0 };
  bool b = p1 < p2; // true (p1.x < p2.x)
}

- overloaded operators
//binary operators 
+ - * / %

= += -= *= /= %=

&= ^= |= <<= >>=

== != > < >= <= <=>

& | ^ << >> && ||

–> –>* ,

//special operators 
( ) [ ] delete new

//not overloadable 
. .* :: ?: # ## sizeof typeid alignof noexcept


# Custom conversions 
- Custom type conversions can be defined to allow an object to be constructed from or converted to another type. 

class MyNum
{
  int value;
};

    + implicit conversion constructor, a constructor needs to be added that takes a single parameter of the desired type
class MyNum
{
 public:
  MyNum(int i) : value(i) {}
 private:
  int value;
};

MyNum a = 5; // implicit conversion
MyNum b(5); // object construction
MyNum c = 5; // implicit conversion

class Point
{
 public:
  Point(int x, int y) : x(x), y(y) {}
 private:
  int x, y;
};
int main()
{
  Point p = { 1,2 }; //a list is implicitly converted to a point 
}

    + explicit conversion constructor,  The explicit constructor modifier is then applied

class MyNum
{
 public:
  int value;
  explicit MyNum(int i) { value = i; }
};


MyNum a = 5; // error
MyNum b(5); // allowed
MyNum c = MyNum(5); // allowed
MyNum d = static_cast<MyNum>(5); // allowed

- conversion operators, he operator keyword is then used, followed by the target type

class MyNum
{
 public:
  int value;
  operator int() { return value; }
};

MyNum a { 5 };
int i = a; // 5

- explicit conversion operators added in C++11 

class True
{
 public:
  explicit operator bool() const {
    return true;
  }
};

True a, b;
if (a == b) {} // error
if (static_cast<bool>(a) == static_cast<bool>(b)) {} // allowed

//contexts requiring a bool value, such as the condition for an if statement, count as explicit conversions.
if (a) {} // allowed


# Namespace 
- Namespaces are used to avoid naming conflicts by allowing entities, such as classes and functions

class Table {};
class Table {}; // error: class type redefinition

//resolve the conflict by adding to different namespace 
namespace furniture
{
  class Table {};
}
namespace html
{
  class Table {};
}

int main()
{
  furniture::Table fTable;
  html::Table hTable;
}

- nesting namespace 
namespace furniture
{
  namespace wood { class Table {}; }
}

//c++17 support shorting namespace 
namespace furniture::wood { class Table {}; }

- importing namespaces 
using namespace html; // global namespace import
int main()
{
  using namespace html; // local namespace import
}

- namespace member import to avoid import the whole namespace 
using html::Table; // import a single namespace member

- namespace alias, create a namespace alias 
namespace myAlias = furniture::wood; // namespace alias

myAlias::Table fTable;

//using directives and using declarations, may be declared either globally or locally.

- type alias, A type alias is defined with a using statement. 
using MyType = furniture::wood::Table;

MyType t;

//Before using statements were introduced in C++11, type aliases were defined with typedef. In such a statement, the typedef keyword is followed by the type name and then the alias name.

typedef furniture::wood::Table MyType;

- include namespace members, the prototypes also have to be made available, for example, by using the appropriate #include directives.

// Include input/output prototypes
#include <iostream>

// Import standard library namespace to global scope
using namespace std;


# Constants 
- a variable cannot be changed 

const int var = 5;
int const var2 = 10; // alternative order

- constant pointers 

    + First, the pointer can be made constant, cannot point to another location 
    
int myPointee;
int* const p = &myPointee; // pointer constant

    + the pointee can be declared constant. that the variable pointed to cannot be modified through this pointer.

const int* q = &myPointee; // pointee constant

const int* const r = &myPointee; // pointer & pointee constant

    + constant variables may not be pointed to by a non-constant pointer. 
const int myConst = 3;
int* s = &myConst; // error: const to non-const assignment

- constant reference,  It only makes sense to protect the referee from changing. the reference itself cannot be changed should we don't need to make the reference const like the pointer 

const int& y = myPointee; // referee constant

- constant objects, variables, pointers and reference can also be declared constant. 
class MyClass
{
 public:
  int x;
  void setX(int a) { x = a; }
};

//constant object cannot be reassigned to another instance. it is also prevent its fields being changed 
const MyClass a, b;
a = b;    // error: object is const
a.x = 10; // error: object field is const

- constant methods, non constant method cannot be called on a constant object since such methods are allowed to change the object's fields 

a.setX(2); // error: cannot call non-const method


//They may only call constant methods, which are methods that are marked with the const modifier before the method body. This effectively restricts the method from modifying the object’s fields or calling any non-constant methods 
int getX() const { return x; } // constant method

- Constant return type and parameters, the return type and method parameters may also be made read-only.

const int& getX() const { return x; }

- Constant fields, must be assigned value with in-class initializers or constructor initialization list 

class MyClass
{
 public:
  int a;
  const int b;
  const int c = 3;
  MyClass() : a(1), b(2) {}
};

//constant static field is either inline or of an integer data type. Such a field may also be initialized within the class
class MyClass
{
 public:
  const static double c1;
  const inline static double c2 = 1.23;
  const static int c3 = 5;
};
const double MyClass::c1 = 1.23;

- Constant expressions, constexpr was introduced in C++11 to indicate a constant expression. Like const it can be applied to variables to make them constant. It will always be computed at compile time compare to const which can be assign at runtime 

constexpr int myConst = 5;
myConst = 3; // error: variable is const

int myArray[myConst + 1]; // allowed

//Functions and class constructors may also be defined as constant expressions, which is not allowed with const
constexpr int getDefaultSize(int multiplier)
{
  return 3 * multiplier;
}

// Compile-time evaluation
int myArray[getDefaultSize(10)];

// Runtime evaluation, If the function is called without constant arguments, it returns a value at runtime just like a regular function
int mul = 10;
int size = getDefaultSize(mul);

//As of C++17, a lambda expression is implicitly constexpr if it satisfies the conditions of a constexpr function.
auto answer = [](int i) { return 10+i; };
constexpr int reply = answer(32); // "42"

//constructor can be defined as constexpr to construct a const expression object 
class Circle
{
 public:
  int r;
  constexpr Circle(int x) : r(x) {}
};

// Compile-time object
constexpr Circle c1(5);
// Runtime object
int x = 5;
Circle c2(x);

//constexpr was added in C++17: the ability to evaluate conditional statements at compile time. 
constexpr int debug = 0;
if constexpr(debug) {
  // Discarded if condition is false
}


// C++20, allowing such virtual functions to be called within a constant expression. it can also be defined as constexpr 
struct Parent {
  virtual int num() const = 0;
};
struct Child: public Parent {
  constexpr virtual int num() const { return 3; }
};
constexpr Child c;
//The static_assert declaration seen here is used to make an assertion at compile time. 
static_assert( c.num() == 3, "num is not 3" );

- immediate functions, C++20 introduced, which designates that the function must always return a compile-time constant. Such a function can be used in a context requiring a constant expression

consteval int doubleIt(int i) {
  return 2*i;
}
constexpr int a = doubleIt(10);  // ok
int x = 10;
int b = doubleIt(x);  // error: call does not produce a constant


# Preprocessor 
- The preprocessor is a text substitution tool that modifies the source code before the compilation takes place.
 
| #include 
| #define 
| #undef 
| #ifdef 
| #if 
| #elif 
| #else 
| #endif 
| #line, set line number 
| #error, abort compilation 
| #pragma, set compiler option 

#include <iostream> // search library directory
#include "MyFile.h" // search current, configured and default directories

#include "C:\MyFile.h" // absolute path
#include "..\MyFile.h" // relative path


- define, create compile-time constants, also called macros . 
- undefine,  undefined using the #undef directive to remove the previous defined macro 

#undef PI // undefine
#undef PI // allowed

- predefined macros, different compiler may have different macros, some most useful 
__FILE__, name and path of the current file 
__LINE__, current line number 
__DATE__, compilation date in MMM DD YYYY format 
__TIME__, compilation time in HH:MM:SS format 
__func__, name of the current function; added in C++11 

cout << "Error in " << __FILE__ << " at line " << __LINE__;

- macro functions, Macros can be made to take arguments. This allows them to define compile-time functions.
#define SQUARE(x) ((x)*(x))

//To break a macro function across several lines, you use the backslash character. 
#define MAX(a,b) \
(a)>(b) ? \
(a): (b)

- conditional compilation 

#define DEBUG_LEVEL 3
#if DEBUG_LEVEL > 2
 // ...
#endif

#if DEBUG_LEVEL > 2
 // ...
#elif DEBUG_LEVEL == 2
 // ...
#else
 // ...
#endif

#if 0
 /* Removed from compilation */
#endif

- compile if defined, two special operators can be used: defined and !defined (not defined). Note that a macro is considered defined even if it has not been given a value.

```
#define DEBUG
#if defined DEBUG
 // ...
#elif !defined DEBUG
 // ...
#endif

//equal to 
#ifdef DEBUG
 // ...
#endif
#ifndef DEBUG
 // ...
#endif
```

- Error directive is encountered, the compilation is aborted

```

#error Compilation aborted

```

- change the line number that is displayed when an error occurs 
#line 5 "myapp.cpp"

- pragma, specify options to the compiler they are vendor specific 

// Show compiler message
#pragma message("Hello Compiler")
// Disable warning 4507
#pragma warning(disable : 4507)

- attributes, A new standardized syntax was introduced in C++11 for providing compiler-specific information in the source code, so-called attributes.


// a standard attribute added in C++14 is [[deprecated]], which indicates that the use of a code entity has become discouraged.
// Mark as deprecated
[[deprecated]] void foo() {}

//[[noreturn]] attribute, which specifies to the compiler that a function will not return to the calling function. This may be the case for functions that loop forever, throw exceptions, or exit the application.
[[noreturn]] void f()
{
  exit(0); // terminate program
}


# Exception handling 
- allows developers to deal with unexpected situation 
- throw exceptions 

// statement is reached, the function will stop executing and the exception will propagate up to the caller where it can be caught, using a try-catch statement.

double divide(double x, double y)
{
  if (y == 0) throw 0;
  return x / y;
}

try {
  divide(10,0);
}
catch(const int& e) {
  cout << "Error code: " << e;
}
catch(const char& e) {
  cout << "Error char: " << e;
}
catch(...) { cout << "Error"; }

- rethrowing exceptions, if an exception is never caught, the program will terminate with a runtime error.

int main()
{
  try {
    try { throw 0; }
    catch(...) { throw; } // rethrow exception
  }
  catch(...) { throw; } // runtime error
}

- noexcept specifier, The noexcept specifier indicates that a function is intended not to throw any exceptions.

void foo() noexcept {} // must not throw exceptions
void bar() {} // may throw exceptions

//Since C++11, the noexcept specifier may also be used as a compile-time operator to check if a function is declared to not throw any exceptions. 

//C++17, the exception specification has become a part of the type system, so the noexcept property needs to be included when binding a function pointer to such a function.

void(*pFunc)() noexcept = foo; // function pointer
pFunc(); // call function through pointer
cout << noexcept(pFunc); // "1" (true)

- exception class, standard library does provide a base class called exception

#include <exception>
using namespace std;
void makeError()
{
  throw exception("My Error Description");
}

try {
  makeError();
}
catch (const exception& e) {
  cout << e.what(); // "My Error Description"
}


# Type conversions 
- convert an expression from one type to another, implicit and explicit 

long a = 5; // int implicitly converted to long
double b = a; // long implicitly converted to double

    + promotion and demotion. Promotion occurs when an expression gets implicitly converted into a larger type, and demotion occurs when converting an expression to a smaller type.

// Promotion
long a = 5; // int promoted to long
double b = a; // long promoted to double
// Demotion
int  c = 10.5; // warning: possible loss of data
bool d = c; // warning: possible loss of data

- explicit conversion 

    + C style cast 
int c = (int)10.5; // double demoted to int
char d = (char)c; // int demoted to char

    + C++ casts 
static_cast<new_type> (expression)
reinterpret_cast<new_type> (expression)
const_cast<new_type> (expression)
dynamic_cast<new_type> (expression)

- static cast, performs conversions between compatible types. 

char c = 10; // 1 byte
int *p = (int*)&c; // 4 bytes
*p = 5; // runtime error: stack corruption

int *q = static_cast<int*>(&c); // compile-time error

- reinterpret cast, This cast handles conversions between certain unrelated types, such as from one pointer type to another incompatible pointer type. It will simply perform a binary copy of the data without altering the underlying bit pattern. 
 
int *r = reinterpret_cast<int*>(&c); // forced conversion

- const cast add or remove the const modifier of a variable.
const int myConst = 5;
int *nonConst = const_cast<int*>(&myConst); // removes const
*nonConst = 10; // potential runtime error

//mainly when there is a function that takes a non-constant pointer argument, even though it does not modify the pointee
void print(int *p) { std::cout << *p; }
print(&myConst); // error: cannot convert const int* to int*
print(nonConst); // allowed

- dynamic cast,  This cast is only used to convert object pointers and object references into other pointers or reference types in the inheritance hierarchy. 

class MyBase { public: virtual void test() {} };
class MyChild : public MyBase {};
int main()
{
  MyChild *child = new MyChild();
  MyBase  *base = dynamic_cast<MyBase*>(child); // ok
  // ...
  delete child;
}

MyBase *base = new MyBase();
MyChild *child = dynamic_cast<MyChild*>(base);
if (child == nullptr) cout << "Null pointer returned";
delete base;

//the dynamic cast will then fail by throwing a bad_cast exception. This needs to be handled using a try-catch statement .
#include <exception>
#include <iostream>
using namespace std;
class MyBase { public: virtual void test() {} };
class MyChild : public MyBase {};
int main()
{
  MyBase *base = new MyBase();
  try {
    MyChild &child = dynamic_cast<MyChild&>(*base);
  }
  catch(const bad_cast &e) {
  cout << e.what(); // "bad dynamic_cast"
  }
  delete base;
}

//dynamic cast check a conversion has succeeded during runtime. The disadvantage is that there is a performance overhead
MyBase *base = static_cast<MyBase*>(child); // ok
// Succeeds for a MyChild object
MyChild *child = dynamic_cast<MyChild*>(base);

// if base-to-derived (base object to derived) conversion had been performed using a static cast instead of a dynamic cast, the conversion would not have failed.
// Allowed, but invalid
MyChild *child = static_cast<MyChild*>(base);


# Smart pointers 
- Several smart pointer classes were added in C++11 for managing dynamically allocated memory and resources in general. the pointer is created, used, and then destroyed automatically when it goes out of scope

a unique pointer has exclusive ownership of the object it points to and therefore cannot be copied. It can, however, transfer ownership to another unique pointer using the std::move function. The original pointer will automatic be set to null 

    + unique pointer std::unique_ptr, simple acts as a container for a raw pointer. It replaces another deprecated smart pointer named auto_ptr, which was removed in C++17.
    
#include <memory> // include smart pointers
#include <iostream>
using namespace std;
struct Foo
{
  int val;
  Foo() { cout << "1"; }
  ~Foo() { cout << "3"; }
};
int main()
{
  unique_ptr<Foo> p(new Foo()); // "1"
  p->val = 2;
  cout << p->val; // "2"
} // "3"

unique_ptr<Foo> u1(new Foo());
unique_ptr<Foo> u2 = u1; // compile-time error
unique_ptr<Foo> u3 = move(u1); // transfers ownership

    + reference, why auto ptr is deprecated
    
    https://stackoverflow.com/questions/3697686/why-is-auto-ptr-being-deprecated
    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html#20.4.5%20-%20Class%20template%20auto_ptr
    
The direct replacement for auto_ptr (or the closest thing to one anyway) is unique_ptr. As far as the "problem" goes, it's pretty simple: auto_ptr transfers ownership when it's assigned. unique_ptr also transfers ownership, but thanks to codification of move semantics and the magic of rvalue references, it can do so considerably more naturally. It also "fits" with the rest of the standard library considerably better

const auto_ptr<int> source(new int);
auto_ptr<int> target = source;  // move from const source to target

 one could put auto_ptr into a container:

    vector<auto_ptr<int> > vec;

However field experience with this design revealed subtle problems. Namely:

    sort(vec.begin(), vec.end(), indirect_less());

The problem is that some implementations of sort will pick an element out of the sequence, and store a local copy of it.

    ...
    value_type pivot_element = *mid_point;
    ...

The algorithm assumed that after this construction that pivot_element and *mid_point were equivalent. However when value_type turned out to be an auto_ptr, this assumption failed, and subsequently so did the algorithm. 

It does not prevent clients from sorting client-defined containers of auto_ptr, or even built-in arrays auto_ptr. For example the following code will compile today:

    #include <algorithm>
    #include <memory>

    struct indirect_less
    {
        template <class T>
        bool operator()(const T& x, const T& y)
        {
            return *x < *y;
        }
    };

    int main()
    {
        std::auto_ptr<int> ptrs[3];
        ptrs[0].reset(new int(3));
        ptrs[1].reset(new int(2));
        ptrs[2].reset(new int(1));
        std::sort(ptrs, ptrs+3, indirect_less()); // run time error?!
    }

//C++11's std::unique_ptr is the "fixed" std::auto_ptr: both of them are suitable when - at any point in time during execution - there should be a single smart-pointer owner for a pointed-to object.

//The crucial difference is in copy-construction or assignment from another un-expiring smart pointer, shown on the => lines below:
   std::auto_ptr<T> ap(...);
   std::auto_ptr<T> ap2(get_ap_to_T());   // take expiring ownership
=> std::auto_ptr<T> ap3(ap);  // take un-expiring ownership ala ap3(ap.release());
   ap->xyz;  // oops... can still try to use ap, expecting it to be non-NULL

   std::unique_ptr<T> up(...);
   std::unique_ptr<T> up2(get_up_to_T());   // take expiring ownership
=> std::unique_ptr<T> up3(up);  // COMPILE ERROR: can't take un-expiring ownership
=> std::unique_ptr<T> up4(std::move(up));  // EXPLICIT code allowed
=> std::unique_ptr<T> up4(up.release());   // EXPLICIT code allowed
    
- shared pointer. A shared pointer can be copied. The memory to the object will not be deallocated until the last remaining shared pointer owning the object is destroyed, either by going out of scope or by resetting the pointer to nullptr manually.

shared_ptr<Foo> s1(new Foo());
shared_ptr<Foo> s2 = s1; // extends ownership
s1 = nullptr; // reset pointer
s2 = nullptr; // reset last pointer and delete memory

//C++14, the use of the new keyword is discouraged in most circumstances. std::make_unique and std::make_shared functions are recommended when allocating dynamic memory.
unique_ptr<Foo> u = make_unique<Foo>();
shared_ptr<int> s = make_shared<int>(10);

//Since C++20 there are also methods available for doing default initialization. 
auto u2 = make_unique_for_overwrite<Foo>();
auto s2 = make_shared_for_overwrite<int>(10);

- weak shared pointer, A weak shared pointer (std::weak_ptr) can be created from a shared pointer. a weak shared pointer is non-owning, meaning that the object will be cleaned up when all shared pointers go out of scope. access the referenced object, a weak shared pointer must first be converted into a shared pointer using the lock method

#include <memory>
#include <iostream>
using namespace std;
void observe(weak_ptr<int> weak)
{
  shared_ptr<int> s = weak.lock();
  if (s != nullptr) {
    cout << "Pointer is " << *s << endl;
  }
  else {
    cout << "Pointer has expired" << endl;
  }
}
int main()
{
  shared_ptr<int> s = make_shared<int>(5);
  weak_ptr<int> w = s; // copy pointer without ownership
  observe(w); // "Pointer is 5"
  s = nullptr; // delete managed object
  observe(w); // "Pointer has expired"
}


# Templates 
- Templates provide a way to make a class, function, or variable operate with different data types without having to rewrite the code for each type

- function templates,  add a template parameter declaration before the function. typename and class is equivalent in this context 
template<typename T>
void swap(T& a, T& b)
{
  T tmp = a;
  a = b;
  b = tmp;
}


template<class T>
void swap(T& a, T& b)
{
  T tmp = a;
  a = b;
  b = tmp;
}

//Every time the function template is called with a new type, the compiler will instantiate another function using the template. It the parameter can be determined in compile time then the type can be omitted

int a = 1, b = 2;
swap<int>(a,b); // calls int version of swap

int e = 1, f = 2;
swap(e,f); // calls int version of swap

- multiple template parameters 

template<class T, class U>
void swap(T& a, U& b)
{
  T tmp = a;
  a = b;
  b = tmp;
}

int main()
{
  int a = 1;
  long b = 2;
  swap<int, long>(a,b);
  swap(a,b); // alternative
}

- class template 

template<class T>
class MyBox
{
 public:
  T a, b;
  MyBox(const T& x, const T& y) : a(x), b(y) {}
};

int main()
{
    // Without type deduction
    MyBox<int> box(1, 2); // MyBox<int>
    // With type deduction
    MyBox box(2.1, 3.2); // MyBox<double>
}

//if the member function definition is outside of the class then it still required to add template keyword 
template<class T>
class MyBox
{
public:
    T a, b;
    void swap();
};

template<class T>
void MyBox<T>::swap()
{
    T tmp = a;
    a = b;
    b = tmp;
}

- non-type parameters, both class and function templates can also have regular function-like parameters. 

template<class T, unsigned int N>
class MyBox
{
public:
    T store[N];
};

MyBox<int, 5> box; 

- default types and values template parameters can be given default values and types.

template<class T = int, int N = 5>
class MyBox
{
 public:
  T store[N];
};

//use the default type and parameter 
MyBox<> box;

- class template specialization, define a different implementation for a template when a specific type is passed as the template parameter, a template specialization can be declared. 

there is no inheritance of members from the standard template to the specialized template. The whole class will have to be redefined.

#include <iostream>
template<class T>
class MyBox
{
 public:
  T a;
  void print() { std::cout << a; }
};

//add special implimentation for bool type 
template<>
class MyBox<bool>
{
 public:
  bool a;
  void print() { std::cout << (a ? "true" : "false"); }
};

int main()
{
  MyBox<bool> box { true };
  box.print(); // "true"
}

- function template specification, it is used to avoid rewritten the whole class for a specific type 

#include <iostream>
template<class T>
class MyBox
{
 public:
  T a;
  template<class T> void print() {
    std::cout << a;
  }
  template<> void print<bool>() {
    std::cout << (a ? "true" : "false");
  }
};

int main()
{
  MyBox<bool> box = { true };
  box.print<bool>(); // "true"
}

- variable templates,  C++14 allows variables to be templated. This is achieved using the regular template syntax.

template<class T>
constexpr T pi = T(3.1415926535897932384626433L);

int i = pi<int>; // 3
float f = pi<float>; // 3.14...

- variadic templates, C++11 allows template definitions to take a variable number of type arguments. 

#include <iostream>
#include <initializer_list>
using namespace std;
int sum(initializer_list<int> numbers)
{
  int total = 0;
  for(auto& i : numbers) { total += i; }
  return total;
}

//The initializer_list type indicates that the function accepts a brace-enclosed list as its argument, so the function must be called in this manner.
int main()
{
  cout << sum( { 1, 2, 3 } ); // "6"
}


//variadic function is traversed recursively rather than iteratively, so once the first argument has been handled, the function calls itself with the remaining arguments.
//The variadic template parameter is specified using the ellipsis (...) operator, followed by a name. This define is so-called parameter pack. it is defined in parameter with ...args, and unpacked in the definition of the body with args...

int sum() { return 0; } // end condition

template<class T0, class ... Ts>
decltype(auto) sum(T0 first, Ts ... rest)
{
  return first + sum(rest ...);
}

int main()
{
  cout << sum(1, 1.5, true); // "3.5"
}

- fold expression, C++17 introduced fold expressions, which make it possible to apply a binary operator to all elements of a parameter pack in one statement. It will reduce the code complexity of the previous sum in C++11 

template<class... T>
decltype(auto) sum(T... args)
{
  // Unpacks to: a1 + (a2 + (a3 + a4))..., A unary right fold is here performed in the return statement
  return (args + ...);
}

//unpacked from right to left, by placing the ellipsis to the left of the parameter pack
#include <iostream>
using namespace std;
template<class... T>
decltype(auto) difference(T... args)
{
  // Unpacks to: ...(a1 - a2) - a3
  return (... - args);
}
int main()
{
  cout << difference(5, 2, 1); // "2" (5-2-1)
}

- Concepts, A concept is a named set of constraints that limit what template arguments may be used with a template. They were introduced in C++20 to allow template arguments to be type-checked at compile time

//The is_integral_v class template used here is part of the standard library, and it is evaluated as true if T is an integral type
#include <concepts>
#include <type_traits>
// Concept declaration
template <class T>
concept MyIntegral = std::is_integral_v<T>;

//This concept can be applied to constrain template arguments
template<MyIntegral T>
bool is_positive(T a)
{
  return a > 0;
}
int main()
{
  is_positive(5); // ok, int satisfies MyIntegral
  is_positive("Hi"); // error, string does not satisfy MyIntegral
}

    + standard library concepts 
#include <concepts>
template<std::integral T>
bool is_positive(T a)
{
  return a > 0;
}

    + There are two ways to express a concept. The first way is in the form of a conditional expression, which was the form used for the integral concept defined earlier.
    
template <class T>
concept Signed_Integral = std::integral<T> && T{-1} < T{0};

    + The second way to define a concept is to use a requires clause. This clause defines objects of the types to be tested and then a list of one or more constraints. Each constraint consists of an expression in curly brackets followed by the expected return type. If all constraints are true, the compiler will allow the type. 
    
template<class T>
concept Equal = requires(T a, T b)
{
  { a == b } -> bool;
  { a != b } -> bool;
};
template<Equal T>
bool areEqual(T x, T y)
{
  return x == y;
}
int main()
{
  areEqual(1, 1); // true
}

- abbreviated function templates, Function templates can be abbreviated as of C++20 by using the auto placeholder type. When auto appears in the parameter list, the function automatically becomes a function template and the auto parameter becomes its template parameter. Applying a concept to such a function is done by adding the name of the concept before the type in the parameter list.

abbreviated function templates are not supported in Visual Studio 2019 as of version 16.3.

#include <concepts>
bool is_positive(std::integral auto a)
{
  return a > 0;
}
int main()
{
  is_positive(2); // calls int version
  is_positive(3L); // calls long version
}

- template lambdas, With C++14 generic lambdas were introduced, which meant that parameters declared as auto became template parameters. 

#include <iostream>
#include <vector>
using namespace std;
int main()
{
  vector<int> v { 1, 2, 3 };
  auto get_size = [](const auto& v) { return size(v); };
  cout << get_size(v); // 3
}

//restrict this lambda to only work with vector types, added support in C++20.  allowing full use of template parameters in lambdas.
auto get_size = []<typename T>(vector<T> const& v) { return size(v); };


# Headers 
-  A compilation unit consists of a source file (.cpp) and any included header files (.h or .hpp).

// MyFunc.cpp
void myFunc() {}
// MyApp.cpp
int main()
{
  myFunc(); // error: myFunc identifier not found
}
To make this work, the function’s prototype has to be included in MyApp.cpp .
// MyApp.cpp
void myFunc(); // prototype
int main()
{
  myFunc(); // ok
}

    + using headers 
// MyFunc.h
void myFunc(); // prototype
// MyApp.cpp
#include "MyFunc.h"

- what to include in headers. the distinction is only conceptual. the key idea is the header should contain the interface of the definition 

Headers should not include using namespace directives, because that would force the namespace inclusion upon everyone using the header.

- global variables and functions may be declared externally multiple times in a program, but they may be defined only once.

// MyApp.h
extern int myGlobal;
// MyApp.cpp
int myGlobal = 0;

- Instantiating a template with the same type in many compilation units leads to significant redundant work done by the compiler and linker. To prevent this, C++11 introduced extern template declarations. 

// MyApp.cpp
MyTemp<int> b; // instantiation is done here
// MyFunc.cpp
extern MyTemp<int> a; // suppress redundant instantiation

- If a header requires other headers, it is common to include those files as well, to make the header stand-alone. 
// MyApp.h
#include <stddef.h> // include size_t
void mySize(std::size_t);

- inline variables,  C++17, variables may be specified as inline, in addition to functions and methods. This allows constant and static variables to be defined in a header file

// MyApp.h
struct MyStruct
{
  static const int a;
  inline static const int b = 10; // alternative
};
inline int const MyStruct::a = 10;

//The constexpr keyword implies inline, so a variable declared as constexpr may also be initialized in a header file. It must be initialized to a compile-time constant 
struct MyStruct {
  static constexpr int a = 10;
};

// an inline variable is not restricted to only constant expressions. It can be assigned to a random value 
#include <cstdlib> // rand, srand
#include <ctime> // time
struct MyStruct {
  static const int die;
};
//This value is guaranteed to be the same for all compilation units using this header, even though the value is not set until runtime.
inline const int MyStruct::die = (srand((unsigned)time(0)), rand()%6+1); // 1-6

- include guards, The macro is then defined, which effectively prevents the file from being included again.

// MyApp.h
#ifndef MYAPP_H
#define MYAPP_H
// ...
#endif // MYAPP_H


most compiler support 
#pragma once


//C++17 added the __has_include preprocessor expression, which evaluates to true if the header file is found.
#if __has_include("myapp.h")
#include "myapp.h"
#endif

- modules, a module is a set of one or more source code files that are compiled independently. They were introduced in C++20 

right-click the project in the Solution Explorer and choose Properties. From there, select All Configurations from the Configuration drop-down list and then enable module support under Configuration Properties ➤ C/C++ ➤ Language ➤ Enable C++ Modules (experimental). 

The ixx file extension is required for module interface units in Visual Studio. Gcc use a cppm file extension 

```
// ModInterface.ixx
export module mymodule; // declare module name

```

Only code entities explicitly marked with export will be visible to source files using the module. This is the big difference compare to traditional header file 

```
// ModInterface.ixx
export module mymodule;
#define VALUE 5
int hidden() { return VALUE; }
export int getValue() { return hidden(); }
```

any code entities it declares will be visible across the entire module but not outside the module to which it belongs 

```
// ModInterface.ixx
export module mymodule;
export int getValue();
// ModImplementation.cpp
module mymodule; // unit belongs to mymodule
#define VALUE 5
int hidden() { return VALUE; }
int getValue() { return hidden(); }
```

- To get the ixx file to compile, right-click the file in the Solution Explorer and click Properties. From the Properties window, change the Item Type of the file to C/C++ Compiler and click OK. With the module ready and compiled, it can be imported into any source file to make use of its functionality. 

// MyApp.cpp
import mymodule; // import module, must appear at the global scope of the file importing the module.
#include <iostream>
using namespace std;
int main()
{
  cout << getValue() << endl; // "5"
}

//not support in Visual Studio 2019 16.3 
import <iostream>;
import <vector>;
















