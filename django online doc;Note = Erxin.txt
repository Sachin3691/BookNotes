django online doc;Note = Erxin

# Download 
- install python 3 
- install latest offical versin 
$ pip install django


# tutorial 
- sqlite backend 
    + substring matching are done case-insensitively 
    fitler(name__contains="aa") will match a name of Aabb 
    
    + none ascii matches are performed case sensitive match, iexact filter will as same as exact filter 
    
    beware of can-insenstive or substring filtering 
- check version 
$ python -m django --version 

- create project 
$ django-admin startproject <project> 
/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
        

manage.py, command line utility 
mysite/urls.py, table of contents of your site 
mysite/asgi.py, entry point of asgi compatible server 
mysite/wsgi.py, entry point of wsgi compatible server 
__init__.py, package indicator 

- run dev server 
$ python manage.py runserver [port]

the server is automatic reload changed python code 

- create app 
$ python manage.py startup app <app>

/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
    urls.py 

a web project may contain several apps

    + view, similar to MVC controller 
from django.http import HttpResponse

def index(request, default_arg=v):
    return HttpResponse("Hello, world. You're at the polls index.")
    
    + add urls.py 
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
]

- include app urls.py into web project 
//mysite/urls 
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('polls/', include('polls.urls')),
    path('admin/', admin.site.urls),
]

using the include() method, Django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing

path() accept four arguments, route, view, kwargs and name 
route, Patterns don’t search GET and POST parameters, or the domain name
view, view function with a httpRequest object as first argument and captured values from the route as keyword arguments 
kwargs, passed in dictionary 
name, naming your URL lets you refer to it unambiguously from elsewhere in Django 

- database setup 
    + select database engine 
    mysite/settings.py 
    
    ENGINE – Either 'django.db.backends.sqlite3', 'django.db.backends.postgresql', 'django.db.backends.mysql', or 'django.db.backends.oracle' etc. 
    
    NAME – The name of your database. If you’re using SQLite, the database will be a file on your computer;
    
    + add models 
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
    
always add __str__ method to model, the django admin app will also use it 
    
    + add apps if the model is contained in a different app from a project 
    
To include the app in our project, we need to add a reference to its configuration class in the INSTALLED_APPS setting. The PollsConfig class is in the polls/apps.py file

mysite/settings.py 

INSTALLED_APPS = [
    'xxx.apps.xxxconfig',
]
    
    + create database 
    
$ python manage.py migrate 

$ python manage.py makemigrations <appname>

By running makemigrations, you’re telling Django that you’ve made some changes to your models

    + sqlmigrate take migration names and return their SQL 
$ python manage.py sqlmigrate <appname> <generated-migrate-name>

By convention, Django appends "_id" to the foreign key field name

    + Migrations are very powerful and let you change your models over time, as you develop your project, without the need to delete your database or tables and make new ones 
    
$ python manage.py makemigrations 
to create migrations for those changes

$ python manage.py migrate 
to apply those changes to the database.

- playing with the API 
$ python manage.py shell 

>>> from polls.models import Choice, Question  # Import the model classes we just wrote.

# No questions are in the system yet.
>>> Question.objects.all()

- view, each web page in django is a view, can be a function, class 
    + reference 
    URL dispatcher
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
    
        * example 
        urlpatterns = [path('articles/<int:year>/<int:month>/<slug:slug>/', views.article_detail, {extra_view_option_key:value})]
        
        /articles/2003/03/building-a-django-site/, views.article_detail(request, year=2003, month=3, slug="building-a-django-site"
        
        ROOT_URLCONF, path to the full import path to URLconf file 
        
        relative view get arguments, httpRequest, if no named grouped in URL pattern then pass position arguments 
        
        at last the keyword arguments 
    
        * path converters by default:
    
        str, any non-emptys string, exclude '/'
        int, zero or any positive integer as an int 
        slug, any slug string consisting of ASCII letters or numbers. 
        uuid, matches a formatted UUID
        path, any non-empty string, including the '/'
    
        * custom path converters, converter is a class that includes 
        regex 
        to_python(self, value) method, handle converting the matched string to type 
        to_url(self, value), handle converting type to string 
        class FourDigitYearConverter:
            regex = '[0-9]{4}'

            def to_python(self, value):
                return int(value)

            def to_url(self, value):
                return '%04d' % value
                
        //use the converter 
        from django.urls import path, register_converter
        from . import converters, views

        register_converter(converters.FourDigitYearConverter, 'yyyy')

        urlpatterns = [
            path('articles/2003/', views.special_case_2003),
            path('articles/<yyyy:year>/', views.year_archive),
            ...
        ]
    
        * use re_path() to map with regex expression 
        re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<slug>[\w-]+)/$', views.article_detail),
        
        * nested arguments, Regular expressions allow nested arguments, and Django will resolve them and pass them to the view. While reversing django will ignore any nested arguments 
        
        re_path(r'^comments/(?:page-(?P<page_number>\d+)/)?$', comments),  # good
        
        (?:...) means non-capture argument, the nested page_number will be passed to view 
        
        since to reverse the view we need to pass the piece of URL instead of the page number.

        As a rule of thumb, only capture the values the view needs to work with and use non-capturing arguments when the regular expression needs an argument but the view ignores it.
        
        *  URLconf doesn’t look at the request method. In other words, all request methods – POST, GET, HEAD, etc. – will be routed to the same function for the same URL
        
        * error handling with 
        handler400 django.conf.urls.handler400
        https://docs.djangoproject.com/en/3.0/ref/urls/#django.conf.urls.handler400
        
        * static(),  URL pattern for serving files in debug mode
        
        urlpatterns = [...] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
        
        * including other URLconf
        path('community/', include('aggregator.urls'))
         
        it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing
        
        another use case of URL patterns by using a list of path() instances. For example, consider this URLconf
        
        from django.urls import include, path
        from . import views

        urlpatterns = [
            path('<page_slug>-<page_id>/', include([
                path('history/', views.history),
                path('edit/', views.edit),
                path('discuss/', views.discuss),
                path('permissions/', views.permissions),
            ])),
        ]
        
        avoid <page_slug>-<page_id> is written repeatedly 
        
        the included URL views will received parent captured parameters 
        
        * reverse resolution of URLs, to get final URLs after django generate it for any resources 
        
        in django we can do by URL mapper which support obtain from both direction 
        
        user/browser  URL  <== URLconf ==> resource identification
        
        in template using url template tag 
        in python code use reverse() function 
        
        example:
        
        //urlconf 
        ...
        path('articles/<int:year>/', views.year_archive, name='news-year-archive'),
        ...
        
        //template 
        a href="{% url 'news-year-archive' yearvar %}">{{ yearvar }} Archive</a>
        
        //python code, for example in a view 
        def foo(request):
            ...
            return HttpResponseRedirect(reverse('news-year-archive', args=(year,)))
        
        * naming URL patterns 
        
        Putting a prefix on your URL names, perhaps derived from the application name 
        
        reverse() matches the number of arguments and the names of the keyword arguments
        
        * URL namespaces 
        application namespace, every instance of a single application will have the same application namespace 
        
        instance namespace 
        unique across your entire project. this is used to specify a default instance of an application 
        
        namespace URL are specified using ':', '<namespace>:url_segment'
        
        support nested URL namespace 
        
        * reverse search process 
        
        the current application can be specified with the current_app argument to the reverse() function.
        
        default application 
        
        last deployed instance of the application 
        
        name not match then perform lookup 
        
        * URL namespaces and included URLconfs

        url_pattern_instances_pair = (<list of path instances>, application_name)
        
        path('polls/', include('polls.urls' | url_pattern_instances_pair )),
        
        will give application namespace polls 
        
    + A view function, or view for short, is a Python function that takes a Web request and returns a Web response. The response can be a web page, a redirect or  Http404 
    
    return HttpResponseNotFound(reason) from view 
    
    Django provides an Http404 exception. If you raise Http404 at any point in a view function
    
    raise Http404(reason) from view 
    
        * specify customizing error views in URLconf
        
        handler404 = '...'
        handler500 = '...'
        
        full example 
        
        from django.core.exceptions import PermissionDenied
        from django.http import HttpResponse
        from django.test import SimpleTestCase, override_settings
        from django.urls import path

        def response_error_handler(request, exception=None):
            return HttpResponse('Error handler content', status=403)

        def permission_denied_view(request):
            raise PermissionDenied

        urlpatterns = [
            path('403/', permission_denied_view),
        ]

        handler403 = response_error_handler

        # ROOT_URLCONF must specify the module that contains handler403 = ...
        @override_settings(ROOT_URLCONF=__name__)
        class CustomErrorHandlerTests(SimpleTestCase):

            def test_handler_renders_template_response(self):
                response = self.client.get('/403/')
                # Make assertions on the response here. For example:
                self.assertContains(response, 'Error handler content', status_code=403)
                
    + template engines to be used with Django 
    
    django template load from templates subdirectory by default 
    
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'APP_DIRS': True,
    },
]

    + put the following code in that template 
{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
    
    reference:
    https://docs.djangoproject.com/en/3.0/topics/templates/
    
    + load template in view 
from django.http import HttpResponse
from django.template import loader
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls/index.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
    
    + using shortcut render function to void create template object 
    from django.shortcuts import render
    
    from .models import Question


    def index(request):
        latest_question_list = Question.objects.order_by('-pub_date')[:5]
        context = {'latest_question_list': latest_question_list}
        return render(request, 'polls/template.html', context)
        
    + raise 404 
    raise Http404("Question does not exist")
    
    + shortcut get object or return 404
    from django.shortcuts import get_object_or_404, render

    ...
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})
    
    There’s also a get_list_or_404() function, which works just as get_object_or_404() – except using filter() instead of get().
    
    + namespace url template 
    //url config in module polls 
    path('<int:question_id>/', views.detail, name='detail'),
    
    <li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
    
    + request.POST is a dictionary-like object that lets you access submitted data by key name
    
- write minimal form 

TODO:
            
- django provide different kinds of views 
from django.views import generic

from .models import Choice, Question


class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        """Return the last five published questions."""
        return Question.objects.order_by('-pub_date')[:5]
- run test 
    + test model 
import datetime

from django.test import TestCase
from django.utils import timezone

from .models import Question


class QuestionModelTests(TestCase):

    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)

    + test view. the django test client
    setup test environment in the shell 
    $ python mange.py shell 
    
    >>> from django.test.utils import setup_test_environment
    >>> setup_test_environment()
    
    Django provides a test Client to simulate a user interacting with the code at the view level. We can use it in tests.py or even in the shell.
    
    >>> from django.test import Client
    >>> # create an instance of the client for our use
    >>> client = Client()
    
    >>> # get a response from '/'
    >>> response = client.get('/')
    Not Found: /
    >>> # we should expect a 404 from that address; if you instead see an
    >>> # "Invalid HTTP_HOST header" error and a 400 response, you probably
    >>> # omitted the setup_test_environment() call described earlier.
    >>> response.status_code
    404
    >>> # on the other hand we should expect to find something at '/polls/'
    >>> # we'll use 'reverse()' rather than a hardcoded URL
    >>> from django.urls import reverse
    >>> response = client.get(reverse('polls:index'))
    >>> response.status_code
    200
    >>> response.content
    b'\n    <ul>\n    \n        <li><a href="/polls/1/">What&#x27;s up?</a></li>\n    \n    </ul>\n\n'
    >>> response.context['latest_question_list']
    <QuerySet [<Question: What's up?>]>
    
    + write test for our views 
    def create_question(question_text, days):
        """
        Create a question with the given `question_text` and published the
        given number of `days` offset to now (negative for questions published
        in the past, positive for questions that have yet to be published).
        """
        time = timezone.now() + datetime.timedelta(days=days)
        return Question.objects.create(question_text=question_text, pub_date=time)


    class QuestionIndexViewTests(TestCase):
        def test_no_questions(self):
            """
            If no questions exist, an appropriate message is displayed.
            """
            response = self.client.get(reverse('polls:index'))
            self.assertEqual(response.status_code, 200)
            self.assertContains(response, "No polls are available.")
            self.assertQuerysetEqual(response.context['latest_question_list'], [])

        def test_past_question(self):
            """
            Questions with a pub_date in the past are displayed on the
            index page.
            """
            create_question(question_text="Past question.", days=-30)
            response = self.client.get(reverse('polls:index'))
            self.assertQuerysetEqual(
                response.context['latest_question_list'],
                ['<Question: Past question.>']
            )

        def test_future_question(self):
            """
            Questions with a pub_date in the future aren't displayed on
            the index page.
            """
            create_question(question_text="Future question.", days=30)
            response = self.client.get(reverse('polls:index'))
            self.assertContains(response, "No polls are available.")
            self.assertQuerysetEqual(response.context['latest_question_list'], [])

        def test_future_question_and_past_question(self):
            """
            Even if both past and future questions exist, only past questions
            are displayed.
            """
            create_question(question_text="Past question.", days=-30)
            create_question(question_text="Future question.", days=30)
            response = self.client.get(reverse('polls:index'))
            self.assertQuerysetEqual(
                response.context['latest_question_list'],
                ['<Question: Past question.>']
            )

        def test_two_past_questions(self):
            """
            The questions index page may display multiple questions.
            """
            create_question(question_text="Past question 1.", days=-30)
            create_question(question_text="Past question 2.", days=-5)
            response = self.client.get(reverse('polls:index'))
            self.assertQuerysetEqual(
                response.context['latest_question_list'],
                ['<Question: Past question 2.>', '<Question: Past question 1.>']
            )

$ python manage.py test [app_name]

    + liver server test case 
        
    from django.contrib.staticfiles.testing import StaticLiveServerTestCase
    from selenium.webdriver.firefox.webdriver import WebDriver

    class MySeleniumTests(StaticLiveServerTestCase):
        fixtures = ['user-data.json']

        @classmethod
        def setUpClass(cls):
            super().setUpClass()
            cls.selenium = WebDriver()
            cls.selenium.implicitly_wait(10)

        @classmethod
        def tearDownClass(cls):
            cls.selenium.quit()
            super().tearDownClass()

        def test_login(self):
            self.selenium.get('%s%s' % (self.live_server_url, '/login/'))
            username_input = self.selenium.find_element_by_name("username")
            username_input.send_keys('myuser')
            password_input = self.selenium.find_element_by_name("password")
            password_input.send_keys('secret')
            self.selenium.find_element_by_xpath('//input[@value="Log in"]').click()
            
    + The databases flag also controls which databases the TransactionTestCase.fixtures are loaded into

- handle static files. django.contrib.staticfiles is for: it collects static files from each of your applications (and any other places you specify) into a single location that can easily be served in production.

example to handle static file 
create style.css 

add template to use reference the file 
{% load static %}

<link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}">


The {% static %} template tag generates the absolute URL of static files.

- customize the admin form. By registering the Question model with admin.site.register(Question), Django was able to construct a default form representation. 

    + splite the form into fieldsets 
    
from django.contrib import admin

from .models import Question


class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date']}),
    ]

admin.site.register(Question, QuestionAdmin)

    + customize project's templates 
    
    Open your settings file (mysite/settings.py, remember) and add a DIRS option in the TEMPLATES setting
    
    + any django default template can be override inside django template directory 
     
    + all the sub apps are registered inside the INSTALLED_APPS
    
- Create reusable apps 
    + Create a file django-polls/README.rst with the following contents
    + add resource.rst 
    + add LICENSE file 
    + create setup.cfg and setup.py files which detail how to build and install the app. 
    + Only Python modules and packages are included in the package by default. To include additional files, we’ll need to create a MANIFEST.in file
    + create tar and instal with pip 
    + publish 
    
- test 
    + TransactionTestCase and TestCase are identical except for the manner in which the database is reset to a known state and the ability for test code to test the effects of commit and rollback
    + liver server test 

- verify 
import django 

print(django.get_version())

- django have a test tool for helping integrate project with selenium

liveServerTestCase 

reference 
https://docs.djangoproject.com/en/3.0/topics/testing/tools/#django.test.LiveServerTestCase

- django admin 

Site managers use the system to add news stories, events, sports scores, etc

    + create super user for admin 
    $ python manage.py createsuperuser
    
    + navigate to http://127.0.0.1:8000/admin/. You should see the admin’s login screen
    
- get latest development version 
$ git clone https://github.com/django/django.git 

- supported versions 
A.B 
A.B+1 

path release A.B.

long term support release(LTS) 


# Overview 
- models for data 
//models.py 
    + create data models 
from django.db import models

class Reporter(models.Model):
    full_name = models.CharField(max_length=70)

    def __str__(self):
        return self.full_name

class Article(models.Model):
    pub_date = models.DateField()
    headline = models.CharField(max_length=200)
    content = models.TextField()
    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)

    def __str__(self):
        return self.headline

    + create database tables 
$ python manage.py makemigrations
$ python manage.py migrate

- free API to access the data models 
>>> from news.models import Article, Reporter
>>> Reporter.objects.all()

>>> r = Reporter(full_name='John Smith')

>>> r.save()

>>> r.id
1

>>> Reporter.objects.all()
<QuerySet [<Reporter: John Smith>]>

>>> r.full_name
'John Smith'

>>> Reporter.objects.get(id=1)
<Reporter: John Smith>
- administrator interface, automatically create a professional, production ready administrative interface
//admin.py
from django.contrib import admin

from . import models

admin.site.register(models.Article)

- design urls 
//urls.py 
from django.urls import path

from . import views

urlpatterns = [
    path('articles/<int:year>/', views.year_archive),
    path('articles/<int:year>/<int:month>/', views.month_archive),
    path('articles/<int:year>/<int:month>/<int:pk>/', views.article_detail),
]

none of them matches, Django calls a special-case 404 view

- write views 
//views.js 
from django.shortcuts import render

from .models import Article

def year_archive(request, year):
    a_list = Article.objects.filter(pub_date__year=year)
    context = {'year': year, 'article_list': a_list}
    return render(request, 'news/year_archive.html', context)
    
- design your template 

    + reference template system, https://docs.djangoproject.com/en/2.2/topics/templates/
    
    the year_archive.html is a template 

    + template content 
//year_archive.html 
{% block title %}Articles for {{ year }}{% endblock %}

{% block content %}
<h1>Articles for {{ year }}</h1>

{% for article in article_list %}
    <p>{{ article.headline }}</p>
    <p>By {{ article.reporter.full_name }}</p>
    <p>Published {{ article.pub_date|date:"F j, Y" }}</p>
{% endfor %}
{% endblock %}

    + Django settings, you specify a list of directories to check for templates with DIRS. 

    + using filters in template | 
https://docs.djangoproject.com/en/2.2/howto/custom-template-tags/#howto-writing-custom-template-filters

- base template include use of static files 
https://docs.djangoproject.com/en/2.2/howto/static-files/

//base.html 
{% load static %}
<html>
<head>
    <title>{% block title %}{% endblock %}</title>
</head>
<body>
    <img src="{% static "images/sitelogo.png" %}" alt="Logo">
    {% block content %}{% endblock %}
</body>
</html>

- other 
syndication framework to create RSS and Atom, https://docs.djangoproject.com/en/2.2/ref/contrib/syndication/

cache framework, 


# Testing tools 
- 


# Writing views 
- reference 
https://docs.djangoproject.com/en/3.0/topics/http/views/

- A view function, or view for short, is a Python function that takes a Web request and returns a Web response.

- the convention is to put views in a file called views.py placed in your project or application directory 


from django.http import HttpResponse
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = "<html><body>It is now %s.</body></html>" % now
    return HttpResponse(html)

- Django includes a TIME_ZONE setting that defaults to America/Chicago
- return errors
https://docs.djangoproject.com/en/3.0/ref/request-response/#ref-httpresponse-subclasses

from django.http import HttpResponse, HttpResponseNotFound

def my_view(request):
    # ...
    if foo:
        return HttpResponseNotFound('<h1>Page not found</h1>')
    else:
        return HttpResponse('<h1>Page was found</h1>')

- Django provides an Http404 exception. If you raise Http404 at any point in a view function, Django will catch it and return the standard error page for your application, along with an HTTP error code 404.

from django.http import Http404
from django.shortcuts import render
from polls.models import Poll

def detail(request, poll_id):
    try:
        p = Poll.objects.get(pk=poll_id)
    except Poll.DoesNotExist:
        raise Http404("Poll does not exist")
    return render(request, 'polls/detail.html', {'poll': p})
    
   


# Using different testing frameworks 

# django 
- reference 
https://docs.djangoproject.com/en/3.0/topics/testing/tools/#django.test.LiveServerTestCase


# Python dependency injection 
- reference 
https://github.com/google/pinject

another popular library 
https://github.com/alecthomas/injector

- implicit class bindings 
>>> import pinject 
>>> class OuterClass(object):
...     def __init__(self, inner_class):
...         self.inner_class = inner_class
...
>>> class InnerClass(object):
...     def __init__(self):
...         self.forty_two = 42
...
>>> obj_graph = pinject.new_object_graph()
>>> outer_class = obj_graph.provide(OuterClass)
>>> print outer_class.inner_class.forty_two
42
>>>

require classes are named CamelCase, your args are named in lower_with_underscores. Pinject transforms class names to injectable arg names by lowercasing words and connecting them with underscores. It will also ignore any leading underscore on the class name 

Class name	Arg name
Foo	        foo
FooBar	    foo_bar
_Foo	    foo
_FooBar	    foo_bar

- new_object_graph(modules=None, class=[SomeClass]) by default looks in all imported modules

The modules arg specifies in which (python) modules to look for classes; this defaults to ALL_IMPORTED_MODULES
The classes arg specifies a exact list of classes; this defaults to None

- auto copying args to fields 

    + @copy_args_to_internal_fields prepends an underscore, field named _foo 
    
>>> class ClassWithTediousInitializer(object):
...     @pinject.copy_args_to_internal_fields
...     def __init__(self, foo, bar, baz, quux):
...         pass
...
>>> cwti = ClassWithTediousInitializer('a-foo', 'a-bar', 'a-baz', 'a-quux')
>>> print cwti._foo
'a-foo'

    + @copy_args_to_public_fields copies the arg named as-is, i.e., it copies an arg named foo to a field named foo

- binding specs, it is any python class that inherits from BindingSpec

Its configure() method can create explicit bindings to classes or instances, as well as requiring bindings without creating them.

Its dependencies() method can return depended-on binding specs.

It can have provider methods, for which explicit bindings are created.

Binding specs should generally live in files named binding_specs.py, where each file is named in the plural even if there is exactly one binding spec in it. 

>>> class SomeClass(object):
...     def __init__(self, long_name):
...         self.long_name = long_name
...
>>> class SomeReallyLongClassName(object):
...     def __init__(self):
...         self.foo = 'foo'
...
>>> class MyBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('long_name', to_class=SomeReallyLongClassName)
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[MyBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> print some_class.long_name.foo
'foo'
>>>

Using to_class binds to a class. When the binding is used, Pinject injects an instance of the class.

>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class MyBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='a-foo')
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[MyBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> print some_class.foo
'a-foo'

Using to_instance binds to an instance of some object.

- The configure() method of a binding spec also may take a function require() as an arg and use that function to require that a binding be present without actually defining that binding. 

>>> class MainBindingSpec(pinject.BindingSpec):
...     def configure(self, require):
...         require('foo')
...
>>> class RealFooBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='a-real-foo')
...
>>> class StubFooBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='a-stub-foo')
...
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> obj_graph = pinject.new_object_graph(
...     binding_specs=[MainBindingSpec(), RealFooBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> print some_class.foo
'a-real-foo'

- Binding specs can declare dependencies.
>>> class ClassOne(object):
...    def __init__(self, foo):
...        self.foo = foo
....
>>> class BindingSpecOne(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='foo-')
...
>>> class ClassTwo(object):
...     def __init__(self, class_one, bar):
...         self.foobar = class_one.foo + bar
...
>>> class BindingSpecTwo(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('bar', to_instance='-bar')
...     def dependencies(self):
...         return [BindingSpecOne()]
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[BindingSpecTwo()])
>>> class_two = obj_graph.provide(ClassTwo)
>>> print class_two.foobar
'foo--bar'

The default implementation of __eq__() in BindingSpec says that two binding specs are equal if they are of exactly the same python type. You will need to override __eq__() (as well as __hash__()) if your binding spec is parameterized

- provider methods,  start with provide_, and it assumes that the methods are providers for whatever the rest of their method names

>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def provide_foo(self):
...         return 'some-complex-foo'
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> print some_class.foo
'some-complex-foo'
>>>

- binding precedence, explicit binding take precedence over implicit bindings 

Explicit bindings are the bindings that come from binding specs.

Implicit bindings are the bindings created for classes in the modules and classes args passed to new_object_graph().

>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class Foo(object):
...     pass
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='foo-instance')
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> print some_class.foo
'foo-instance'
>>>

- safety, disable implicit binding 

    + new_object_graph() uses implicit bindings by default. If you worry that you may accidentally inject a class or use a provider function unintentionally, then you can make new_object_graph() ignore implicit bindings
    
    only_use_explicit_bindings=True.
    
    + If you want to promote an implicit binding to be an explicit binding, you can annotate the corresponding class with @inject(). The @inject() decorator lets you create explicit bindings without needing to create binding specs

- Pinject's default scope is SINGLETON. If you have a multi-threaded program, it's likely that some or all of the things that Pinject provides from singleton scope will be used in multiple threads. So, it's important that you ensure that such classes are thread-safe.

Similarly, it's important that your custom scope classes are thread-safe.

>>> class ExplicitlyBoundClass(object):
...     @pinject.inject()
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class ImplicitlyBoundClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_instance='explicit-foo')
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()],
...     only_use_explicit_bindings=True)
>>> # obj_graph.provide(ImplicitlyBoundClass)  # would raise a NonExplicitlyBoundClassError
>>> some_class = obj_graph.provide(ExplicitlyBoundClass)
>>> print some_class.foo
'explicit-foo'

- Pinject annotations let you have different objects injected for the same arg name.

    + On the arg side, an annotation tells Pinject only to inject using a binding whose binding key includes the annotation object.
    
    + On the binding side, an annotation changes the binding so that the key of the binding includes the annotation object.
    
>>> class SomeClass(object):
...     @pinject.annotate_arg('foo', 'annot')
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', annotated_with='annot', to_instance='foo-with-annot')
...         bind('foo', annotated_with=12345, to_instance='12345-foo')
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class = obj_graph.provide(SomeClass)
>>> print some_class.foo
'foo-with-annot'
>>>

annotated_with arg to specify the annotation object. The decorator's first param, arg_name

    + requiring a binding in the spec 
>>> class MainBindingSpec(pinject.BindingSpec):
...     def configure(self, require):
...         require('foo', annotated_with='annot')

- scopes, a single instance of bound-to class or instance is return by provider by default. Pinject will keep the singleton pattern 

>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def provide_foo(self):
...         return object()
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class_1 = obj_graph.provide(SomeClass)
>>> some_class_2 = obj_graph.provide(SomeClass)
>>> print some_class_1.foo is some_class_2.foo
True
>>>

    + A scope controls memoization (i.e., caching). A scope can choose to cache never,

    + Singleton scope (SINGLETON) is the default and always caches. Prototype scope (PROTOTYPE) is the other built-in option and does no caching whatsoever
    
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     @pinject.provides(in_scope=pinject.PROTOTYPE)
...     def provide_foo(self):
...         return object()
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> some_class_1 = obj_graph.provide(SomeClass)
>>> some_class_2 = obj_graph.provide(SomeClass)
>>> print some_class_1.foo is some_class_2.foo
False
>>>

    + Memoization of class bindings works at the class level, not at the binding key level. Two fieds of a same class will get the same instance 

- provider bindings, need to inject the ability to create instances on demand

>>> class Foo(object):
...   def __init__(self):
...     self.forty_two = 42
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def configure(self, bind):
...         bind('foo', to_class=Foo, in_scope=pinject.PROTOTYPE)
...
>>> class NeedsProvider(object):
...     def __init__(self, provide_foo):
...         self.provide_foo = provide_foo
...
>>> obj_graph = pinject.new_object_graph(binding_specs=[SomeBindingSpec()])
>>> needs_provider = obj_graph.provide(NeedsProvider)
>>> print needs_provider.provide_foo() is needs_provider.provide_foo()
False
>>> print needs_provider.provide_foo().forty_two
42
>>>

    + provider bindings, which let you inject args named provide_something with provider functions
    
    + provider methods, which are methods of binding specs that provide instances of some arg name.

- partial injection 
    + tell provider which args will be pass directly when call the provider function in Pinject
    
>>> class SomeBindingSpec(pinject.BindingSpec):
...     @pinject.inject(['widget_polisher'])
...     def provide_widget(self, color, widget_polisher):
...         return some_function_of(widget_polisher, color)
...     def provide_something_needing_widgets(self, colors, provide_widget):
...         return SomethingNeedingWidgets(
...             [provide_widget(color) for color in colors])
...
>>>

 there is a method called provide_widget() and an arg of provide_something_needing_widgets() called provide_widget, these are not exactly the same! The latter is a dependency-injected wrapper around the former.

>>> class Widget(object):
...     @pinject.inject(['widget_polisher'])
...     def __init__(self, color, widget_polisher):
...         pass  # normally something involving color and widget_polisher
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     def provide_something_needing_widgets(self, colors, provide_widget):
...         return SomethingNeedingWidgets(
...             [provide_widget(color) for color in colors])
...
>>>

    + The @inject() decorator also takes an all_except arg. You can use this, instead of the (first positional) arg_names instead of use the first arg of inject method to specify which args are not automatic injected. 
    
>>> class Widget(object):
...     # equivalent to @pinject.inject(['widget_polisher']):
...     @pinject.inject(all_except=['color'])
...     def __init__(self, color, widget_polisher):
...         pass  # normally something involving color and widget_polisher
...
>>>
    
- custom scopes is any class that implements the Scope interface. it is used when some objects need to be reused which lifetime is less than the entire lifetime of your program 

class Scope(object):
    def provide(self, binding_key, default_provider_fn):
        raise NotImplementedError()

>>> class MyScope(pinject.Scope):
...     def __init__(self):
...         self._cache = {}
...     def provide(self, binding_key, default_provider_fn):
...         if binding_key not in self._cache:
...             self._cache[binding_key] = default_provider_fn()
...         return self._cache[binding_key]
...     def clear(self):
...         self._cache = {}
...
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     @pinject.provides(in_scope='my custom scope')
...     def provide_foo(self):
...         return object()
...
>>> my_scope = MyScope()
>>> obj_graph = pinject.new_object_graph(
...     binding_specs=[SomeBindingSpec()],
...     id_to_scope={'my custom scope': my_scope})
>>> some_class_1 = obj_graph.provide(SomeClass)
>>> some_class_2 = obj_graph.provide(SomeClass)
>>> my_scope.clear()
>>> some_class_3 = obj_graph.provide(SomeClass)
>>> print some_class_1.foo is some_class_2.foo
True
>>> print some_class_2.foo is some_class_3.foo
False
>>>

The binding_key passed to provide() will be an object implementing __eq__() and __hash__(), default_provider_fn is a zero-arg function 

Scopes almost always have other methods that control clearing the scope's cache.

    + thread safe scope 
>>> class MyScope(pinject.Scope):
...     def __init__(self):
...         self._cache = {}
...         self._rlock = threading.RLock()
...     def provide(self, binding_key, default_provider_fn):
...         with self._rlock:
...             if binding_key not in self._cache:
...                 self._cache[binding_key] = default_provider_fn()
...             return self._cache[binding_key]
...     def clear(self):
...         with self._rlock:
...             self._cache = {}
>>>

- scope accessibility, Pinject lets you pass a validation function as the is_scope_usable_from_scope arg to new_object_graph(). This function takes two scope identifiers and returns True if an object in the first scope can be injected into an object of the second scope.

>>> class RequestScope(pinject.Scope):
...     def start_request(self):
...         self._cache = {}
...     def provide(self, binding_key, default_provider_fn):
...         if binding_key not in self._cache:
...             self._cache[binding_key] = default_provider_fn()
...         return self._cache[binding_key]
...
>>> class SomeClass(object):
...     def __init__(self, foo):
...         self.foo = foo
...
>>> class SomeBindingSpec(pinject.BindingSpec):
...     @pinject.provides(in_scope=pinject.SINGLETON)
...     def provide_foo(bar):
...         return 'foo-' + bar
...     @pinject.provides(in_scope='request scope')
...     def provide_bar():
...         return '-bar'
...
>>> def is_usable(scope_id_inner, scope_id_outer):
...     return not (scope_id_inner == 'request scope' and
...                 scope_id_outer == scoping.SINGLETON)
...
>>> my_request_scope = RequestScope()
>>> obj_graph = pinject.new_object_graph(
...     binding_specs=[SomeBindingSpec()],
...     id_to_scope={'request scope': my_request_scope},
...     is_scope_usable_from_scope=is_usable)
>>> my_request_scope.start_request()
>>> # obj_graph.provide(SomeClass)  # would raise a BadDependencyScopeError
>>>

- changing naming conventions 

- miscellaneous, pass use_short_stack_traces=False to new_object_graph() to help debugging the dependency injection problem 

- summary 
Pinject uses code and decorators to configure injection, not a separate config file.
Bindings are keyed by arg name, (not class type, since Python is dynamically typed).
Pinject automatically creates bindings to some_class arg names for SomeClass classes.
You can ask Pinject only to create bindings from binding specs and classes whose __init__() is marked with @inject().
A binding spec is a class that creates explicit bindings.
A binding spec can bind arg names to classes or to instances.
A binding spec can bind arg names foo to provider methods provide_foo().
Binding specs can depend on (i.e., include) other binding specs.
You can annotate args and bindings to distinguish among args/bindings for the same arg name.
Pinject has two built-in scopes: "singleton" (always memoized; the default) and "prototype" (never memoized).
You can define custom scopes, and you can configure which scopes are accessible from which other scopes.
Pinject doesn't allow injecting None by default, but you can turn off that check.