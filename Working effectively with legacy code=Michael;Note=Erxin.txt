Working effectively with legacy code=Michael;Note=Erxin

# The mechanics of change 
## Changing software
- The act of improving design without changing its behavior is called refactoring. The idea behind refactoring is that we can make software more maintainable without changing behavior

optimization 

- risky change 

what chagnes do we have to make 

how will we know that we've done them correctly 

how will we know that we haven't broken anything 

how much change can you afford if changes are risky


## working with feedback 
- changing only one piece of behavior at a time 

- unit testing 

error localization 

execution time 

coverage 

    + tests often masquerade as unit tests. a test not a unit test if 
    
    talks to a database 
    
    communicates across a network 
    
    it touches the file system 
    
    you have to do special things to your environment such as editing configuration files 
    
- legacy code change algorithm 

identify change points 

find test points 

break dependencies 

write tests 

make changes and refactor 


## Sensing and separation
- sensing, we break dependencies to sense when we can't access values our code 
- separation 
- fake objects, easy to write are a very valuable tool for sensing 

- mock objects are fakes that perform assertions internally 


## The seam model 
- a huge sheet of text 
- seams, This seam is what I call an object seam. We were able to change the method that is called without changing the method that calls it.

A place where you can vary behavior in a software system without editing in that place.

Such as macros in C++/C 

- object seams, abstract class 
- post receive error 


## Tools 
- automated refactoring tools 
- mock objects 
- unit testing harnesses 
- cpp unit lite, CppUnit other unit test libraries 
- nunit,.net unit test library 
- framework for integrated tests (FIT), FIT is a concise and elegant testing framework 

http://www.fitnesse.org/


# Changing software 
## I don't have much time and I have to change it 
- sprout methods 
identify change locations 

formulated as a single sequence of statements 

determine what local variables you need from the source 

sprouted method will need to return values to source methods, The source method might contain a lot of complicated code and a single sprout of a new method

thest driven development 

remove the comemnt in the source 

- sprout class, 
- wrap method 
- wrapper class 
- decorator pattern 


## It takes forever to maek a change 
- understanding 
- lag time

build system 

- dependency inversion principle 


## How do I add a feature 
- TDD
write a failing test 
get it to compile 
make it pass 
remove duplication 
repeat 

- Liskov substitution principle (LSP) violation.  Objects of subclasses should be substitutable for objects of their superclasses throughout our code


# I cann't get this class into a test harness 
- Objects of the class can't be created easily 
- The test harness won't easily build with the class in it 
- The constructor we need to use ahs bad side effects 
- Significant work happens in the constructor and we need to sense it 


# Dependency breaking techniques 









