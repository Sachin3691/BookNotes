Microsoft Official Course 2778A, Writing Queries Using Microsoft SQL Server 2008 Transact-Sql; note = eshang

Sql server components
1. database engine
2. analysis services
3. reporting services
4. integration services
;
5. full text search, replication, service broker, notification services

management tool
management, configuration manager, profiler, database engine tuning advisor, business intelligence development studio

database engine components
protocol, relational engine, storage engine, sqlos (operating system with a powerful api, bring together all system components)

Normalization, 标准化

ANSI, American National Standard Institute(ANSI)
ISO, International Standards Organization

ANSI-SQL, define by ANSI, other kinds of SQL script:
T-SQL, Transact SQL Microsoft implementation
PL/SQL, Procedural Language/SQL   Oracle's PL/SQL
IBM's SQL Procedual Language

Categories of SQL Statements
DML, DCL, DDL data defination language, TCL transactional control language, DQL sql select statements

T-SQL language:
Operator likes VB and variable definition likes batch files
arithmetic: +, -, *, /, %
assignment: =, set @varName = value
comparision: =, <, >, <>, !, >=, <=
logical: and, or, not
string: str0 + str1
;
Function:
rowset: return objects that can be used as table references
	containstable, opendatasource, openquery
aggregate: operate on a collection but return single value
	avg, checksum_agg, sum, count
ranking: return a ranking value fore each row in a partition
	rank, dense_rank
scalar: operate on a signle value and then return a single value
	create function dbo.ufn_cubicVolume
;
variables:
declare @varName as type

Control-of-flow statements
begin...end, break, goto, continue, if...else, while, return, waitfor

exception handling
begin try
	...
end try
begin catch
	...
end catch;
raiserror (... ... ); --raise the specify expception

select [distinct]...
[into new table]
from table...
where ...
group by...
having ...
order by ... [asc|desc]
;
Comparison Operators like VB
;
Filtering Data
where value0 = value1
where string0 like string1   -- %, replace zero or more; _, replace single char
where contains( collection, value)	--collection like columns, fuzzy search
where freetext(description, value) -- search columns for value match the meaning not just the exact word
;
logical operators
~, bit not
%, mod
^, bit exclusive or
|, bit or
other operators:
not, and, all, between, in ,like, or, some

Working with NULL value
NULL is unknow value, not zero or empty string and NULL not equal to NULL
anything compare to NULL returns UNKNOWN
NULL can't included in a calculation
"sparse" keyword can be used to conserve space in columns that allow null
is NULL, used for test something is NULL or not.
;
function:
isnull(column, value), if the column value is NULL then return value
nullif(), returns NULL if both specified expressions are equal
coalsce(arguments...), returns the first non NULL expression among the arguments

Labeling columns in result sets
columnName as otherName, rename columns in result.

Create more efficient queries
reduce these kinds of sentence in query:
like '%...', leading wildcards
!=, not in( collection ),  Negative condition test
Expression use two columns in the same table;
Expression use column names in search arguments; use index column if possible
Avoid use multiple aliase for same table

Aggregate Function
avg, mix, max, sum, count, grouping, var
Aggregate function can only appear in the select statement, compute/compute by and having clause
For NULL value, use ISNULL(columnName, repalceValue )
Exp:
	select avg( isnull( columnName, replaceValue) ) as aliasName
except count(*) exclude null value, count() include null value.

CLR integration, assemblies, such as c#,...
Implementing:
create assembly StringUtilitties from 
'PathToAssembly\StringUtilities.dll' --strDllPath
with PERMISSION_SET = SAFE;
;
create aggregate concatenate( @input nvarchar(40000))
returns nvarchar(4000)
external name [StringUtilities].[concatenate]
;
UDA, User Defined Aggregate, when UDA is loaded in can be use as buildin function

ROLLUP, CUBE
ROLLUP, generate a result set showing the aggregates for hierarchy of values in selected columns
CUBE, generates a result set that shows the aggregates for all combination of values in selected columns
Exp:
select a, b, c, sum(<expression>)
from t
group by ROLLUP(a,b,c)
;
--generates a subtotal for each unique combination of values for (a, b, c), (a, b) and (a)
;
group by CUBE(a,b,c)
--generates a row for each unique combination of values of (a, b, c), (a, b), (a, c), (b, c), (a), (b) and (c)

Pivot, converts values to columns
unpivot, convert columns to values
;
select * from table
pivot (sum(columnName)) for columnName in ( [value0], [value1] ) PVT

Grouping and Summarization
Group by
rollup, give a statistic about each group
one attribute: grouping_id, returns the level of grouping

join table can be use in the same table. You have to give the same table two alias name for this purpose. 
t0 join t1 on condition
;
Use user define function to return joined table
create function functionName( parameters )
returns table as return (select ... )

Limited the return results, top, tablesample
select top ( 10 [percent] ) * from tableName

use all, any exists to limited the subquerys
ntext, text, image cannot be used in subquerys

Common table expression(CTE), implement by WITH expression:
with CommonTableName( columnNamesOrColumnAliaNames ) as
(/*subquerys*/
	select columnExpression_For_ColumnNamesOrColumnAliaNames ...
)
Use CTE in recursive expression

Use Insert statement
insert [into] tableName (columnList) values( ... )
insert [into] tableName selectStatement
insert [into] tableName execute storeProcedureName(parameters)
insert top (#) into tableName selectStatements // use to insert top n rows to the aimTable
;
use set identity_insert on statement to insert identity column
;
use output statement to retrieve the value of identity column
insertStatement output columnList

Use Delete statement, likes insert.
;
Use Truncate statement, remove all rows from a table.
truncate table tableName
compare to the delete statement, truncate table do less log, fewer locks, and zero pages left in the table.

Transaction
Begin transaction, commit, rollback
;
begin transaction transactionName|@tranName
;
use set statement to set the database locker
set transaction isolation level <levelNumber>;
;
limited transaction to atomic operation

Querying Metadata, XML, FullText Indexes
;
Metadata, is data about stored data. Such as length of the column, relationship, and so on.
Begin with sql2000, we can use compatibility views to check the metadata.
select * from sys.sysobjects
;
All the system informations have been saved in sys module.
;
Information_schema use to check the current database schema, includes  columns, tableName, views and so on. 
information schema view examples
select column_name from information_schema.columns where table+name = n'product'
;
Dynamic Management views and functions
look at the internal working of sql server by TSQL
table:
CATEGORY	VIEW						FUNCTIONS
Execution	dm_exec_requests			dm_exec_sql_text
Index		dm_db_index_usage_stats		dm_db_missing_index_columns
I/O			dm_io_pending_io_requests	dm_io_virtual_file_stats
Operating System	dm_os_sys_info
;
sys.dm_exec_query_stats have saved all the executed sql squery's detail information, such as sqlHandle which can be use by dm_exec_sql_text
;
System stored Procedures and Functions
sotred procedures, name begin with sp_xxxx which can be selected from sys.sysobjects
;
sp_database, sp_tables, sp_columns, sp_statistics, sp_pkeys, sp_fkeys
dataBaseProperty, columnproperty, objectProperty, col_length, db_name, db_id

XML, implements by SQL Server 2008
Serialize means make sqlquery results to XML format
Deserialize means make XML format to sqlquery results
Deserialize by OpenXML function
XQuery support query based interaction with data stored in XML format
XML schema collections provide the ability to define schemas for typed XML storage.
;
XQuery base on the XPath query language. 
;
Before create xml variables ... much use CREATE XML SCHEMA first to regist the XML schema
;
XML is a build-in data type in sql server. have five methods
Query, Value, Exists, Modify, Nodes
;
Exp:
select * for xml auto {raw('elementName')|explicit}
for xml ... can be used for any rowset. 
;
OpenXML return a rowset
select * from openXML(parameters) with( columnName type, ... )
One useful storage procedure sp_xml_preparedocument

FullText Indexing and Querying Process
query->full-text index -> dataTable-> results
;
Enable full-text indexs in sql server by:
sp_fulltext_database 'enable'
Create the full-text index for the required tables(s)
sp_fulltext_table
Add query columns to the index
sp_fulltext_column
Set population options for index
sp_fulltext_table
;
Contains Predicate offer a complex syntax for using full-text indexed
contains( Name, '"Mountain" OR "Road"' )
Freetext Predicate used to search columns containing character-based data types
select * from textColumnName where freetext( textColumnName, var )
;
Functions:
freeTextTable, likes Contains and Freetext, but returns matches in table form.

Views
create|alter view viewName
as 
begin
	select ...
end
;
drop view viewName
we can changed data by view.
;
view can be indexed using Create Index
Precondition:
View must be defined suing the with schemabinding option.
create view viewName With Schemabinding
as
begin
	select ...
end
create unique clusterd index ... on ...
;
Partitioned Views
Can set a member tables across one or more servers, making the data appear as if from one table. Use union all statements to combine the rows form the member tables.
create table tableName (columnsName...)
create view viewName
select * from tableName0
unionall 
select * from tableName1
...

User defined function 
create|alter function functionName (parameters)
returns varType // such as int, table, ...
as 
begin
	...
end
;
Restriction:
If update data, use stored procedures instead
Objects referred to by the function have to be previously declared and created
;
Consider balance between performance and maintainability
If user define function is used in select or where statement, it will be executred for every row!!!!
;
Call user define function
functionName(parameters)

Stored Procedures
create procedure procedureName @ParameterName type [in|output|inoutput]
returns Type
as 
begin
	...
end
;
return a status value to a calling procedure

Stored Procedure, stored procedure don't return a value. Only functioin could return a value to the caller. 
create procedure Name @parameter type [in|out|inout]...
as
begin ... end
have to validataion all the input parameter

Trigger
A special typeo of stored procedure that executes when attempt modify the data in a table.
two categories of DML triggers: instead of (before) and after.
create trigger Name on table type // type = instead of insert, after insert|update|delete
begin
	...
end
;
a trigger apply to only on table
triggers must belong to the same schema as their target

Sql server works with Heterogeneous(多相的) Data, 从多种数据库中同时筛选数据，如Oracle, DB2
;
use distributed query to access another data source
use sp_addlinkedserver to define specific login
;
exec sp_addlinkedserver
	@server = 'Marketing',
	@srvproduct = 'Oracle',
	@provider = 'MSDAORA',
	@datasrc = 'OraServer'
;
exec sp_addlinkedsrvlogin
	@rmtsrvname = 'Marketing',
	@useself = 'false',
	@locallogin = 'Mary',
	@rmtuser = 'MaryP',
	@rmtpassword = '...'
;
Using Ad hoc Distributed query
select * from openDataSource('msdaora', 'data source=OraServer; user=name; password=...').catalog.dbo.table'
select * from openRowset('msdaora', 'oraServer', 'name', 'password', 'select * from dataName.dbo.table')
select * from openQuery(OracleSvr, 'select * from talbe')

Execution Plans represent the execution cost of specific statements

cast with convert
cast is comply with ISO.
convert take advantage of style functionality

Date, time type
DataType		Format		Accuracy
time			hh:mm:ss	100 nanoseconds
date			YYYY-MM-DD	1 day
smalldatetime	YYYY-MM-DD	1 minute
				hh:mm:ss
datetime		YYYY-MM-DD	0.00333 seconds
				hh:mm:ss[.nnn]
datetime2					100 nanoseconds
datetimeoffset				100 nanoseconds

Using Dynamic SQL
;
use SQL generate sql script and run it with the store procedure
@sqlString = '....'
sp_executesql @sqlString
exec|execute @sqlString [output]
;
Should consider:
sql injection
security is checked for every object
use sp_executesql for best chance at plan reuse

Sqlcmd is command line operator

sql server could connect to Excel file

using trigger to get the relative changed data
There are only 2 reserved or special tables for Triggers.
1.    Inserted
2.    Deleted
On Insert:
Newly inserted rows will be available on the Inserted table
Deleted table row count will be ZERO
On Update
Newly modified data will be available on the Inserted Table
Deleted table hold the previous data(before update)
On Delete
Inserted table row count will be ZERO
Just deleted rows will be available on the Deleted table
For getting the updated result you can use the INSERTED table.

using remote connection to another sql server
DECLARE @svrname as nvarchar(max)
SET @svrname = '192.168.2.99\sqlexpress'
if not exists(SELECT server_id from sys.servers where name=@svrname)
	EXEC master.dbo.sp_addlinkedserver @server=@svrname, @srvproduct=N'SQL Server'
EXEC master.dbo.sp_addlinkedsrvlogin @rmtsrvname=@svrname, @locallogin=NULL, @useself=N'False', @rmtuser='IEUSER', @rmtpassword='IEUSER'
SELECT * from [192.168.2.99\sqlexpress].BeemDB.dbo.map_recipe_to_process_id
drop the linked server
sp_dropserver '192.168.2.99\sqlexpress', 'droplogins'
check server name
SELECT @@SERVERNAME, SERVERPROPERTY('MachineName')


reset identity column in three ways
1. truncate table table_name
2. DBCC CHECKIDENT (yourtableName, reseed, @NewStartSeedValue)
3. remove and switch the table by alter
/*Define table with same structure but no IDENTITY*/
CREATE TABLE Temp
(
ID INT PRIMARY KEY,
X VARCHAR(10)
)

/*Switch table metadata to new structure*/
ALTER TABLE Test SWITCH TO Temp;

/*Do the update*/
UPDATE Temp SET ID = ID + 1;

/*Switch table metadata back*/
ALTER TABLE Temp SWITCH TO Test;

/*ID values have been updated*/
SELECT *
FROM Test

/*Safety check in case error in preceding step*/
IF NOT EXISTS(SELECT * FROM Temp)
    DROP TABLE Temp /*Drop obsolete table*/

## dynamic sql 
- artical reference address
http://www.sommarskog.se/dynamic_sql.html
- two main roads to go
    + Send SQL statements from the client to SQL Server. 
    + Perform access through stored procedures.
- sp_executesql and EXEC() in detail
- bad dynamic sql example
CREATE PROCEDURE general_select1 @tblname sysname,
                                 @key     varchar(10) AS
DECLARE @sql nvarchar(4000)
SELECT @sql = ' SELECT col1, col2, col3 ' +
              ' FROM dbo.' + quotename(@tblname) +
              ' WHERE keycol = @key'
EXEC sp_executesql @sql, N'@key varchar(10)', @key
CREATE PROCEDURE general_select2 @tblname nvarchar(127),
                                 @key     varchar(10) AS
EXEC('SELECT col1, col2, col3
      FROM ' + @tblname + '
      WHERE keycol = ''' + @key + '''')
 You may know that when you use stored procedures, users do not need permissions to access the tables accessed by the stored procedure. This does not apply when you use dynamic SQL! 
 This example need the user have the select permission to the table
- number of consequences
    + Within the block of dynamic SQL, you cannot access local variables (including table variables) or parameters of the calling stored procedure. But you can pass parameters – in and out – to a block of dynamic SQL if you use sp_executesql.
    + Any USE statement in the dynamic SQL will not affect the calling stored procedure.
    + Temp tables created in the dynamic SQL will not be accessible from the calling procedure since they are dropped when the dynamic SQL exits. (Compare to how temp tables created in a stored procedure go away when you exit the procedure.) The block of dynamic SQL can however access temp tables created by the calling procedure.
    + If you issue a SET command in the dynamic SQL, the effect of the SET command lasts for the duration of the block of dynamic SQL only and does not affect the caller.
    + The query plan for the stored procedure does not include the dynamic SQL. The block of dynamic SQL has a query plan of its own.
- sp_executesql @stmt, @parameters
it is a built-in stored procedure that takes two pre-defined parameters and any number of user-defined parameters. 
@stmt
    The data type of @stmt is ntext in SQL 7 and SQL 2000, and nvarchar(MAX) in SQL 2005 and later. Beware that you must pass an nvarchar/ntext value 
 @parameters is the same used to specify the parameters for the procedure
    + ex.
       SELECT @sql =
       N' SELECT @cnt = COUNT(*) FROM dbo.' + quotename(@tbl) +
       N' WHERE LastUpdated BETWEEN @fromdate AND ' +
       N'                           coalesce(@todate, ''99991231'')'
       SELECT @params = N'@fromdate datetime, ' +
                        N'@todate   datetime = NULL, ' +
                        N'@cnt      int      OUTPUT'
       EXEC sp_executesql @sql, @params, '20060101', @cnt = @count OUTPUT
- the reason of dynamic sql is You can't specify a table name through a variable in T-SQL. It need to plug in with string
- EXEC() takes one parameter which is an SQL statement to execute. 
FETCH tblcur INTO @tbl
IF @@fetch_status <> 0 BREAK
SELECT @sql = 'UPDATE STATISTICS ' + quotename(@tbl) + ' WITH FULLSCAN'
EXEC(@sql)
- sql injection attack
an attacker first tests what happens if he enters a single quote (') in an input field or a URL. If this yields a syntax error, the attacker knows that there is a vulnerability
Thus, be very careful how you handle anything that comes into  your application from the outside.
- prevent sql inject three steadfast principles you need to follow
    + Never run with more privileges than necessary. 
    + For web applications: never expose error messages from SQL Server to the end user.
    + Always used parameterised statements. That is, in a T-SQL procedure use sp_executesql, not EXEC(). 
- use the cache to accelerate the dynamic sql excution
All this changes, if you instead use sp_executesql to run your query with parameters:
DECLARE @sql nvarchar(2000)
SELECT @sql = 'SELECT O.OrderID, SUM(OD.UnitPrice * OD.Quantity)
               FROM   dbo.Orders O
               JOIN   dbo.[Order Details] OD ON O.OrderID = OD.OrderID
               WHERE  O.OrderDate BETWEEN @from AND @to
                 AND  EXISTS (SELECT *
                              FROM   dbo.[Order Details] OD2
                              WHERE  O.OrderID = OD2.OrderID
                                AND  OD2.ProductID = @prodid)
                GROUP  BY O.OrderID'
EXEC sp_executesql @sql, N'@from datetime, @to datetime, @prodid int',
                   '19980201', '19980228', 76
The principle for cache lookup is the same as for a non-parameterised query: SQL Server hashes the query text and looks up the hash value in the cache, still in a case- and space-sensitive fashion
- query all reference relative to a table
 find all references by using the system stored procedure sp_depends or query a system table directly
- exec on a linked server
EXEC('SELECT COUNT(*) FROM ' + @db + '.dbo.sysobjects') AT SQL2K
SQL2K is a server name added by   sp_addlinkedserver.
specify a another user to run dynamic sql on linked server
As with regular EXEC(), you can specify AS USER/LOGIN to use impersonation:
EXEC('SELECT COUNT(*) FROM ' + @db + '.dbo.sysobjects')
    AS USER = 'davidson' AT SQL2K
- create synonyms for a long verbose database reference name, especially when do a remote procedure call
The best solution for this particular problem is to use synonyms, added in SQL 2005:
CREATE SYNONYM otherdbtbl FOR otherdb.dbo.tbl
- doing something in each linked database
sp_MSforeachdb 'SELECT ''?'', COUNT(*) FROM sysobjects'
- Creating an Object in Another Database
SELECT @sql = 'CREATE VIEW ...'
SELECT @sp_executesql = quotename(@dbname) + '..sp_executesql'
EXEC @sp_executesql @sql
- select * from tbl where @condition
SELECT * FROM tbl WHERE @condition
If you are considering to write the procedure
CREATE PROCEDURE search_sp @condition varchar(8000) AS
   SELECT * FROM tbl WHERE @condition
Just forget it. If you are doing this, you have not completed the transition to use stored procedure and you are still assembling your SQL code in the client. But this example lapses into
- if else then statement in sql
[1996] = SUM(CASE Year(OrderDate) WHEN '1996' THEN 1 ELSE 0 END
- select top @n from tbl
On SQL 2000, TOP does not accept variables, so you need to use dynamic SQL to use TOP. But there is an alternative:
CREATE PROCEDURE get_first_n @n int AS
SET ROWCOUNT @n
SELECT au_id, au_lname, au_fname
FROM   authors
ORDER  BY au_id
SET ROWCOUNT 0
- use the dynamic sql with link server
EXEC sp_addlinkedserver MYSRV, @srvproduct='Any',
                               @provider='SQLOLEDB', @datasrc=@@SERVERNAME
go
CREATE PROCEDURE linksrv_demo_inner WITH RECOMPILE AS
   SELECT * FROM MYSRV.master.dbo.sysdatabases
go
EXEC sp_dropserver MYSRV
go
CREATE PROCEDURE linksrv_demo @server sysname AS
   IF EXISTS (SELECT * FROM master..sysservers WHERE srvname = 'MYSRV')
      EXEC sp_dropserver MYSRV
   EXEC sp_addlinkedserver MYSRV, @srvproduct='Any',
                           @provider='SQLOLEDB', @datasrc=@server
   EXEC linksrv_demo_inner
   EXEC sp_dropserver MYSRV
go
EXEC linksrv_demo 'Server1'
EXEC linksrv_demo 'Server2'
    + The code snippets drawback:
    The procedure must be run by someone who has privileges to set up linked servers, normally only the roles sysadmin and setupadmin
 
 # giving permissions through stored procedures
 - the procedures perform validations of business rules to protect the integrity of the database
    + ownership chaining
    + signing procedures with certificates
    + using impersonation with execute as
- create schema, the command need to call in a isolate batch
go
CREATE SCHEMA myschema
go
- create new user for a schema
The preferred way to create a user since SQL 2005 is:
CREATE USER newuser [WITH DEFAULT_SCHEMA = someschema]
there are two sp are both deprecated, sp_adduser and  sp_grantdbaccess
- create user for test only
CREATE USER thisdbonly WITHOUT LOGIN
- create role
 CREATE ROLE that replaces sp_addrole in the same vein that CREATE USER replaces sp_adduser
- ownership chain
A -> B -> C, A only need the permission to access B, don't need the permission to access C. This is a simple example of ownership chain
    + there are permissions that cannot be transferred through ownership chaining
    + most of the time dbo own all schema and store procedures
    + the owner chain example
    http://www.sommarskog.se/grantperm.html
    + Essentially, ownership chaining applies to DML statements (SELECT, INSERT, DELETE, UPDATE and MERGE) and EXECUTE of stored procedures and functions. If you put a statement like CREATE TABLE into a stored procedure, the user must have permissions to create tables or truncate table, chaining does not work is BULK INSERT, this command requires a server level permission
- change owner
ALTER AUTHORIZATION ON sp2procowner TO procowner
- introduce use CLR to do the sync process
grant the users direct permissions to these tables or employ module signing or impersonation
the reference docs link, describe how to use c# or vb.net to write a store procedure and regist into sql server
http://msdn.microsoft.com/en-us/library/ms345102.aspx
- cross data access
If a stored procedure sp1 in database A accesses a table  tbl2 in database B, ownership chaining can apply as well.   In the trivial case, the two databases have the same owners and all involved objects are owned by dbo. The user running sp1 must also be a user in database B.
- enable special database for cross database access
To open an individual database for cross-db chaining, use the command ALTER DATABASE db SET DB_CHAINING ON
- the reason for disable cross database secrets chain
Jack can get to Jill's inner secrets, by taking the following steps.
1.Add Jill as a user in his own database.
2.Create a schema in his database owned by Jill.
3.Create stored procedures in the Jill schema that accesses Jill's database. Since Jill owns the schema, she also owns the procedures, as noted above. (Jack could also create the procedures in the dbo schema, and then make Jill owner of those procedures.)
Jack can now access all tables in Jill's database as he likes. 
- instead of the cross database responsible chain, I recommend that you try to keep cross-database access to stored procedure calls. And give the other uses the execute permissions
- signing procedures with certificates
Our example setup is this one:
CREATE TABLE testtbl (a int NOT NULL,
                      b int NOT NULL)
go
CREATE PROCEDURE example_sp AS
   EXEC ('SELECT a, b FROM testtbl')
go
GRANT EXECUTE ON example_sp TO public
go
the exec don't have a real owner, so it break the ownership chain. to let the procedure have the permission need four steps
1.Create a certificate.
2.Create a user associated with that certificate.
3.Grant that user SELECT rights on  testtbl.
4.Sign the procedure with the certificate, each time you have changed the procedure.
- the authenticator info is visible through the sys.user_token and sys.login_token views
- create the certificate
CREATE CERTIFICATE examplecert
    ENCRYPTION BY PASSWORD = 'All you need is love'
    WITH SUBJECT = 'Certificate for example_sp',
    START_DATE = '20020101', EXPIRY_DATE = '21000101'
- create the certificate user
CREATE USER examplecertuser FROM CERTIFICATE examplecert
- granting rights to the certificate user
grant select on proc_name to examplecertuser
- if you use a lot of dynamic SQL, you may prefer to grant the certificate user SELECT on the dbo schema or add it to db_datareader
- syntax to sign a procedure
ADD SIGNATURE TO example_sp BY CERTIFICATE examplecert
    WITH PASSWORD = 'All you need is love'
- putting all together
    USE master
    go
    -- Create a test login and test database
    CREATE LOGIN testuser WITH PASSWORD = 'CeRT=0=TeST'
    CREATE DATABASE certtest
    go
    -- Move to the test database.
    USE certtest
    go
    -- Create the test user.
    CREATE USER testuser
    go
    -- Create the test table and add some data.
    CREATE TABLE testtbl (a int NOT NULL,
                          b int NOT NULL)
    INSERT testtbl (a, b) VALUES (47, 11)
    go
    -- Create two test stored procedures, and grant permission.
    CREATE PROCEDURE unsigned_sp AS
       SELECT SYSTEM_USER, USER, name, type, usage FROM sys.user_token
       EXEC ('SELECT a, b FROM testtbl')
    go
    CREATE PROCEDURE example_sp AS
       SELECT SYSTEM_USER, USER, name, type, usage FROM sys.user_token
       EXEC ('SELECT a, b FROM testtbl')
       -- EXEC unsigned_sp
    go
    GRANT EXECUTE ON example_sp TO public
    GRANT EXECUTE ON unsigned_sp TO public
    go
    -- Create the certificate.
    CREATE CERTIFICATE examplecert
       ENCRYPTION BY PASSWORD = 'All you need is love'
       WITH SUBJECT = 'Certificate for example_sp',
       START_DATE = '20020101', EXPIRY_DATE = '20200101'
    go
    -- Create the certificate user and give it rights to access the test table.
    CREATE USER examplecertuser FROM CERTIFICATE examplecert
    GRANT SELECT ON testtbl TO examplecertuser
    go
    -- Sign the procedure.
    ADD SIGNATURE TO example_sp BY CERTIFICATE examplecert
        WITH PASSWORD = 'All you need is love'
    go
    -- Run as the test user, to actually see that this works.
    EXECUTE AS USER = 'testuser'
    go
    -- First run the unsigned procedure. This gives a permission error.
    EXEC unsigned_sp
    go
    -- Then run the signed procedure. Now we get the data back.
    EXEC example_sp
    go
    -- Become ourselves again.
    REVERT
    go
    -- Clean up
    USE master
    DROP DATABASE certtest
    DROP LOGIN testuser
- the REVERT statement 
Switches the execution context back to the caller of the last EXECUTE AS statement. 
- Using Certificates with Bulk Copy
give users permissions to empty a table and reload it with BULK INSERT from a file. Here is a very simple procedure for this task, the ownership chain does not suffice
CREATE PROCEDURE reload_sp AS
   TRUNCATE TABLE reloadable
   BULK INSERT reloadable FROM 'E:\temp\reloadable.csv'
      WITH (FIELDTERMINATOR=',', ROWTERMINATOR='\n')
the two reason ownership chain failed are  reasons: 1) it does not apply to TRUNCATE TABLE. 2) to perform bulk operations, you need the server-level permission ADMINISTER BULK OPERATIONS or membership in the fixed server role bulkadmin,  set up reload_sp so it can be executed by an unprivileged user.
1.Create a certificate in the master database.
2.Create a login for that certificate.
3.Grant that login rights to perform bulk operations.
4.Export the certificate to file.
5.Switch to the application database.
6.Import the certificate from the file.
7.Delete the file from disk.
8.Create a user for the certificate.
9.Grant the certificate user rights to truncate the target table and insert into it.
10.Sign the stored procedure with the certificate, each time you have changed the procedure.
    + code example
    USE master
    go
    CREATE CERTIFICATE reloadcert
       ENCRYPTION BY PASSWORD = 'All you need is love'
       WITH SUBJECT = 'For bulk-load privileges',
       START_DATE = '20020101', EXPIRY_DATE = '20200101'
    go
    CREATE LOGIN reloadcert_login FROM CERTIFICATE reloadcert
    go
    GRANT ADMINISTER BULK OPERATIONS TO reloadcert_login
    go
    BACKUP CERTIFICATE reloadcert TO FILE = 'C:\temp\reloadcert.cer'
    WITH PRIVATE KEY (FILE = 'C:\temp\reloadcert.pvk' ,
                      ENCRYPTION BY PASSWORD = 'Tomorrow never knows',
                      DECRYPTION BY PASSWORD = 'All you need is love')
    go
    + reused the backup certificate from the previous saved location
    CREATE CERTIFICATE reloadcert FROM FILE = 'C:\temp\reloadcert.cer'
    WITH PRIVATE KEY (FILE = 'C:\temp\reloadcert.pvk',
                      DECRYPTION BY PASSWORD = 'Tomorrow never knows',
                      ENCRYPTION BY PASSWORD = 'A day in life')
    go
    EXEC xp_cmdshell 'DEL C:\temp\reloadcert.*'
    go
    CREATE USER reloadcert_user FOR CERTIFICATE reloadcert
    go
    GRANT ALTER, INSERT ON reloadable TO reloadcert_user
    go
    -- Sign the test procedure each time you have changed it.
    ADD SIGNATURE TO reload_sp BY CERTIFICATE reloadcert
        WITH PASSWORD = 'A day in life'
    go
    +  run the procedure reload_sp as a non-privileged user
    CREATE PROCEDURE reload_sp AS
        TRUNCATE TABLE reloadable
        EXEC('BULK INSERT reloadable FROM ''C:\temp\reloadtest.csv''
              WITH (FIELDTERMINATOR='','', ROWTERMINATOR=''\n'')')
    + the full example could be found at 
    http://www.sommarskog.se/grantperm.html#certandbulkcopy, full example of builk-load
- get the current database file location
SELECT substring(physical_name, 1, len(physical_name) -
                                   charindex('\', reverse(physical_name)) + 1)
FROM   sys.database_files
WHERE  file_id = 1
- new features in sql 2012, CREATE CERTIFICATE FROM BINARY in SQL 2012
DECLARE @public_key varbinary(MAX) = certencoded(my_cert),
        @private_key varbinary(MAX) = 
            certprivatekey(my_cert, 'private_key_password', 'public_key_password')
CREATE CERTIFICATE newcert
FROM BINARY = @public_key
WITH PRIVATE KEY (BINARY = @private_key,
                  DECRYPTION BY PASSWORD = 'private_key_password',
                  ENCRYPTION BY PASSWORD = 'new_public_key_password')
    + the new feature influence the BULK copy script in the previous example
    DECLARE @sql nvarchar(MAX)
    SELECT @sql = 
       'CREATE CERTIFICATE reloadcert 
        FROM BINARY = ' + convert(nvarchar(MAX), pubkey, 1) + '
        WITH PRIVATE KEY (BINARY = ' + convert(nvarchar(MAX), privkey, 1) + ',
                          DECRYPTION BY PASSWORD = ''Tomorrow never knows'',
                          ENCRYPTION BY PASSWORD = ''A day in life'')'
    FROM #keys
    PRINT @sql
    EXEC (@sql)
    DROP TABLE #keys 
    this support copy the certification from one computer to the database computer
- cross database access
when you need to write a stored procedure that accesses data in another database, you can arrange permissions by signing your procedure with a certificate that exists in both database
    + cross database access code example
    USE master
    go
    -- Create a test login.
    CREATE LOGIN testuser WITH PASSWORD = 'CeRT=0=TeST'
    go
    -- Create test two databases
    CREATE DATABASE db1
    CREATE DATABASE db2
    go
    -- Move to first test database.
    USE db1
    go
    -- Create certificate in db1
    CREATE CERTIFICATE crossdbcert
       ENCRYPTION BY PASSWORD = 'Lucy in the Skies with Diamonds'
       WITH SUBJECT = 'Cross-db test',
       START_DATE = '20020101', EXPIRY_DATE = '20200101'
    go
    -- Save the certificate to disk.
    BACKUP CERTIFICATE crossdbcert TO FILE = 'C:\temp\crossdbcert.cer'
    WITH PRIVATE KEY (FILE = 'C:\temp\crossdbcert.pvk' ,
                      ENCRYPTION BY PASSWORD = 'She said She said',
                      DECRYPTION BY PASSWORD = 'Lucy in the Skies with Diamonds')
    go
    -- Create the certificate user. Note that we do not grant access to
    -- testuser.
    CREATE USER certuser FROM CERTIFICATE crossdbcert
    go
    -- A test table.
    CREATE TABLE testtbl (a int NOT NULL,
                          b int NOT NULL,
                          c int NOT NULL)
    go
    -- Insert some test data.
    INSERT testtbl (a, b, c) VALUES (12, 23, 34)
    go
    -- The certificate user needs to access this table.
    GRANT SELECT ON testtbl TO certuser
    go
    -- Switch to the second database.
    USE db2
    go
    -- Welcome the test user to this database.
    CREATE USER testuser
    go
    -- Signed test procedure.
    CREATE PROCEDURE signed_sp AS
        SELECT a, b, c FROM db1..testtbl
    go
    -- Same code, but we will leave this one unsigned.
    CREATE PROCEDURE unsigned_sp AS
        SELECT a, b, c FROM db1..testtbl
    go
    -- Give test user right to execute the procedures.
    GRANT EXECUTE ON signed_sp TO testuser
    GRANT EXECUTE ON unsigned_sp TO testuser
    go
    -- Import the certificate we created in the first test database into the second.
    CREATE CERTIFICATE crossdbcert FROM FILE = 'C:\temp\crossdbcert.cer'
    WITH PRIVATE KEY (FILE = 'C:\temp\crossdbcert.pvk',
                      DECRYPTION BY PASSWORD = 'She said She said',
                      ENCRYPTION BY PASSWORD = 'Helter Skelter')
    go
    -- Delete the file with the certificate.
    EXEC master..xp_cmdshell 'DEL C:\temp\crossdbcert.*', 'no_output'
    go
    -- Sign the test procedures.
    ADD SIGNATURE TO signed_sp BY CERTIFICATE crossdbcert
        WITH PASSWORD = 'Helter Skelter'
    go
    -- Switch to the test login.
    EXECUTE AS LOGIN = 'testuser'
    go
    -- Run the unsigned procedure. You will get a permission error.
    EXEC unsigned_sp
    go
    -- Run the signed procedure. testuser can now access testdbl, even though
    -- he is not a user of db1.
    EXEC signed_sp
    go
    -- Back to ourselves.
    REVERT
    go
    -- Clean up.
    USE master
    go
    DROP DATABASE db1
    DROP DATABASE db2
    DROP LOGIN testuser
- grant command syntax
 GRANT <some permission> ON <some object> TO <some user, login, or group>. 
 http://technet.microsoft.com/en-us/library/ms187965.aspx
 The REVOKE statement can be used to remove granted permissions, and the DENY statement can be used to prevent a principal from gaining a specific permission through a GRANT
 sp_helprotect system stored procedure reports permissions on a database-level securable
 - counter signatures
 When you counter-sign a procedure P1 with a certificate C,  there is also a procedure P2 that has been signed with C. when you call an inner procedure from a signed procedure, the certificate user is removed from the user token. But when P1 is counter-signed with C, the certificate user remains in the user token. The net effect of this is that you can get the powers of P1 only if you call it through P2.
    + code example
    USE master
    go
    -- Create a test login and test database.
    CREATE LOGIN testuser WITH PASSWORD = 'CeRT=0=TeST'
    CREATE DATABASE certtest
    go
    -- Move to the test database.
    USE certtest
    go
    -- Create the test user, and grant him permission to execute any
    -- stored procedure.
    CREATE USER testuser
    GRANT EXECUTE TO testuser
    go
    -- Create a test table and add some data.
    CREATE TABLE testtbl (a     int     NOT NULL,
                          b     int     NOT NULL,
                          owner sysname NOT NULL)
    INSERT testtbl (a, b, owner) VALUES (47, 11, 'testuser')
    INSERT testtbl (a, b, owner) VALUES (17, 89, 'someotheruser')
    go
    -- This is the inner procedure that permits you to view all data,
    -- but the selection could be constrained to a certain owner.
    CREATE PROCEDURE inner_sp @owner sysname = NULL AS
       SELECT SYSTEM_USER, USER, name, type, usage FROM sys.user_token
       DECLARE @sql nvarchar(MAX)
       SELECT @sql = N'SELECT a, b FROM testtbl WHERE 1 = 1 '
       IF @owner IS NOT NULL
          SELECT @sql = @sql + ' AND owner = @owner'
       EXEC sp_executesql @sql, N'@owner sysname', @owner
    go
    -- The outer procedure which forces the owner to be the current user.
    CREATE PROCEDURE outer_sp AS
       SELECT SYSTEM_USER, USER, name, type, usage FROM sys.user_token
       DECLARE @owner sysname
       SELECT @owner = SYSTEM_USER
       EXEC inner_sp @owner
    go
    -- Create the certificate.
    CREATE CERTIFICATE examplecert
       ENCRYPTION BY PASSWORD = 'Being for the benefit of Mr Kite'
       WITH SUBJECT = 'Certificate for counter-sign example',
       START_DATE = '20020101', EXPIRY_DATE = '20200101'
    go
    -- Create the certificate user and grant access the test table.
    CREATE USER examplecertuser FROM CERTIFICATE examplecert
    GRANT SELECT ON testtbl TO examplecertuser
    go
    -- Sign the outer procedure.
    ADD SIGNATURE TO outer_sp BY CERTIFICATE examplecert
        WITH PASSWORD = 'Being for the benefit of Mr Kite'
    go
    -- And counter-sign the inner procedure.
    ADD COUNTER SIGNATURE TO inner_sp BY CERTIFICATE examplecert
        WITH PASSWORD = 'Being for the benefit of Mr Kite'
    go
    -- Run as the test user, to actually see that this works.
    EXECUTE AS USER = 'testuser'
    go
    -- First run the inner procedure directly. This gives a permission
    -- error.
    EXEC inner_sp
    go
    -- Then run the outer procedure. Now we get the data back, but
    -- only what we are permitted to see.
    EXEC outer_sp
    go
    -- Become ourselves again.
    REVERT
    go
    -- Clean up.
    USE master
    DROP DATABASE certtest
    DROP LOGIN testuser
- Using Asymmetric Keys
Instead of signing your procedure with certificate, you can use asymmetric keys
    + practice differences between signing procedures
    asymmetric key never expire
    don't need to specify a subject
    you can't export a asymmetric key from a database. If you want to sign procedures in two database with same key, you need to create it outside the sql server and import it into the database
    The key for a certificate in SQL Server is always 1024 bits, where as for an asymmetric key you can choose between 512, 1024 and 2048 bits. It's possible that there is a performance gain by using a shorter key for signing your procedures.
- check which procedure have been signed by which certificates
SELECT Module = object_name(cp.major_id),
       [Cert/Key] = coalesce(c.name, a.name),
       cp.crypt_type_desc
FROM   sys.crypt_properties cp
LEFT   JOIN sys.certificates c    ON c.thumbprint = cp.thumbprint
LEFT   JOIN sys.asymmetric_keys a ON a.thumbprint = cp.thumbprint
-  find the users mapped to certificates
SELECT certname = c.name, "username" = dp.name
FROM   sys.certificates c
JOIN   sys.database_principals dp ON c.sid = dp.sid
- to find logins mapped to certificates:
SELECT certname = c.name, loginname = sp.name
FROM   master.sys.certificates c
JOIN   sys.server_principals sp ON c.sid = sp.sid
- Managing Certificates and Passwords
    + There is one certificate for each procedure you sign. easily review which permissions you have granted by querying sys.certificates in master
    + The password are GUIDs they are used only for the duration of the script and not saved
    + When the procedure has been signed, the private key is removed from the certificate with ALTER CERTIFICATE cert REMOVE PRIVATE KEY. the certificate is only good for validation, but cannot be used to sign any new procedures
    + The script does not grant database-level permissions, the application admin needs to create a separate certificate for this
    + code logic to manage the certificates for the specify database
    1.Validate and normalise database and procedure names. This is to make sure that the script always generates the same name for the certificate, even if you use different case or is inconsistent with specifying the schema.
    2.Generate the name, subject and password for the certificate.
    3.If a login with the certificate name exists, drop it.
    4.Drop any old certificate in master.
    5.If the procedure is signed with the old certificate, remove the signature.
    6.As a safety precaution, remove any user created from the certificate in the target database.
    7.Drop the certificate in the target database, if it exists there.
    8.Create the new certificate in master.
    9.Create a login from the certificate.
    10.Grant permissions to the login.
    11.Export the certificate.
    12.Import the certificate in the target database.
    13.If xp_cmdshell is enabled, delete the certificate files. (Else you will need to delete them manually; they are located in the same directory as the master database.)
    14.Sign the procedure.
    15.Remove the private key from the certificate, both in the target database and in master. 
    + the dynamic certificate code example
    -- Copy the certificate to the target database.
    SELECT @sql = '
       CREATE CERTIFICATE ' + quotename(@certname) + '
       FROM BINARY = ' + convert(varchar(MAX), 
                             certencoded(cert_id(quotename(@certname))), 1) + '
       WITH PRIVATE KEY (BINARY = ' + convert(varchar(MAX),
                   certprivatekey(cert_id(quotename(@certname)), @pwd, @pwd), 1) + ',
            ENCRYPTION BY PASSWORD = ''' + @pwd + ''',
            DECRYPTION BY PASSWORD = ''' + @pwd + ''')'
    IF @debug = 1 PRINT @sql
    EXEC @sp_executesql @sql
    + full code slice could be found at http://www.sommarskog.se/grantperm.html#certandbulkcopy in the managing certificate and password section
- Impersonation with EXECUTE AS, there are two types of this script
    + write in the store procedure
    + separate statement
    EXECUTE AS LOGIN = 'somelogin'
    EXECUTE AS USER = 'someuser'
    statements to execute context to impersonate another login or user
    + use the REVERT statement to return back to the previous context owner
    If the EXECUTE AS statement is executed in a lower-level scope – that is, in a stored procedure or a batch of dynamic SQL – there is an implicit REVERT when the scope exits.
    EXEC('EXECUTE AS LOGIN = ''frits''; SELECT SYSTEM_USER')
    SELECT SYSTEM_USER
    the second SELECT will not return frits, but your own login name.
    + there are two apparent uses for the execute as statement
        * A privileged user can use EXECUTE AS to test queries and procedures as another user
        * To implement "application proxies". When you create a user in SQL 2005, you can specify the clause WITHOUT LOGIN to create a user that exists in the database only. the application should add the clause WITH NO REVERT or WITH COOKIE to the EXECUTE AS statement. Else a malicious user could inject a REVERT statement and gain the rights of the proxy login. 
    + impersonal short cut for execute command, it's used for a high-privileged user to impersonate a low-privileged user.
    EXECUTE(@somesql) AS LOGIN = 'somelogin'
    EXECUTE(@somesql) AS USER = 'someuser'
    it should be EXECUTE AS 'Domain\User', not EXECUTE AS '[Domain\User]'.
- Using EXECUTE AS to Grant Permissions within the Database
code example 
CREATE TABLE testtbl (a int NOT NULL,
                      b int NOT NULL)
go
CREATE PROCEDURE example_sp AS
   EXEC ('SELECT a, b FROM testtbl')
go
GRANT EXECUTE ON example_sp TO public
go
to use to the execute as statement
1.Create a proxy user.
2.Grant the proxy user the necessary permissions.
3.Add the EXECUTE AS clause to the stored procedure.
-- Create a proxy user.
CREATE USER exampleproxy WITHOUT LOGIN
-- Give it permissions on the table.
GRANT SELECT ON testtbl TO exampleproxy
go
-- Add EXECUTE AS to the procedure.
CREATE PROCEDURE example_sp WITH EXECUTE AS 'exampleproxy' AS
EXEC ('SELECT a, b FROM testtbl')
go
- EXECUTE AS clause is the same as of the EXECUTE AS USER statement, but there are two main differences
    + It's not that the rights of the proxy user are added to your rights, but you are John Malkovich.
    + If there is a call to an inner stored procedure or a trigger fires, you are not reverted back to your original self; you continue to execute in the context of the proxy user. It is not until you exit the stored procedure with the EXECUTE AS clause that you return to your true self.
This means that if there is some basic permission granted to everyone, say SELECT permission in a certain schema, you don't have to grant that permission to the certificate user. For a proxy user for EXECUTE AS you must grant all permissions needed. But this cuts both ways.
- The Side Effects of EXECUTE AS, SYSTEM_USER, SESSION_USER, USER, user_name(), suser_sname() and a few more. All these are affected by the EXECUTE AS clause
In the WHERE clause of a view or stored procedure for row-level security. 
To fill in the values of auditing columns, through a DEFAULT constraint or a trigger or directly in a stored procedure.
is_member() or  permissions() to determine whether a user is entitled to see some data 
- WITH EXECUTE AS CALLER | SELF | OWNER
    + caller is the store procedure's default behavior
    + EXECUTE AS SELF is short for EXECUTE AS 'yourusername'. That is, if you create a procedure and add WITH EXECUTE AS SELF to it, anyone who runs the procedure will execute with your permissions
    + EXECUTE AS OWNER, finally, means that the procedure executes in the context of the procedure owner.
    CREATE PROCEDURE example_sp WITH EXECUTE AS OWNER AS
   --SELECT SYSTEM_USER, USER, name, type, usage FROM sys.user_token
   EXEC ('SELECT a, b FROM testtbl')
    go
    +  reduce the impact of the EXECUTE AS clause., this code snippets will record the caller of the store procedure
    CREATE PROCEDURE some_sp WITH EXECUTE AS 'proxyuser' AS
        DECLARE @realuser sysname
        EXECUTE AS CALLER
        SELECT @realuser = SYSTEM_USER
        REVERT
        -- Do whatever requires extra privileges
        go
    but there are many situation where execute as calller does not help. if a procedure sp1 with an EXECUTE AS clause calls sp2, sp2 cannot use EXECUTE AS CALLER to set its context to the caller of sp1, as the caller to sp2 is the user in the EXECUTE AS clause in sp1. 
    + get the first connect user 
    original_login()
    check there is no impersonate execution
    IF SYSTEM_USER <> original_login()
    BEGIN
       RAISERROR('This procedure does not support impersonated users', 16, 1)
       RETURN 1
    END
- SET CONTEXT_INFO, it's used for a application login with a proxy then the original_login() function will return the proxy but not the caller of the application
DECLARE @contextinfo varbinary(128)
SELECT @contextinfo = convert(varbinary(128), N'JoeCool')
SET CONTEXT_INFO @contextinfo
 normally the effect of a SET statement issued in a stored procedure is reverted when the procedure exits. SET CONTEXT_INFO is an exception to this rule, and the effect of SET CONTEXT_INFO is always global to the connection.
 - Using DDL Triggers to Stop All This
 SELECT module = object_name(object_id),
       execute_as = CASE m.execute_as_principal_id
                         WHEN -2 THEN 'OWNER'
                         ELSE d.name
                    END
FROM   sys.sql_modules m
LEFT   JOIN sys.database_principals d
          ON m.execute_as_principal_id = d.principal_id
WHERE  m.execute_as_principal_id IS NOT NULL
- write trigger to control the database add store procedure with execute as
CREATE TRIGGER stop_execute_as ON DATABASE
  FOR CREATE_PROCEDURE, ALTER_PROCEDURE,
      CREATE_FUNCTION, ALTER_FUNCTION,
      CREATE_TRIGGER, ALTER_TRIGGER AS
DECLARE @eventdata   xml,
        @schema      sysname,
        @object_name sysname,
        @object_id   int,
        @msg         nvarchar(255)
-- Get the schema and name for the object created/altered.
SELECT @eventdata = eventdata()
SELECT @schema = C.value(N'SchemaName[1]', 'nvarchar(128)'),
       @object_name = C.value(N'ObjectName[1]', 'nvarchar(128)')
FROM   @eventdata.nodes('/EVENT_INSTANCE') AS E(C)
-- Find its object id.
SELECT @object_id = o.object_id
FROM   sys.objects o
JOIN   sys.schemas s ON o.schema_id = s.schema_id
WHERE  o.name = @object_name
  AND  s.name = @schema
-- If we don't find it, it may be because the creator does not have
-- have permission on the object. (Yes, this can happen.)
IF @object_id IS NULL
BEGIN
   SELECT @msg = 'Could not retrieve object id for [%s].[%s], operation aborted'
   RAISERROR(@msg, 16, 1, @schema, @object_name)
   ROLLBACK TRANSACTION
   RETURN
END
-- Finally check that the catalog views whether the module has any
-- EXECUTE AS clause.
IF EXISTS (SELECT *
           FROM   sys.sql_modules
           WHERE  object_id = @object_id
             AND  execute_as_principal_id IS NOT NULL)
BEGIN
   ROLLBACK TRANSACTION
   SELECT @msg = 'Module [%s].[%s] has an EXECUTE AS clause. ' +
                 'This is not permitted in this database.'
   RAISERROR (@msg, 16, 1, @schema, @object_name)
   RETURN
END
go
- execute as and access outside the database
The EXECUTE AS clause always impersonates a database user, never a server login. And when you impersonate a user, you are sandboxed into the current database, and you are denied any access outside that database. This applies to the EXECUTE AS clause in a procedure as well as the statement EXECUTE AS USER. 
    + open the sandbox to execute sql from another database need to open two doors
    If the database is owned by a user with sysadmin permission, one of the doors are already open. The other door is this statement:
    ALTER DATABASE db SET TRUSTWORTHY ON
- Using EXECUTE AS to Give Bulk-Copy Permissions
1.Create a proxy login, in the master database.
2.Grant the proxy login ADMINISTER BULK OPERATIONS. Again in master.
3.Mark the target database as trustworthy.
4.Switch to the application database.
5.Create a user for the proxy login.
6.Grant the proxy user ALTER and INSERT on the target table.
7.Add an EXECUTE AS clause to the procedure.
- extending database impersonation by using execute as 
1. The database A must be TRUSTWORTHY. 
2a. For access to another database B, the owner of A must have been granted the permission AUTHENTICATE in the database B. 
2b. For actions that require server-level permissions, the owner of A must have been granted the permission AUTHENTICATE SERVER. 
MS online doc, http://msdn.microsoft.com/en-us/library/ms188304.aspx
- the dangerous of at trustworthy database and authenticate server right to a user
CREATE USER [Domain\ServerDBA]        -- That's you!
go
EXECUTE AS USER = 'Domain\ServerDBA'
- cross-database access
 if all databases are owned by the same generic user. But if all databases have individual owners, execute as + trustworthy may be perfectly acceptable
 - how we could make it possible for users of an application to start a certain job with help of certificates. 
1.The source database must have an individual owner. 
2.The source database must be TRUSTWORTHY.
3.The database owner is added to msdb and granted AUTHENTICATE in that database.
4.Create a login-less user jobstartuser in msdb and add this user to SQLAgentOperatorRole.
5.You create a stored procedure in msdb to start the job in question. The procedure should have EXECUTE AS 'jobstartuser'. 
6.The database owner is granted EXECUTE permission on this procedure.
7.The database owner creates a stored procedure in his database with EXECUTE AS 'dbo' that calls the procedure in msdb.
this is a little difference with a sign TRUSTWORTHY property for a database and the db owner could impersonate the trusted database's administrator. because 
CREATE USER sa
CREATE USER Nisse FROM LOGIN sa
You will be told:
Msg 15405, Level 16, State 1, Line 1
Cannot use the special principal 'sa'.
This solution is still have a few fault, the best solution is use a intermedia database the steps are as followed
1.The source database must have an individual owner. 
2.The source database must be TRUSTWORTHY.
3.Create an intermediate database, call it jobstarter. This database MUST be owned by sa.
4.Make jobstarter TRUSTWORTHY.
5.Create a login jobstartuser who is to be the proxy user to start jobs. Deny this login the CONNECT SQL, that is, the right to log in to SQL Server.
6.Add jobstartuser to msdb and make it member of the SQLAgentOperatorRole.
7.Add jobstartuser to the jobstarter database.
8.Add the owner of the source database to jobstarter, and grant him AUTHENTICATE.
9.In jobstarter create a procedure that calls sp_start_job for the specific job. The procedure should have EXECUTE AS 'jobstartuser'. 
10.Grant the database owner EXECUTE permission on the procedure.
11.The database owner adds a procedure to his database with EXECUTE AS 'dbo' that calls the procedure in jobstarter.
- Yet another Side Effect – WindowsIdentity
In a CLR module, you can access the WindowsIdentity object. SqlContext.WindowsIdentity.Name will return the domain and the Windows user name, if the user logged in through Windows authentication. For an SQL login,  WindowsIdentity is Null, so access to SqlContext.WindowsIdentity.Name yields a Null exception.
- other methods
    + application role, The idea is that you create a role to which you assign the necessary privileges to run the application. The users have no permissions at all beyond the database access.  sp_setapprole to activate the role.  a three-tier application is more saver than the client server application, the sensitive data could be saved in the middle layer where normal use don't have the right to access
    But you can get a cookie back from sp_setapprole, which you then can pass to  sp_unsetapprole before you disconnect.
     suser_sname() etc – still return the login name of the actual user. user_name() – return the name of the application role.
    + terminal server, You need to configure the network so that the SQL Server machine is not directly accessible from the users' computers, only from the computer running Terminal Server.
- sql server module signing, http://msdn.microsoft.com/en-us/library/ms345102.aspx
    + Note that data definition language (DDL) triggers cannot be signed.
    + Module signing should only be used to grant permissions, never to deny or revoke permissions.
    + senario
    Let us assume that access to the sys.sysprocesses view should be mediated by the usp_sysprocesses stored procedure. Users can access the sys.sysprocesses information only when going through the usp_sysprocesses procedure. Since the usp_sysprocesses and sys.sysprocesses objects have different ownerships, ownership chaining does not apply.
        * SQL Server only grants permissions to principals
        * A test key pair must be created first using the MakeCert tool that is included with the .NET Framework SDK.
        * code sample
        use master
        go

        -- Create a test database.
        CREATE DATABASE db_Demo
        go

        -- Create a certificate on the server. A test key pair can be created
        -- using the MakeCert tool that ships with the .NET Framework SDK.
        CREATE CERTIFICATE SysProcCert FROM FILE = 'e:\programming\testCert.cer'
        go

        -- Create a login and map it to the certificate.
        CREATE LOGIN login_SysProcCert FROM CERTIFICATE SysProcCert
        Go

        -- Revoke the connect permission.
        REVOKE CONNECT SQL FROM login_SysProcCert ;
        go 
         
        -- Grant the certificate, through the login, permission to select from sys.sysprocesses view.
        GRANT VIEW SERVER STATE TO login_SysProcCert
        go

        -- Create a test login.
        CREATE LOGIN bob WITH PASSWORD = '<enterStrongPasswordHere>'
        go

        -- Connect to the test database.
        use db_Demo
        go

        -- Create the master key for the test database (used to protect 
        -- private keys and certificates in the database).
        CREATE MASTER KEY ENCRYPTION BY PASSWORD = '<enterStrongPasswordHere>' 

        -- Create a certificate from a private key.
        CREATE CERTIFICATE SysProcCert FROM FILE = 'e:\programming\testCert.cer'
        WITH PRIVATE KEY
        (FILE = 'e:\programming\testCert.pvk', 
         DECRYPTION BY PASSWORD= '<enterStrongPasswordHere>', 
         ENCRYPTION BY PASSWORD='<enterStrongPasswordHere>')
        go 

        -- Create the assembly on the server. The assembly DLL must be signed.
        CREATE ASSEMBLY SysStoredProcedures
        FROM 'E:\programming\SysStoredProcs.dll'
        WITH PERMISSION_SET = SAFE
        go 

        -- Create the managed stored procedure on the server.
        CREATE PROCEDURE usp_sysprocesses
        AS EXTERNAL NAME SysStoredProcedures.StoredProcedures.usp_sysprocesses
        go 

        -- Add the signature to the stored procedure.
        ADD SIGNATURE TO [dbo].[usp_sysprocesses] 
        BY CERTIFICATE SysProcCert WITH PASSWORD = '<enterStrongPasswordHere>'
        go 

        -- Create a role.
        CREATE ROLE SysProcRole
        go

        -- Create a test user
        CREATE USER bob
        go

        -- Add the test user to the role.
        EXEC sp_addrolemember 'SysProcRole', 'bob'
        go

        -- Grant execute permissions on the stored procedure to the new role.
        GRANT EXECUTE ON [dbo].[usp_sysprocesses] TO SysProcRole
        go
         
        -- Connect as the test user.
        EXECUTE AS LOGIN = 'bob'
        use db_Demo
        go
         
        -- User only has permission to see their own processes.
        SELECT * FROM sys.sysprocesses
        go

        -- Execute the stored procedure, which has been signed.
        exec usp_sysprocesses
        go

        -- REVERT
        REVERT
        ----------------------------------------------------------------------
        -- Cleanup

        use db_Demo
        go

        use master
        go

        DROP DATABASE db_Demo
        go 

        DROP login login_SysProcCert
        DROP login bob
        go

        DROP CERTIFICATE SysProcCert
        go
        * the source code of usp_sysprocesses in c#, the dll must be signed
        using System;
        using System.Data.SqlClient;
        using Microsoft.SqlServer.Server;

        public partial class StoredProcedures
        {
        [Microsoft.SqlServer.Server.SqlProcedure]
        public static void usp_sysprocesses()
        {
            using(SqlConnection connection = new SqlConnection("context connection=true"))
            {
                connection.Open();
                SqlCommand command = new SqlCommand("SELECT * FROM sys.sysprocesses", connection);
                SqlContext.Pipe.ExecuteAndSend(command);
            }
        }
        };

 # calling exe from tsql
 - the store procedure xp_cmdshell is used to call the command line from tsql, it's disabled by default
 xp_cmdshell 'F:\Data\SMARTConfig\USTTemp\ExecuteSmartConfigSchedules.exe'
 - to enable the xp_cmdshell you need to used
 sp_configure
 - case sensitive match a string 
 select 'case sensitive' 
where 
	'a' like 'A' collate SQL_Latin1_General_CP1_CS_AS
 
 # call webservice from tsql
 - use these store procedures
 sp_oa*, such as
 sp_oscreate, sp_oamethod
 
 # how to share data between stored procedure
 - there are plenty of ways to do this but each have a advantage and drawback
method                                  type        callee?     version     comment
OUTPUT Parameters           Output      Yes                            Not generally applicable, but sometimes overlooked. 
Table-valued Functions        Output      Yes                           Often the best choice for output-only, but there are several restrictions. 
Inline Functions                                                                     Use this to reuse a single SELECT. 
Multi-statement Functions                                                       When you need to encapsulate more complex logic. 
Using a Table                       In/Out      Yes                            The most general solution. My favoured choice for input/output scenarios. 
Sharing a Temp Table                                                            Mainly for a single pair of caller/callee. 
Process-keyed Table                                                             Best choice for many callers to the same callee. 
Global Temp Tables                                                               A variation of process-keyed. 
Table-valued Parameters     Input        Yes        SQL 2008    Mainly useful when passing data from a client. 
INSERT-EXEC                     Output      No                              Deceivingly appealing, but should be used sparingly. 
Using the CLR                      Output      No         SQL 2005    Complex, but useful as a last resort when INSERT-EXEC does not work. 
OPENQUERY                       Output     No                              Tricky with many pitfalls. Discouraged. 
Using XML                            In/Out      Yes        SQL 2005    A bit of a kludge, but not without advantages. 
Using Cursor Variables          Output      Yes                          Not recommendable. 
- create a output parameter procedure
    + ex.
CREATE PROCEDURE insert_customer @name    nvarchar(50),
                                 @address nvarchar(50),
                                 @city    nvarchar(50),
                                 @cust_id int OUTPUT AS
BEGIN TRANSACTION
SELECT @cust_id = coalesce(MAX(cust_id), 0) + 1 FROM customers (UPDLOCK)
INSERT customers (cust_id, name, address, city)
   VALUES (@cust_id, @name, @address, @city)
COMMIT TRANSACTION
    + use the procedure
EXEC insert_customer @name, @address, @city, @cust_id OUTPUT
- inline function, instead of directly use output parameter of store procedure, it's mostly better to replace it with inline functions
CREATE FUNCTION SalesByStore (@storeid varchar(30))
RETURNS TABLE AS
RETURN (SELECT t.title, s.qty
        FROM   sales s
        JOIN   titles t ON t.title_id = s.title_id
        WHERE  s.stor_id = @storeid)
// to use the function:
SELECT * FROM SalesByStore('6380')
- Multi-statement Functions,  that can have as many statements as you like. You need to declare a return table, and you insert the data to return into that table. 
CREATE FUNCTION SalesByStore (@storeid varchar(30))
   RETURNS @t TABLE (title varchar(80) NOT NULL PRIMARY KEY,
                     qty   smallint    NOT NULL)  AS
BEGIN
   INSERT @t (title, qty)
      SELECT t.title, s.qty
      FROM   sales s
      JOIN   titles t ON t.title_id = s.title_id
      WHERE  s.stor_id = @storeid
   RETURN
END
- using a table, What could be better for passing data in a database than a table, there are two ways to do this
    + sharing a temp table
CREATE PROCEDURE called_procedure @par1 int,
                                  @par2 bit,
                                  ... AS
   ...
   INSERT/UPDATE/DELETE #tmp
go
CREATE PROCEDURE caller AS
   DECLARE ...
   CREATE TABLE #mytemp (col1 int     NOT NULL,
                         col2 char(5) NULL,
                        ...)
   ...
   EXEC called_procedure @par1, @par2 ...
   SELECT * FROM #mytemp
go
In this example, caller creates the temp table, and called_procedure fills it in, that is, the table is output-only
- The Impact of Recompilation
- suppress TSQL warning, There is a way to suppress the warning: right-click the file in Solution Explorer and select Properties. There is a property Suppress T-Sql Warning and here you can enter the code for the error.
- Process-Keyed Tables
- A process-keyed table is simply a permanent table that serves as a temp table. 
CREATE TABLE process_keyed (spid  int     NOT NULL,
                            col1  int     NOT NULL,
                            col2  char(5) NULL,
                            ...)
go
CREATE CLUSTERED INDEX processkey_ix ON process_keyed (spid)
-- Add other columns as needed.
go
...
DELETE process_keyed WHERE spid = @@spid
INSERT process_keyed (spi, col1, col2, ....)
   VALUES (@@spid, @val1, @val2, ...)
...
SELECT col1, col2, ...
FROM   process_keyed
WHERE  spid = @@spid
...
DELETE process_keyed WHERE spid = @@spid
    + several things need to be caution
    1.The table should have a clustered index on the process key (spid in this example), as all queries against the table will include the condition WHERE spid = @@spid.
    2.You should delete any existing data for @@spid before you insert any data into the table, as a safety precaution.
    3.When you are finished using the data you should delete it, so that it does not occupy any extra space.
    4.If sloppy programmers neglect to clear the spid before and after use, old data may be passed to the callee, causing incorrect results that are difficult to understand how they arose.
    5.If a client needs to pass a process-key around, there is no guarantee that it will have the same spid every time, since modern clients typically connect and disconnect for each call they make.
    +  If you create the process key in SQL Server, you can use the function newid(). 
    You may have heard that you should not have guids in your clustered index, but that applies when the guid is the primary key alone, since this can cause fragmentation and a lot of page splits. In a process-keyed table, you will typically have many rows for the same guid, so it is a different situation.
- Using Memory-optimised Tables in SQL 2014, use the table create with this options
WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)
- global temp tables, with two leading hash marks (e.g. ##temp), xp_cmdshell, here is a code snippets to create a global temp table whenever the sql server starts
USE master
go
CREATE PROCEDURE create_global_temp AS
   CREATE TABLE ##global(process_key uniqueidentifier NOT NULL,
                         -- other columns here
   )
go
EXEC sp_procoption create_global_temp, 'startup', 'true'
- Table-valued Parameters, introduced in sql 2008
CREATE TYPE my_table_type AS TABLE(a int NOT NULL,
                                   b int NOT NULL)
go
CREATE PROCEDURE the_callee @indata my_table_type READONLY AS
   INSERT targettable (col1, col2)
      SELECT a, b FROM @indata
go
CREATE PROCEDURE the_caller AS
   DECLARE @data my_table_type
   INSERT @data (a, b)
       VALUES (5, 7)
   EXEC the_callee @data
go
 implicit default value of an empty table. So saying EXEC the_callee in this example would not be an error.
 - INSERT-EXEC, use insert with exec to call the store procedure to add the data into to temp table
 CREATE PROCEDURE SalesByStore @storeid varchar(30) AS
   SELECT t.title, s.qty
   FROM   sales s
   JOIN   titles t ON t.title_id = s.title_id
   WHERE  s.stor_id = @storeid
go
CREATE PROCEDURE BigSalesByStore @storeid varchar(30),
                                 @qty     smallint AS
   
   CREATE TABLE #SalesByStore(title varchar(80) NOT NULL PRIMARY KEY,
                              qty   smallint    NOT NULL)
   
   INSERT #SalesByStore (title, qty)
      EXEC SalesByStore @storeid

   SELECT * FROM #SalesByStore WHERE qty >= @qty
go
EXEC SalesByStore '7131'
EXEC BigSalesByStore '7131', 25
go
DROP PROCEDURE SalesByStore, BigSalesByStore
    + drawbacks
    It Can't Nest
    There is a Serious Maintenance Problem
    The Procedure is Executed in the Context of a Transaction
    + You can also use INSERT-EXEC with dynamic SQL
    sp_executesql which permits you to use OUTPUT parameters with dynamic sql script to use with insert with dynamic sql
- Using the CLR
    + there are several senerail that exec-insert statement doesn't supply sufficient functions
1. The called procedure returns several result sets with different structures. This is true for many system procedures in SQL Server.
2. The called procedure cannot be called within an active transaction. See the final note in this section for an example.
3. The called procedure already uses INSERT-EXEC.
4. The called procedure accesses a linked server, and you cannot get the distributed transaction to work.
    + A further complication is that the CLR in SQL Server is disabled by default. To enabled it, you (or the DBA) need to run:
EXEC sp_configure 'clr enabled', 1
RECONFIGURE
    +  Another violation of best practice is the use of the DataAdapter, DataTable and DataSet classes. This is something to be avoided, because it means that you have data in memory in SQL Server outside the buffer pool.
    + The alternative is to use a plain ExecuteReader and insert the rows as they come, possibly buffering them in small sets of say 500 rows to improve performance. 
- OPENQUERY and its cousin OPENROWSET is to permit you to run pass-through queries on linked servers.
    + ex.
SELECT * FROM OPENQUERY(LOCALSERVER, 'EXEC sp_who') WHERE status = 'runnable'
    + sometimes openquery is not easy to use
    + setup a openquery
EXEC sp_addlinkedserver @server = 'LOCALSERVER',  @srvproduct = '',
                        @provider = 'SQLOLEDB', @datasrc = @@servername
    to add linked server you must have the ALTER ANY SERVER permission,  Instead of SQLOLEDB, you can specify SQLNCLI, SQLNCLI10 or SQLNCLI11 depending on your version of SQL Server.
    + Implications of Using a Loopback Connection
1. The procedure that you call with OPENQUERY cannot refer temp tables created in the current connection.
2. The new connection has its own default database (defined with sp_addlinkedserver, default is master), so all object specifications must include a database name. 
3. If you have an open transaction and you are holding locks when you call OPENQUERY, the called procedure can not access what you lock. That is, if you are not careful you will block yourself.
4. Connecting is not for free, so there is a performance penalty.
5. There is also a performance penalty for passing the data out from SQL Server and back. Even if there is no network involved, data is copied twice extra compared to a plain SELECT query. This can be costly if the result set is big.
    + ANSI settings
    The settings ANSI_NULLS and ANSI_WARNINGS must be ON for queries involving linked servers. Thankfully, these setting are also on by default in most contexts. There are mainly two exceptions: 1) very old client APIs like DB-Library. 2) If you are still on SQL 2000
    + The Query Parameter
    The second parameter to OPENQUERY is the query to run on the remote server, and you may expect to be able to use a variable here, but you cannot. The query string must be a constant
    + ex.
CREATE FUNCTION quotestring(@str nvarchar(MAX)) RETURNS nvarchar(MAX) AS
BEGIN
   DECLARE @ret nvarchar(MAX),
           @sq  char(1)
   SELECT @sq = ''''
   SELECT @ret = replace(@str, @sq, @sq + @sq)
   RETURN(@sq + @ret + @sq)
END
go
CREATE PROCEDURE SalesByStore @storeid varchar(30) AS
   SELECT t.title, s.qty
   FROM   sales s
   JOIN   titles t ON t.title_id = s.title_id
   WHERE  s.stor_id = @storeid
go
CREATE PROCEDURE BigSalesByStore @storeid varchar(30),
                                 @qty     smallint, 
                                 @debug   bit = 0 AS
   DECLARE @remotesql nvarchar(MAX),
           @localsql  nvarchar(MAX)
   SELECT @remotesql = 'EXEC ' + quotename(db_name()) + '.dbo.SalesByStore ' +
                                 dbo.quotestring(@storeid)
   SELECT @localsql = 'SELECT * FROM OPENQUERY(LOCALSERVER, ' + 
                       dbo.quotestring(@remotesql) + ') WHERE qty >= @qty'
   IF @debug = 1 PRINT @localsql
   EXEC sp_executesql @localsql, N'@qty smallint', @qty
go
EXEC SalesByStore '7131'
EXEC BigSalesByStore '7131', 25, 1
go
DROP PROCEDURE BigSalesByStore, SalesByStore
DROP FUNCTION quotestring
    + The Battle with FMTONLY ON, When FMTONLY is ON, SQL Server does not execute any data-retrieving statements, but only sifts through the statements to return metadata about the result sets. But the any temp table will not be created in FMTONLY ON mode
    here is a bypass way
    CREATE PROCEDURE temp_temp_trick AS
   DECLARE @fmtonlyon int
   SELECT @fmtonlyon = 0
   IF 1 = 0 SELECT @fmtonlyon = 1
   SET FMTONLY OFF
   CREATE TABLE #temp(...)
   IF @fmtonlyon = 1 SET FMTONLY ON
   -- Rest of the code goes here.
The famous, but undocumented, system stored procedure sp_who2 uses dynamic SQL to size the columns of the result set. On SQL 2008 the query
SELECT * FROM OPENQUERY(LOCALSERVER, 'EXEC sp_who2')
- metadata retrieval in sql 2012
sp_describe_first_result_set which is a more robust way to determine metadata,  SET FMTONLY ON still works in SQL 2012 to support calls from legacy clients in 2012, and for loopback connection, SQL 2012 only uses sp_describe_first_result_set
- to control the result set of store procedure in 2012, use 'with result set' statement
SELECT * FROM OPENQUERY(LOCALSERVER, 
              'EXEC msdb..sp_helpindex sysjobs
               WITH RESULT SETS ((index_name        sysname,
                                  index_description nvarchar(500),
                                  index_keys        nvarchar(500)))')
If you want to know how the result set from the stored procedure you are calling looks like, you can say:
EXEC sp_describe_first_result_set N'your_sp'
- the effect of DML statement
- OPENQUERY was not intended for accessing the local server, and you should think twice before you use it that way. 
- using XML, XML is a solution that aims at the same spot as sharing a temp table and process-keyed tables. 
    + ex. use xml as the result of store procedure
    CREATE PROCEDURE SalesByStore_core @storeid varchar(30),
                                   @xmldata xml OUTPUT AS
    SET @xmldata = (
      SELECT t.title, s.qty
      FROM   sales s
      JOIN   titles t ON t.title_id = s.title_id
      WHERE  s.stor_id = @storeid
      FOR XML RAW('SalesByStore'), TYPE)
    go
    + output will like this
    <SalesByStore title="Is Anger the Enemy?" qty="20" />
    <SalesByStore title="The Gourmet Microwave" qty="25" />
    <SalesByStore title="Computer Phobic AND Non-Phobic Individuals: Behavior Variations" qty="20" />
    <SalesByStore title="Life Without Fear" qty="25" />
    <SalesByStore title="Prolonged Data Deprivation: Four Case Studies" qty="15" />
    <SalesByStore title="Emotional Security: A New Algorithm" qty="25" /> 
    + The part T(c) defines as alias for the one-column table as well as an alias for the column.
    CREATE PROCEDURE BigSalesByStore @storeid varchar(30),
                             @qty     smallint AS
    DECLARE @xmldata xml
    EXEC SalesByStore_core @storeid, @xmldata OUTPUT

    ; WITH SalesByStore AS (
      SELECT T.c.value('@title', 'varchar(80)') AS title,
             T.c.value('@qty',   'smallint') AS qty
      FROM  @xmldata.nodes('SalesByStore') AS T(c) 
    )
    SELECT title, qty
    FROM   SalesByStore   
    WHERE  qty >= @qty
    go
    + Parent-child Data save the hierarchical data into one xml document
    SELECT a.au_id  ,  
           a.au_lname, 
           a.au_fname ,
           (SELECT t.title 
            FROM   pubs..titleauthor ta  
            JOIN   pubs..titles t ON t.title_id = ta.title_id
            WHERE  a.au_id = ta.au_id
            FOR  XML RAW('titles'), TYPE)
    FROM   pubs..authors a
    FOR XML RAW('authors'), TYPE
    + Assessing the xml query Method
        * Compared to temp tables and process-keyed tables, you don't have to be worried about recompilation or that programmers fail to clean up a process-keyed table after use. 
        * the return xml file size should controlled less than  200KB
        * Another weak point is that you have to specify the data type for each column in the call to value
        * the spell error of the column will return NULL silently
- Using Cursor Variables for sharing data between store procedure
    + ex.
    CREATE PROCEDURE get_cursor @cursor CURSOR VARYING OUTPUT AS
       SET @cursor = CURSOR STATIC FOR
       SELECT au_id, au_lname, au_fname FROM pubs..authors
       OPEN @cursor
    go
    CREATE PROCEDURE caller AS
       DECLARE @cursor CURSOR
       DECLARE @au_id char(11),
               @au_fname varchar(40),
               @au_lname varchar(40)
       SET NOCOUNT ON
       EXEC get_cursor @cursor OUTPUT
       WHILE 1 = 1
       BEGIN
          FETCH NEXT FROM @cursor into @au_id, @au_lname, @au_fname
          IF @@fetch_status <> 0
             BREAK
          PRINT 'Au_id: ' + @au_id + ', name: ' + @au_fname + ' ' + @au_lname
       END
       DEALLOCATE @cursor
    go
    EXEC caller
    go
    DROP PROCEDURE caller, get_cursor
- The Challenges of Linked Servers
    + It is somewhat easier to retrieve data from a procedure on a linked server than passing data to it
    + OUTPUT parameters – but only for data types that are 8000 bytes or less
    + INSERT-EXEC – INSERT-EXEC works fine with linked servers
    + MSDTC (Microsoft Distributed Transaction Coordinator)
    + OPENQUERY – since OPENQUERY is a feature for linked servers in the first place, there is no difference to what I discussed above
    + Using the CLR – Using the CLR for linked servers is interesting, because the normal step would be to connect to the remote server directly
    + XML – You cannot use the xml data type in a call to a remote stored procedure. However, you can make the OUTPUT parameter to be varchar(8000) and return the XML document that way – if it fits. 
    
    
# difference between function and store procedure in TSQL
- Procedure can return zero or n values whereas function can return one value which is mandatory.
- Procedures can have input/output parameters for it whereas functions can have only input parameters.
- Procedure allows select as well as DML statement in it whereas function allows only select statement in it.
- Functions can be called from procedure whereas procedures cannot be called from function.
- Exception can be handled by try-catch block in a procedure whereas try-catch block cannot be used in a function.
- We can go for transaction management in procedure whereas we can't go in function.
- Procedures can not be utilized in a select statement whereas function can be embedded in a select statement.
- UDF can be used in the SQL statements anywhere in the WHERE/HAVING/SELECT section where as Stored procedures cannot be.
- UDFs that return tables can be treated as another rowset. This can be used in JOINs with other tables.
- Inline UDF's can be though of as views that take parameters and can be used in JOINs and other Rowset operations.
- User defined functions have three main categories:
    1.Scalar-valued function - returns a scalar value such as an integer or a timestamp. Can be used as column name in queries.
    2.Inline function - can contain a single SELECT statement.
    3.Table-valued function - can contain any number of statements that populate the table variable to be returned. They become handy when you need to return a set of rows, but you can't enclose the logic for getting this rowset in a single SELECT statement.  
- in procedure you CANNOT alter or create an object and use the altered object at the same call, because there is no go here
- The most important thing belong to Functions
Functions cannot run side-effects commands, such as update, delete, alter, open, etc. 
- There are really only TWO categories: (1) Scalar functions, and (2) Table-Valued Functions. 
Each of these categories can be further categorized as either
    (a) inline (i.e., no function body; the table is the result set of a single SELECT statement), or 
    (b) multi statement (with a function body defined in a BEGIN...END block.) 
(Another way to look at this is there are 4 categories: scalar-inline, scalar-multi, table-inline, and table-multi.)  
- User-defined functions are quite restricted in what they can do
    + You can only perform INSERT, UPDATE or DELETE statements on table variables local to the function.
    + You cannot call stored procedures (with the exception of extended stored procedures).
    + You cannot invoke dynamic SQL.
    + You cannot create tables, neither permanent tables nor temp tables. You can use table variables.
    + You cannot use RAISERROR, TRY-CATCH or BEGIN/COMMIT/ROLLBACK TRANSACTION.
    + You cannot use "side-effecting" system functions, such as newid() and rand().
    + On SQL 2000, you cannot use non-deterministic system functions.
- references
http://www.codeproject.com/Tips/286539/Difference-between-stored-procedure-and-function
http://www.sommarskog.se/share_data.html
 
 
 
 
 
