Webpack Transpiling and Bundling JavaScript=Wes Higbee;Note=Erxin

# What is webpack 
- author website 
http://weshigbee.com

- welcome 
    + interactive viewing 
    use vue.js 
    
    vue can not refresh browser and reflect the changes 
    
    + react could do the same 
    + angular.js will refresh the page 
    
- webpack benefits 
    + interactive coding 
    + seamless compilation 

- check module support website 
http://caniuse.com

    
- compiler hook types 
    + reference 
    https://github.com/webpack/tapable#hook-types
    
Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.

Waterfall. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.

Bail. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.

Loop. TODO

- benefit bundling for performance 
- sophisticated bundling, bundle per page, bundle/clode splitting, minify, lazy load, remove unsued code for different products 

$ npm install lodash 

module format interop (CJS node), ESM(harmony) AMD (RequireJS), UMD, globals 

webpack is a module loader /resolution, your responsibility is to specify relationships between modules, not path & script order 

- help with caching 
caching can be tailored to development and production separately. we require cache in product and no cache in development 

- source maps, source map file will be generated by webpack for help set breakpoint in the bundled files 

- webpack benefits 
caching 

dev isn't prod, easily customized builds per environment 

source map 

platform for transformation 

- a compiler platform 

service worker and appcache 

course series and updates 

incremental builds, even without interactive coding 

extensible via Plugins and Loaders 

use future technology 

- can import webassembly and supoprt cpp, rust with webpack 

- debugger.html, dev-tool is used webpack 

- course series and updates 
tentative course series 

    + first bundle js 
    + second bundle css, less etc with web app 
    + multiple bundles 
    + bundle optimization 

    https://github.com/g0t4/optimizing-web-apps-webpack/

# Bundling code 
- cloning and starting the solitaire

    + clone the game 
    https://github.com/g0t4/optimizing-web-apps-webpack/
    
    https://github.com/devtools-html/debugger.html
    
- bundling app.js 
$ npm install -D webpack 

$ npx webpack --help 

npx is used to run command locally which is release with npm 

$ npx webpack app/app.js app/dist/app.bundle.js 

this will only package only the entry point file

we could replace the entry file location into the html 

webpack will help us wrapper the code into a function boilerplate

we could add import JS file to let webpack package the relative JS files for us 

- webpack polyfills module for help compatible with old world browsers 

//in the code we write 
import "./klondlike/scoring.js";

//webpack will generate 
/*harmony import*/var __WEBPACK_IMPORT_MODULE_0_klondlike_scoring_js_ == __webpack_require__(1);

all the module will be packaged into an array 

- webpack polyfills use strict 
webpack detect an import statement then will automatic add "use strict" into the bundle 

- learning from webpack source 
    + learn from the source code 
    + learn from the official document. such as check the implementation of "use strict"

- generating an interactive graph 

$ webpack *.js *.js --verbose 

etc 

    + check the graph of modules npm packages 
    $ npm install -D webpack-stats-graph 
    
    $ npx webpack *.js *.js --json > stats.json 
    
    $ webpack-stats-graph
    will create the graph for you. which is a dot file 

- challenge, link the process together bundle the app and generate the graph. After webpack it will reduce the web request count 


# Accelerating Development
- Benefits of Watch and WDS 
watch mode, wath the changes and regenerate the bundle for you 

hot module replacement, we no long need to run the webserver and help us reload the changed files 

- watch mode 
    + interactive 
    $ npx webpack --watch *.js 
    
    webpack will watch the file to changes 
    
- install webpack-dev-server module. it's a development server 
$ npm install -D webpack-dev-server 

$ npx webpack-dev-server --help 

the options will be displayed 

    + set up configure file before we could use 
    $ npm-run-script 
    module will run arbitrary command from a package's script object 
    
    add a build field inside the packge.js with the commandline 
    
    $ npm run build 
    
    + directly start from commandline 
    $ npx webpack-dev-server --open *.js *.js 

    + configuration file could put all the commandline parameters into a single field to reduce duplication 
    
- use webpack.config.js 
- webpack DevServer section for more detail information 
https://webpack.github.io/docs 
https://webpack.org/

- Hot module replacement documentation 

devServer.hot 

when the js files saved. the browser will be refreshed 

    + using plugins 
    NamedModulesPlugin plugin 
    HotModuleReplacementPlugin
    
- Using module.hot hotOnly property for hot replacement 
- Inspecting server state and bundles 
http://localhost:8080/webpack-dev-server/


# Dev Isn't Prod
- configure webpack build for production should remove the hot module replacement codes 
    + conditional add webpack-dev-server and relative development plugins 
    
    using nodejs environment variable to control load the module in conditions 
    
    const isDevelopment = process.env.NODE_ENV === "development";
    
    if(isDevelopment){
        baseConfig.plugins.push({
            new webpack.NamedModulesPlugin(),
            new webpack.HotModuleReplacementPlugin()
        });
    }
    
    in the configuration file 
    
    npm devEnv module for help you load envirnoment variables 
    
    $ npm install -D devEnv
    
- webpack configuration file could be treat as a js file; in the configuration file webpack.config.json 

module.exports = function(env){
    const baseConfig = {
    };
    
    return baseConfig;
};

we could use module yargs module to parse the commandline arguments 
$ npm install -D yargs 

- webpack commandline interface could be provide to support different kinds of commandline arguments

http://webpack.js.org/api/cli/#envirnoment-options/

- using multiple configurations and named configuration

baseConfig.name = 'configuration name';

$ npx webpack --config-name <configuration-name>

- inspecting the merged configuration 

module.exports = function(env){
    const baseConfig = {
    };
    
    return merge(baseConfig, {
       new webpack.HotModuleReplacementPlugin(),
       ...
    });
};

we could create different plugins 

new syntax to work with plugin https://github.com/webpack/tabable/
    

# Transpiling using the future now 
- works with babel 
- babelrc.js 


# Understanding Loaders 
- loader 


# Running Build Tasks 
- output folder 
- rimraf npm package 
- from dev to prod 

loaders operate on the level of modules 

plugins are operate on the level of entire compilation 

- not just build task, extend webpack with plugins 

- not just build task, npm-install-webpack-plugin, automatic install npm plugin 

https://github.com/webpack-contrib/awesome-webpack/


# Troubleshooting with source maps 
- Source map reference back to the original code 
- enable source maps with devtools 

const baseConfig = {
    ...
    devtool: 'source-map',
    ...
}

the source map file could be consumed by the devtool

- fast, inline, partial source maps

change the devtool option to eval, the mapping still have the mapping. but there is no map file generated 

const baseConfig = {
    ...
    devtool: 'eval',
    ...
};

the mappings are inline and contained in the source code for helping debugging in the production environment 

- high quality maps with fast 

const baseConfig = {
    ...
    devtool: 'eval-source-map',
    ...
}

- devtool: 'hidden-source-map' we could product the map and hidden the mapping file name. hide the url from the bundle file 

- only map location and filename. no source code. just the filename without original source file content. This could be saved into logging system etc for helping debugging 
devtool: 'nosources-source-map'

- resources, check the webpack document 
- devtool is just an idiosyncratic
- add the SourceMapDevToolPlugin for helps generate source map 


# Generating Code 
- create a code generator 
    + challenge buildInfo.js will grab out the git commit information such as time and checksum and let webpack combine these information into the bundle 

- reference git repository for the solution 
https://github.com/g0t4/optimizing-web-apps-webpack/

https://github.com/webpack-contrib/val-loader/
























