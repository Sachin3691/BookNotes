Learning Perl=Randal L. Scbwartz;Note=Erxin

# introduction
- check perl version
$ perl -v 
- the definitive reference for perl is Programming Perl, also known as the Camel book 
- Perl stand for, Practical Extraction and Report Language also called Pathologically Eclectic Rubbish Lister 
- perl is optimized for problems which are about 90% working with text and about 10% everything else 
- perl for the program you could give the source code of your program 
- what is CPAN? is comprehensive perl archive network 
- get support of perl 
    + website, 
    http://www.pm.org/ 

    + read document on CPAN 
    http://www.cpan.org 
    http://perldoc.perl.org 
    http://faq.perl.org 
    

    + newsgroups on usenet, are located at comp.lang.perl.*
    https://en.wikipedia.org/wiki/Usenet

    + perl monastery website 
    http://www.perlmonks.org 
    
    + blogs 
    http://perlshpere.net 
    
    + learning website 
    http://learn.perl.org 
    mail list beginners@perl.org 
    
- editor 
perlfaq3 documentation also list other editors 
    
- on linux required to make a file executable by 
$ chmod a+x file_name 

- first hello world program 
#!/usr/bin/perl
print "hello, world\n";

use 5.010;  #for 5.010+ support say keyword 
say "say hello\n";

- write perl program run as cgi by http://perl.apache.org or modules lick CGI::Fast 

- use perl document in command line 
$ perldoc -f builtin_function_name

will display the formatted help message 

- run a external command in perl source file by use backquotes wrap the command line, the output could be saved into a variable 
`command parameters`
    
#!/usr/bin/perl

@lines = `perldoc -u -f atan2`;
foreach (@lines) {
	s/\w<([^>]+)>/\U$1/g;
	print;
}


# scalar data 
- singular and plural, perl is similar, a scalar is the simplest kind of data. Scalars are either a number or string of characters 

- numbers, all numbers have a same format internally 
- floating point literals 
1.25 
225.00
-6.5e24 #
7.25e45 #7.25 times 10 to the 45th power 
-12e-24 

- integer literals, perl allows you to add underscores for clarity within integer literals 
61_298_040_283_768, equal to 61298040283768

- nondecimal integer literal 
0377 #octal, same as 255 decimal 
0xff # ff hex, also 255 decimal 
0b111111111 # binary 255 decimal 

- number operation same with python 

- strings
    + use unicode in your source doe 
use utf8; 

    + single-quoted string literals, perl does not interpret the \n within a single-quoted string as a newline, only \\n have special meaning 
    + double-quoted string literals, backslash takes its full power to specify certain control characters or octal and hex representations, backslash escape support 
\n 
\r
\t 
\f  formfeed 
\b  backspace 
\a  bell 
\e  escape
\007 octal ascii value, 007=bell 
\x7f any hex value 
\x{2744} any hex unicode code point 2744 snowflake 
\cC a control character(here ctrl-c)
\\  backslash 
\"
\l  lowercase next letter 
\L  lowercase all following letters until \E 
\u  uppercase next letter 
\U  uppercase all following letters until \E 
\Q  quote nonword characters by adding a backslash until \E 
\E  End \L, \U, or \Q

- string operators 
concatenation operator ., "hello" . "world" # same as "helloworld"
copies of string string x N, 'hello' x 3
                              4 x 4.8 # is really "5" x 4 which is "5555"

- automatic conversion between numbers and strings, string is something that isn't a number will convert to zero 

- perl's built-in warnings, told to warn you when it sees something suspicious going on in your program 

using warnings;

#!/usr/bin/perl -w 

$!perl -w 

per will warn you when you use something isn't a number 

display diagnostic message 

use diagnostics;

in further optimization can be had by using one of perl's command-line options, -M to load the pragma only when needed instead of editing the source code each time to enable the diable diagnostics 

- scalar variables, holds a single scalar value begin with a dollar sign 
$variable_name 

- scalar assignment,the perl assignment operator is the equals sign 
$fred = 17; # give fred the value of 17 
    
- output with print, print accept a sequences of arguments separated by commas

- interpolation of scalar variables into strings 
$meal = "brontosaurus steak";
$barney = "fred ate a $meal";
$barney = 'fred at a ' . $meal; #this one is equal to the above line 

- create characters by code point 
$c = chr(0x05D0);
$alpha = chr(hex('03b1'));
    
get code point by 
$code_point = ord('a');
    
- operator precedence and associativity likes python or C
()
->
++, --
\!~+-
=~!~
*/%x 
+ - .
<< >>
<< = >> lt le gt ge 
== != <= > eq ne cmd 
&
|^
&& 
|| 
.. ... 
, => list operators 
    
- perl compare number and string with different operator 
< <= == >= > != , for number 
lt le eq ge gt and ne, for string 
    
- if control structure 
if( $name gt 'fred')
{
}
else 
{
}
    
- boolean values 
$is_bigger = $name gt 'fred'; 
    
    + if the vavlue is number, 0 means flase, all other numbers 
    + otherwise, if the value is string the empty string '' means false, here is a trick hidden rules, '0' will be treat as false 
    + otherwise convert it to a number of a string and try again 
    
a handy trick to turn any value to boolean by 
$still_true = !! 'Fred';
$still_false = !! '0';   

- get user input, each time you use <STDIN> perl expects a scalar value followed by a new line 
$line = <STDIN>

need more control could use Term::ReadLine module from CPAN 

- chomp operator, the variable has to hold a string and if the string ends in a newline character, chomp() removes the newline 
$text = "a line of text\n";
chomp($text); 

if a line ends with two or more newlines, chomp() removes only one, chomp will return the number of character it removed 

- while control structure 
while(expression){
}

- the undef value, undef is a scalar variable before give it a value, which is a special value which is neither a number nor a string 
undef automatically acts like zero when used as a number, a empty string when used as string 

$n = 1;
while($n < 10){
    $sum += $n;
    $n += 2;
}

<STDIN> can return undef when there is no more input or end-of-file 
- the defined function, use built-in defined function to check a value is undef or not 
$madonna = <STDIN>;
if(defined($madonna)){
}
else 
{
}


# list and arrays 
- array or list start from zero 
- each value is a scalar value 
- define a array 
$ary[0] = 'yabba';
$ary[1] = 'dabba';

if the index of array is given by a float-point number it will be truncated not rounded!
unused array element or scalar variable will return undef 
$ary[0] = 3;
print $ary[0], $ary[1], $ary[2];
print $ary;

output: 
3 

- special array indices, if you store into an array element that is beyond the end of the array, the array is automatically extended 

    + get the last element of a array 
    $#array_name, is the index of the last element 
    
    $array_name[$#array_name], get the value of the last element 

    + support negative index like python 

- list literals, a list of comma separated values enclosed in parentheses 
(1,2,3) #list of three values 1,2, and 3 

- the qw shortcut, makes it easy to generate a list of string without typing too much quotes 
qw(fred barney bettty wilam dino) # same as 
("fred", "barney", "betty", "wilam", "dino")

qw stands for "quoted words" or "quoted by whitespace", you can't use \n or $fred inside a qw list, the whitespace characters are spaces, tabs and newlines 

perl support not only the parentheses as the delimiter 
qw! fred barney ... !

- list assignment, support like in python 
($fred, $barney) = ("flintstone", "rubble");

if the initialization list contain undef scalar variables then the value will be ignored 

this could be used to swap two values in perl 
($a, $b) = ($b, $a)

if the left and right variable number is not match, the right will be ignore and the left will be save as undef 

save entire array by 
@array_name = qw/bedrock slate lava/;
could be read as all of array_name 

the the last array index by $#array_name 

- copy a arrary by 
@copy = @ary_name 

the copied array is a deep copy 

- the pop and push operators 
@ary = 5..9; 
$fred = pop(@ary) # gets 9 
pop @ary 

push(@ary, 0);
push @ary, 1..10;

- shift and unshift operations 
@ary = qw/dino fred barney/;
$m = shift(@ary) # $m gets 'dino'

unshift(@ary, "a") # "a" will be added in at the first element of ary 

- splice operator, it takes up to four arguments, two of them are optional. with two arguments perl will removes all of the elements from your starting position to the end and return them to you 
splice(array_name, start_position)

@ary = 1..5;
@removed = splice @ary, 2;
#removed is (3,4,5)

removed = splice(array_name, start_position, length, replacement_list)
the replacement_list is added to the source array_name 

if the length is 0 then will removed nothing from array_name 

- interpolating arrays into strings 
@rocks = qw{flintstone slate rubble};
print "@rocks"; #print the array separated by space 

don't forget to escape the @ when write email 

- a single element of an array interpolates into its value, just as you'd expect from a scalar variable 
@fred = qw(eating rocks is wrong);
$fred = "right";
print "this is $fred[3]\n";
print "this is ${fred}[3]\n";
print "this is $fred"."[3]\n";
print "this is $fred\[3]\n";

output:
this is wrong
this is right[3]
this is right[3]
this is right[3]

- foreach control structure, foreach steps through a list of values, executing one iteration for each value 
foreach $rock (qw/bedrock slate lava/)
{
    print "one rock is $rock.\n"; #prints names of three rocks 
}

the control variable is not a copy of the list element, it actually is the list element. if you modify the control inside the loop, you modify the list element it self.

if you omit the control variable in foreach loop, perl use is favorite default variable $_
foreach(1..10){
    print "count to $_ \n";
}

print without parameter will print $_ by default 
- perl variable scope is like python 
- the reverse operator 
@fred = 6..10;
@barney = reverse(@fred); #gets 10, 9, 8, 7, 6

reverse return the reversed list, it doesn't affect its arguments 

- the sort, will sort the sequence and return the changed value
@return = sort 1..100; 
- each operator, from perl 5.12, you can use the each operator on arrays, before that you only use each with hashes, every time you cal each on an array it returns two values for the element in the array, the index of the value 
use 5.012;

@rocks = qw/bedrock slate rubble granite/;
while(my($index, $value)) = each @rocks) {
    say "$index: $value";
}

or you can do 
foreach $index (0...$#rocks){
    print "$index: $rocks[$index]\n";
}

- scalar and list context, most important

    + expressions in perl always return the appropriate value for their context, for example, name of an array, in a list context, it gives the list of elements. in a scalar context, it returns the number of elements in the array 
    @people = qw(fred barney betty);
    @sort = sort @people; #list context;
    $number = 42 + @people; #scalar context 42+3 gives 45 

    + even ordinary assignment causes different contexts 
    @list = @people; # a list of three people 
    $n = @people;   # the number 3 
    
- using list-producing expressions in scalar context 
    + sort in a scalar context always returns undef 
    + reverse, in list context it gives a reverse list
               in scalar context it returns a reversed string 
               
    @backwards = reverse qw/yabba dabba doo/;
    #gives doo, dabba, yabba 
    
    $backwards = reverse qw/yabba dabba doo/;
    #gives oodabbadabbay
    
- common contexts 
$fred = something;               #scalar context 
@pebbles = something;            #list context 
($wilma, $betty) = something;    #list context 
($dino) =  something;            #still list context 

if you assign to a list or an array it's a list context

    + example to provide scalar context to something 
$fred = something;
$fred[3] = st;
123 + st;
st + 654;
if(st) {...}
while(st) {...}
$fred[st] = st;

    + provide a list context 
@fred = st;
($fred, $barney) = {something};
($fred) = st;
push @fred, st;
foreach $fred (st){...}
sort st;
reverse st;
print st;

- using scalar producing expressions in list context 
@fred = 6*7; #gets the one-element list(42)
@barney = "hello" . '' . "world";

@wilma = undef; #get one element list (undef);
@betty = (); # a correct way to empty a array 

- forcing scalar context, use the fake function scalar 
@rocks = qw(talc quartz jade obsidian);
print "I have", scalar @rocks, " rocks!\n"; # gives a number 
scalar @list_name 

- <STDIN> in list context, <STDIN> is a line input operator
    + scalar context it will return the next line of input in a scalar context 
    
    + in list context it will return all of the remaining lines up to the end-of-file, it return each line as a separate element of the list 
    
    @lines = <STDIN>; #read standard input in list context 
    
    when the input is coming from a file, this will read the rest of the file 
    
    when input come from keyboard
        * unix and linux similar system use c-D 
        * windows use c-Z 
        
        
# chapter 4 subroutines 
- the name of a subroutine is another perl identifier with a sometimes-optional ampersand(&) in front
the subroutine name comes from a separate namespace, so perl won't be confused if you have a subroutine called &fred and a scalar called $fred 

this is different in python, all the variable are placed in the current object's namespace as property 

- define a subroutine, all perl subroutine have a return value but not all of them have a meaningful return value, the last evaluated expression in the body is the return value 
so if you add print at the end of a subroutine, the return value will the print function 
sub subroutine_name {
    ... 
}

- invoke a subroutine
&subroutine_name [parameters...]

- arguments, perl passes the list of arguments to the subroutine and store them in a special variable called $_ and will copy the variables by value 
$_[0], the first passed parameter, and so on, but here is a important note, these variables have nothing whatsoever to do with $_ variable, . 
for example $dino[#] have no relationship with $dino 
to reference the whole passed arguments list by @_ 
    + demo array element relationship with array_name 
$ary[0] = 1;
$ary[1] = 2;
foreach(@ary) {
    print "\n" . $_;
}

output:
1 
2 
print $ary;
output: #nothing 

reference array element by 
$ary_name[index] or @ary_name[index]

    + demo get max subroutine
sub max 
{
    if($_[0] > $_[1]){
        $_[0];
    }else{
        $_[1];
    }
}

the @_ variable is private to the subroutine, if there is a global value in @_ perl saves it before invokes the next subroutine and restore it after invoke 

- private variables in subroutines , you can create lexical variables at any time with the my operator, the private variable can be used in any code block  
without a parentheses my only declare a single lexical variable 
sub max {
    my($m, $n); #create two private variable $m and $n 
    ($m, $n) = @_ #give names to the paramters 
    if($m > $n) {$m} else {$n}
}

we could simpler the definition by 
my($m, $n) = @_;

my operator also works with foreach 
foreach my $var (list){
    ...
}

- variable-length parameter lists 
@_ != length; #check argument length 

- empty parameter list, the return value of a subroutine could be undef, a safe way to define a max function by 
sub max {
    my($max_so_far) = shift @_;
    foreach(@_){
        if($_) $max_so_far {
            $max_so_far = $_;
        }
    }
    return $max_so_far;
}

if pass empty list as max arguments, the $max_so_far will be initialize as undef and return undef 

- strick pragma
use strict; # enforce some good programming rules, such as declare variable 
use 5.012; #start with 5.12 perl loads strict by default 

perl will insist that you declare every new variable usually done with my 

- the return operator
return return_value;

- omitting the ampersand, if the compiler sees the subroutine definition before invocation or perl can tell fro the syntax that it's a subroutine call, the subroutine can be called without an ampersand 

if a subroutine have the same name as the built-in function, the ampersand is not operational 

- persistent, private variables, with state operator you can have perl keep the private values between each subroutine calls 

this is useful when your program declare as use strict; the global variable can't be reference directly from the subroutine 

state variables are enabled only when the use feature "state"; pragma is in effect or the keyword is written as CORE::state 

sub name {
    state $variable = value;
    $variable += 1;
}

a slight restriction on arrays and hashes as state variables, you can't initialize them in list context as of perl 5.10 


# chapter 5 input and output 
- input from standard input, <STDIN> operator 
$line = <STDIN>;

or, but this is a use less syntax, the input true will the enter the while body but the input will be throw away 
while(<STDIN>){
    print "I saw $_";
}

the good syntax Larry made is 
while(defined($_ = <STDIN>)){
    print "I saw $_";
}
by addition this is only works when the line-input operator in the conditional of a while loop. if you put anything else into the conditional expression, this shortcut won't apply 
the while syntax will get one line of the input and execute the body and then get another one till the end of input 

get the rest of the input, each element of the list is one line 
foreach(<STDIN>){
    print "I saw $_";
}
in foreach syntax, you use the input in a list context

while syntax will  get input line by line 

- input from the diamond operator 
    + the invocation arguments to a program are normally a number of "words" on the command line 
    $ ./program fred barney betty 
    
    in unix utility such as cat, sed, awk, sort, grep, lpr
    program will process file fred, barney and betty one by one as standard input stream
    
    <> is a diamond operator, which is named by Larry's daughter(8 years), will do the same thing as unix utility 
    
    + <> this will get user's choice of input, which may or may not get input from the keyboard 
    while(defined($line=<>)){
        chomp($line);
        print "it was $line that I saw!\n";
    }
    
- the invocation arguments, technically the diamond operator isn't looking literally at the invocation arguments it works from the @ARGV array, when program start it fill with all invocation arguments 

diamond operatr will check the @ARGV, if it is empty it will use standard input 

you could tinker the @ARGV before the diamond operator used 
@ARGV = qw/larry moe/;
while(<>){
    chomp;
    print "it was that i saw in some file $_";
}

on each loop <> will save input into $_

- output to standard output 
print 

- formatted output with printf 
printf "hello %s %d", $user, $day_to_die;

%g, automatically chooes floating point, integer, or even exponential notation 
%d, decimal 
%s, string 

format just like C, support such as %10.3f, %10s 

- arrays and printf

my @items = qw( a b c);
my $format = "items are: ". ("%s" x @items);
printf $format, @items;

- filehandles 
    + six special filehands in perl
    STDIN, STDOUT, STDERR, DATA, ARGV and ARGVOUT

    + pipeline, unix concept 

    + opening a file handle, by open operator 
    open file_handle 'file_name'   #existing file file_name
    open file_handle '<file_name'  #same as above a explicit say it read file from file_name
    open file_handle '>file_name'  #output to a new file 
    open file_handle '>>file_name' # add new data to the end 

    + to prevent unexpected arguments filename such as >file_name which file_name = '>name' will make the output from write to append, modern perl use three arguments open 
    open file_handle, '</>/>>', file_name 
    open file_handle, '</>/>>:encoding(UTF-8)', file_name 
    
    open file_handle, '<:utf8', file_name
    
    with explicty encoding support specify other encoding 

    + check all encoding support by perl 
    $ perl -MEncode -le "print for Encode->encodings(':all')"

    + a file in unix \n and windows \r\n are end with different character use 
    open handle, '>:crlf', $file_name 

    when read a file, perl will translate all cr-lf to just newlines 
    
- binmoding filehandles, in older perls used bindmode to turn off line ending processing to prevent endline symbol translate 
binmode STDOUT; #don't translate line endings  

binmodel STDOUT, ':encoding(UTF-8)'; #tell output use utf8 

- bad filehandles, if you read from a bad filehandles, you will see an immediate end-of-file 

$issuccess = open handle, '>', 'file_name';

- close filehandles, perl automatic close a filehandle if you reopen it (it means reuse the handle name in a new open)
close handle;

- fatal errors with die, when your program encounter a fatal error, perl will call the die function, so you can make your own fatal errors 
die function prints out the message you give it and makes sure that your program exits with a nonzero exit status 

traditionally 0 for success, 1 for syntax error, 2 something went wrong, 3 means the configuration file 

if(! open log, '>>', 'logfile'){
    die 'cannot create log file $!';
}
$!, is human readable complaint from the system 

you should always check the return value of open 

- warning messages with warn function
warn message;

- automatically die-ing 
if(! open LOG, '>>', 'logfile'){
    die 'cannot create log file, $!';
}

use autodie; #the program will die 

program's name is $0 it is a perl special variable, __FILE__ and __LINE__ tokens for the current execute information 

- using filehandles, you can use a filehandle appending with print or printf
print filehandle 'message';
printf fielhandle 'message';

printf (STDERR "%d percent complete.");

there is no comma between the filehandle and the items to be printed 

- changing the default output filehandle, with select operator could change the default stdout 
select filehandle;
print 'i hope something happen';
print 'output to file handle';

    + manually flush file buffer 
select handle;
$| = 1; #don't keep buffer 
select STDOUT;
print handle 'this get writes to the handle at once!';

- reopening a standard filehandle, redirect the stderr 
open STDERR, ">>log";
die 'the message will be redirect to log file'

- output with say, say will automatic add new line at each output 

- filehandles in a scalar, perl 5.6 support create filehandle in scalar variable, you don't have to use a bareword 

my $handle_fh;
open $handle_fh, '<', 'file_name'
    or die 'could not open file_name $!';
    
use the opened handle by 
while(<$handle_fh>){
    chomp;
    ...
}

when store filehandle in scalar variable to make sure perl do the right thing use brace surround the handle 
print {$handle}; #use $_ by default 
print {$rocks[0]} 'message';


# chapter 6 hashes 
- hash element access 
$hash{$some_key}

$family_name{'fred'} = 'fintstone';
$family_name{'barney'} = 'rubble';

- hash variable, subroutine, scalar variable may have the same name but will not conflict each other 
$hash{}, &sub, $scalar 

undefined hash key will return undef or can't execute base on the different perl version 

- convert hash to list and back 
%hash = ('key', value, 'key0', value1);
@ary = %hash;

the order of each hash is not guarantee

- hash assignment, copy hash 
%new_hash = %old_hash

%inverse_hash = reverse %any_hash;

- big arrow for initialize hash 
%hash = (
    key => value,
    ...
);

    + you could omit the left quotes for the keys, perl will automatic quote them for you 
    
    + another place you could omit the quote is in the curly brace
    $hash{key}, you don't have to use $hash{'key'}

    $hash{key.other}, the symbol '.' will be interpret as string concatenation
    
- hash function 
keys %hash_name; #return all the keys 
values %hash_name; #return all the values 

perl don't maintain the order, but the keys and values are return the same other 

in scalar context, perl will return the number of elements for the hash 
my $count = keys %hash_name; #return the key-value pair count 

if(%hash){
...
}
if hash contain at lease one key-value pair 

- the each function returns a key-value pair 
while(($key, $value) = each %hash){
    ...
}

the list assignment expression is a scalar context so when get to the end of hash will return a uninitialized list in scalar context, in scalar context is the number of elements in list 

sort key values by 
foreach $key (sort keys %hash){
    my $value = $hash{$key};
}

- typical use of hash 
- exists function
if( exists $hash{$key}){
    #check if the key is in the hash 
}

- delete function remove the given key from hash, if there is no such key there will be no error or warning 
delete $hash{$key};

- hash element interpolation, the element of hash could be interpolation in the double quoted string 
can directly interpolation %hash in double quote string 

string concatenation operator is scalar context 
string . scalar value 

- the %ENV hash, perl store environment variables in %ENV hash 


# chapter 7, in the world of regular expressions
- regular expression is actually a tiny program language in their own special language 
- use regular in perl 
/regular_expression/ against default $_, will return true if it found a match 

all the usual backslash escapes that you can put into double-quoted strings are available in patterns 

- unicode properties, each property have a name you can read from perluniprops documentation 
\p{PROPERTY}, for example \p{SPACE} match any whitespace
\#, back reference previous matched groups 
\g{N}, a new way to back reference support at perl 5.10+
|, alternative

- character classes, a list of possible characters inside square brackets ([])
- character shortcut
\d, digit 
\s, whitespace 
\R, newline 
 
 
# chapter 8 matching with regular expressions 
- matches with m//, just like qw// operator, you also could write m(pattern), m<...>, m{...}, m[...] with custom paired delimiters 

it is common to use curly brace as delimiter

- match modifier to change the default match behavior 
    + format 
    /pattern/modifier 

    + modifiers 
/i, case insensitive 
/s, . match any character include newline 
/x, allow added arbitrary whitespace in the pattern, use backslash space to match normal space 
    /-?[0-9]+\.?[0-9]*/ equal to  /-? [0-9]+ \.? [0-9]*/

    because new line is white space too, you could put new line and add comments to the regular expression 
    /
        -?      #an optional minus sign 
        [0-9]+  #one or more digits before the decimal point 
        \.?     #an optional decimal point 
        [0-9]*  #some optional digits after the decimal point 
    /x

for the pound sign, you have too comment it or wrap it in the character class [#]

- combining option modifiers, use more modifier then just put both at the end 
/.../is 

- choosing a character interpretation, support from perl 5.14
    + case-folding 
    + character shortcuts 

/a, tells perl use ascii 
/u, unicode 
/l, respect local 

    + for example 
/\w+/a, A-Z, a-z, 0-9
/\w+/u, any uncode word charcter 
/\w+/l, the ascii version, word chars from the local

- anchors 
\A | ^, absolute begin 
\z | $, end of string 
\Z, allowed optional newline after it 
\b, word anchor, match only the begin or end of a word 

- binding operator =~, match the pattern on the right against the string on the left 
$var =~ /pattern/; #will return true or false with pattern try to match $var 

could also works with use input 
<STDIN> =~ /pattern/;

$issuccess = $var =~ /pattern/;

- interpolating into patterns 
/($var)/, use the variable as a regex pattern 

- the match variables, the matched groups also could be reference after the match by $1, $2 in the regex pattern could be reference by \1, \2
$0 is the program path of the current executing script 

the unmatched group will be a empty string 

- persistence of captures 
    + unsuccess match will not override the previous matched sub group variables such as $1, $2 
    
- noncapturing parentheses 
add ?: in the front of the parentheses (?:...)

- named capture, label match pattern
(?<LABEL>PATTERN)
m/(?<name1>\w+) (?:and|or) (?:<name2>\w+)/x

you could also use another syntax 
\k<lable>

- the automatic match variables, there are three more variables automatic matched, whether the pattern has capture parenthese or not. the names are 
$&, $`, $'

the part of the string that actually matched the pattern is automatic store in $&;

    + example 
'hello there, neighbor' =~ /\s(\w+),/; 
$& is store with ' there,', which is entire match section 
$1 is store with 'there'

$`, is store the string before the match 
$', is store the string after the match 
combine the $`$&$', is always the original string 

    + after perl 5.10+ you could use 
${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} map to $`, $&, $'

- general quantifiers, a pattern means to repeat the preceding item a certain number of times, number inside curly braces ({})
/a{5,15}/, match to five to fifteen repeat a 

the, *, ?, + is just a shortcut for the general qualifiers 
*, {0,}
+, {1,}
?, {0,1}

- precedence, from top to slow 
()
*,+,?, {#,#}
\A, \Z, \z, ^, $, 
|
atoms, pieces of the pattern 


# Chapter 9, Processing Text with Regular expression 
- substitution with s///, m// pattern could be seem as a search feature 
s///, is a substitution operator, like search and replace 

s/search_pattern/replace_value/;

example 
s/with (\w+)/against $1's team/; # the replace string back reference the group 

the default parameter is $_

the return value is bool, true means replace successed 

by default it will do one replacement 

- global replacements 
s/.../.../g;

- different delimiter, you have replace three delimiter for s///
s#...#...#;

if you use paired characters you have to use two pairs such as  
s{search_pattern}[replce_pattern]

- substitution modifier, like the search m//, support i,x,s
- use binding operator to choose different target
- nondestructive substitution
my $original = '...';
my $copy = $original;
$copy =~ s/.../.../;

single line substitution
(my $copy = $original) =~ s/\d+ ribs?/10 ribs/;

- case shifting 
\U escape forces what follows to all uppercase 
\U$1

\L, forces lowercase 
\L$1

\E, end case shifting 

written in lowercase (\l and \u ), they affect only the next character

\u\L$1, combine the two up means first upper case the rest are lowercase 

- split operator
split, /separator/, $string;

leading empty fields are always returned, but trailing empty fields are discarded:
my @fields = split /:/, ":::a:b:c:::"; # gives ("", "", "", "a", "b", "c")

avoid use the capturing parentheses, if have to use captures use noncapturing (?...)
- the join function 
$result = join $glue, $pieces;

to add $glue required at least two pieces
my $y = join "foo", "bar"; # gives just "bar", since no foo glue is needed

- m// in list context, the return value is capture variables created in the match 

$_ = "Hello there, neighbor!";
my($first, $second, $third) = /(\S+) (\S+), (\S+)/;
print "$second is my $third\n";

my $text = "Fred dropped a 5 ton granite block on Mr. Slate";
my @words = ($text =~ /([a-z]+)/ig);
print "Result: @words\n"; # Result: Fred dropped a ton granite block on Mr Slate

my $data = "Barney Rubble Fred Flintstone Wilma Flintstone";
my %last_name = ($data =~ /(\w+)\s+(\w+)/g);
each match is read into a hash equal to 
$last_name = {
    Fred => Flintstone,
    Wilma => Flintstone,
    Barney => Rubble,
};

- nongreedy quantifiers 
+?, *?
??. That matches either once or not at all,

- matching multiple-line text 
the /m regular expression option lets them match at internal newlines

$_ = "I'm much better\nthan Barney is\nat bowling,\nWilma.\n";
print "Found 'wilma' at start of line\n" if /^wilma\b/im;

- updating many files, example 
aim files format:
Program name: granite
Author: Gilbert Bates
Company: RockSoft
Department: R&D
Phone: +1 503 555-0095
Date: Tues March 9, 2004
Version: 2.1
Size: 21k
Status: Final beta
...

change name, datetime and remove phone 

perl script 
#!/usr/bin/perl -w
use strict;
chomp(my $date = `date`);
$^I = ".bak";

while (<>) {
    s/^Author:.*/Author: Randal L. Schwartz/;
    s/^Phone:.*\n//;
    s/^Date:.*/Date: $date/;
    print;
}

the $^I, the default value is undef when add string to this built-in variable, diamond operator will open the aim file and rename the file_name to file_name.$^I as default input stream, then diamond will create a new file named as file_name, diamond will select the new created one as output stream 

some people will use '~' as backup extension which is used by emacs
if $^I equal to empty string, this enabled in-place editing 

- in-place editing from the command line 
$perl -p -i.bak -w -e 's/SearchPattern/ReplaceValue/g' *.dat

The -p option tells Perl to write a program for you. It’s not much of a program, though;
it looks something like this:
while (<>) {
print;
}

The -e option says “executable code follows.” That means that the s/Randall/Randal/g string is treated as Perl code


# Chapter 10 more control strutures 
- unless control structure, execute a code block only when conditional is false 
unless(is_false_then_execute){
    ...
}
[else{
    ...
}]

unless(1){
    print "executed";
} # will print nothing 
else{
    print "will print this";
}

- the until control structure, used to reverse the condition of while loop 
until(is_false_conditoin){
    ...
}

- expression modifiers 
    + if modifier
expression if condition;

equal to 
if(condition){
    expression;
}

    + unless modifier
expression unless condition;

    + until modifier 
expression until condition;

    + while modifier 
expression while condition;

    + foreach modifier, there is not way to choose a different control variable, it's always $_
expression foreach condition;

- the naked block control structure, its just a code block, its provide temporary lexical variables                

- elseif clause
if(condition){
    ...
}elsif(condition){
    ...
}elsif(condition){
    ...
}else{
    ...
}

- autoincremenet and autodecrement 
    + add ++ in operator to a scalar, just like it in C
    
    + if the scalar variable doesn't exist, it will be created automatically, $undefined++ will become to 1
    
    + example, count the number of appearance words 
my @people = qw{ fred barney fred wilma dino barney fred pebbles };
my %count; # new empty hash
$count{$_}++ foreach @people; # creates new keys and values as needed

- the value of autoincrement, could put ++, -- in front of a value like C    

- the for control structure 
for(initialization; test; increment){
}

the loop structure will add a new code block 

for(my $i = 0; $i < 10; $i++){
    my $j = $i + $i;
    say $i;
}

say "i=$i";
say "j=$j";

will display nothing for $i and $j;

- the secret connection between foreach and for, in perl the keyword foreach is exactly equivalent to the keyword for. use foreach as foreach(;;) will become for 

the loop with two semicolon will not assign the variable $_ 
for/foreach($i = 0; $i < 10; $i++){
    say $i;
}
will print nothing

- loop controls
    + last operator, immediately ends execution of the loop, like break in C
    while (1){
        last;
    }
    
    + next, like continue in C

    + redo operator, it means to go back to the top of the current loop block and run again 
    while (1){
        ...
        redo if condition; #if condition is true then goback to the top 
        ...
    }

- labeled block, recommends make the label name all uppercase. used to work with a loop which is not the innermost one 
LABEL_NAME: while(<>){
    foreach(split){
        last LABEL_NAME if condition; # bail out of the line loop
    }
}

the labels could works with last, next, redo keywords 

- the conditional operator ?: 

- logical operators 
logical AND operator &&
logical OR operator ||

- the value of a short circuit operator, use or to set default variable value 

my $last_name = $last_name{$someone} || '(No last name)';

- the defined-or operator, perl 5.10 added with defined-or operator //, 

use 5.010;
my $last_name = $last_name{$someone} // '(no last name)';


use 5.010;
my $Verbose = $ENV{VERBOSE} // 1;
print "I can talk to you!\n" if $Verbose;

- control structures using partial-evaluation operators 
&&, ||, ?:

the idiomatic way of opening a file in perl looks like 
open my $fh, '<', $filename 
    or die "can't open '$filename':$!";


# Chapter 11, perl modules 
- a lots of people do interesting works with perl, check the information at Comprehensive Perl Archive Network(CPAN),

- finding modules, there are two types of module
    + those come with perl 
    + those you could get from CPAN
    http://search.cpan.org 


    + check if a module is installed 
        * check with perldoc 
        $perldoc module_name 

        * create a autobundle with cpan command 
        $ cpan -a 
        
- installing modules, there are two major build systems for perl distributions 
    + use MakeMaker, sequence will be 
    $ perl Makefile.PL 
    $ make install 
    
    if you can't install modules in the system-wide directories you can specify another directory by 
    $ perl Makefile.PL INSTALL_BASE=/Users/fred/lib 
    
    + others use Module::Build, to build and install their creations 
    $ perl Build.PL 
    $ ./Build install 

    specify an alternative directory by 
    $ perl Build.PL --install_base=/Users/fred/lib 

    + use CPAN.pm from the command line can solve the module dependence like python pip 
    $ perl -MCPAN -e shell 
    
    The “.pm” file extension stands for “Perl Module,” and some popular modules are pronounced with the “.pm” to distinguish them from something else.
    
    some authors wrote a little script called cpan, you could directly call this script to wrap the complex 
    $ cpan list_of_module_name

    + active perl have a package manager 
    + use cpanm for capnminus, is a CPAN client, http://xlr.us/cpanm 
    
    after that just tell him the module list you want to install 
    $ cpanm list_of_module_name
    
- using your own directories, common problems with perl module installation is that by default CPAN tools want to install new modules into same directories where perl is 
    
you might need proper permissions to create new files in those directories 

    + easy way is use local::lib 
    $ perl -Mlocal::lib 
    export PERL_LOCAL_LIB_ROOT="/Users/fred/perl5";
    export PERL_MB_OPT="--install_base /Users/fred/perl5";
    export PERL_MM_OPT="INSTALL_BASE=/Users/fred/perl5";
    export PERL5LIB="...";
    export PATH="/Users/brian/perl5/bin:$PATH";

    cpan client supports this if you use the -I swith to install modules 
    $ cpan -I Set::Crossproduct 
    
    + cpanm is a bit smarter, if you already set the environment variable local::lib, it uses them. or you could execute with explicit local::lib 
    $ cpanm --local-lib module_name 

    + set configuration for Makemaker and build system 
    $ cpan
    cpan> o conf makepl_arg INSTALL_BASE=/Users/fred/perl5
    cpan> o conf mbuild_arg "--install_base /Users/fred/perl5"
    cpan> o conf commit
    
    + tell the program where to find the installed module by 
        * use local::lib then use 
        # inside your Perl program
        use local::lib;
        
        * if in other directory you could use lib pragma by 
        # also inside your Perl program
        use lib qw( /Users/fred/perl5 );
    
- use simple modules 
use 5.014;

my $name = '/usr/local/bin/perl';
my $basename = $name =~ s#.*/##r; #oops 

these code will not work well in unix because unix directory name may contain newline 
these code are unix specific 
the codes are remake the wheel and 

    + a better way to extract filename, with File::Basename 
use File::Basename;

my $name = '/usr/local/bin/perl';
my $basename = basename $name; #gives 'perls'
    
- only use some functions from a module 
    + load an import list, showing exactly which function names it should give you 
    use File::Basename qw/func0, func1,.../;
    
    + load with empty list which means all the function in the module should be called with full name 
    use File::Basename qw//;
    use File::Basename ();
    
    my $dirname = File::Basename::dirname $name; # dirname from the module
    
    + each module have a default import list, such as File::Basename will import dirname, basename, rename, ...
    
- the File::Spec module, it is a object oriented module, which is used to manipulating file specifications such as names, directories and other things that stored on filesystems 

use File::spec;

my $new_name = File::Spec->catfile($dirname, $basename);

rename($old_name, $new_name)
or warn "Can't rename '$old_name' to '$new_name': $!";

the method catfile is used to combine directory and file name to full name 

    + for oo module, you have to always call the method with small arrow 
module_name->method 

    + for oo module, you import a empty method list 

- Path::Class, module which is doesn't come with perl, supply a more pleasant interface compare to File::Spec module 
    
my $dir = dir(qw(Users fred lib));
my $subdir = $dir->subdir('perl5'); #Users/fred/lib/perl5
my $parent = $dir->parent;          #User/fred
    
- CGI.pm used to help create cgi application with perl 
- database and dbi , DBI module 
use DBI;
$dbh = DBI->connect($data_source, $username, $password);
- dates and times, DateTime object   

  
# Chapter 12 file tests 
- file test operators, you could find their documentation in perlfunc. the -X operator with the filehandle 

    + test file exists or not with -e 

die 'A file $filename already exists'
    if -e $filename; 
    
    + get file modification times by opened filehandler, -M 
    $modify_times = -M fileHandle; #will return the modify times 
    
    + get file size in bytes by -s $file_handle 
    
    + get file access times by -A $file_handle 
    
    + file test tables 
File test   Meaning
-r          File or directory is readable by this (effective) user or group
-w          File or directory is writable by this (effective) user or group
-x          File or directory is executable by this (effective) user or group
-o          File or directory is owned by this (effective) user
-R          File or directory is readable by this real user or group
-W          File or directory is writable by this real user or group
-X          File or directory is executable by this real user or group
-O          File or directory is owned by this real user
-e          File or directory name exists
-z          File exists and has zero size (always false for directories)
-s          File or directory exists and has nonzero size (the value is the size in bytes)
-f          Entry is a plain file
-d          Entry is a directory
-l          Entry is a symbolic link
-S          Entry is a socket
-p          Entry is a named pipe (a “fifo”)
-b          Entry is a block-special file (like a mountable disk)
-c          Entry is a character-special file (like an I/O device)
-u          File or directory is setuid
-g          File or directory is setgid
-k          File or directory has the sticky bit set
-t          The filehandle is a TTY (as reported by the isatty() system function; filenames can’t be tested by this test)
-T          File looks like a “text” file
-B          File looks like a “binary” file
-M          Modification age (measured in days)
-A          Access age (measured in days)
-C          Inode-modification age (measured in days)

if you have a symbolic link pointing to a file, that will report true for both -f and -l.
negative file access age means in the feature 
a value of 2.00001 if a file had been modified two days and one second ago.

the -t file test returns true if the given filehandle is a TTY such as keyboard 

the default file test operand is $_ 

- whenever operator works with $_, use parentheses wrapper around would be a better idea 

- testing several attributes of the same file with the virtual filehandle _, its the value from the last file lookup 
if(-r $file and -w _){
...
}

- stacked file test operators, support start from perl, 5.010, test in one line 
if(-w -r $file){
...
}

- the stat and Istat functions the operand to stat is a filehandle (including the _ virtual filehandle)

    + stat function return a list of 13 element or a empty list which means it is failed 
    my($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks) = stat($filename);
    
$dev and $ino, the device number and inode number of the file 
$mode, the set of permission bits for the file and some other bits, like like -rwxr-xr-x.
$nlink, the nubmer of links to the file or directory 
$uid and $gid, user id and group id showing the file's ownership 
$atime, $mtime and $ctime, access time, modify time, change time, start from 1970 at mid night 

    + what is inode number in linux/unix an index node, informally referred to as an inode, is a data structure used to represent a filesystem object, which can be one of various things including a file or a directory
https://en.wikipedia.org/wiki/Inode

    + check the symbol link information instead of the file by lstat

- localtime function 
    + in scalar context 
    “Thu May 31 09:48:18 2007”. Perl can do that with the localtime function in a scalar context:
my $timestamp = 1180630098;
my $date = localtime $timestamp;

    + in list context 
my($sec, $min, $hour, $day, $mon, $year, $wday, $yday, $isdst) = localtime $timestamp;

$mon is a month number, ranging from 0 to 11
The $year is the number of years since 1900, oddly enough
The $wday ranges from 0 (for Sunday) through 6(for Saturday)
$yday is the day-of-the-year (ranging from 0 for January 1,through 364 or 365 for December 31).

Both localtime and gmtime default to using the current time value if you don’t supply a parameter

- bitwise operators 
10 & 12 Bitwise-and—which bits are true in both operands (this gives 8)
10 | 12 Bitwise-or—which bits are true in one operand or the other (this gives 14)
10 ^ 12 Bitwise-xor—which bits are true in one operand or the other but not both (this gives 6)
6 << 2 Bitwise shift left—shift the left operand by the number of bits shown in the right operand, adding zero-bits at
the least-significant places (this gives 24)
25 >> 2 Bitwise shift right—shift the left operand by the number of bits shown in the right operand, discarding the leastsignificant
bits (this gives 6)
~10 Bitwise negation, also called unary bit complement—return the number with the opposite bit for each bit in
the operand (this gives 0xFFFFFFF5)

- using bitstrings, All of the bitwise operators can work with bitstrings, as well as with integers.
But if both operands of a bitwise operator are strings, Perl will perform the operation on those bitstrings. That is, "\xAA" | "\x55" will give the string "\xFF". Note that these values are single-byte strings; the result is a byte with all eight bits set. Bitstrings may be arbitrarily long.


# Chapter 13 Directory Operations 
- move around the directory tree, chdir operator change the current working directory 
chdir '/etc' or die "cannot chdir to /etc: $!";

normally check $! when chdir returns a false 

chdir without an argument, Perl determines your home directory as best as possible and attempts to set the working directory to your home directory

- globbing 
foreach $arg (@ARGV){
    print 'one arg is $arg\n';
}
When you run this program with a glob as the single argument, the shell expands the glob before it sends the result to your program

$ perl show-args *.pm
one arg is barney.pm
one arg is dino.pm
one arg is fred.pm
one arg is wilma.pm

direct use glob in perl 
my @all_files = glob '*';

including multiple patterns separated by spaces

if save the glob result into scalar context will only save the first one 

- an alternate syntax for globbing 
my @all_files = <*>; # exactly the same as my @all_files = glob "*";

my $dir = '/etc';
my @dir_files = <$dir/* $dir/.*>;

Here, you fetch all the non-dot and dot files from the designated directory because
$dir has been expanded to its current value.

    + So, if the item between the angle brackets is strictly a Perl identifier, it’s a filehandle read; otherwise, it’s a globbing operation
my @files = <FRED/*>; # a glob
my @lines = <FRED>; # a filehandle read
my @lines = <$fred>; # a filehandle read
my $name = 'FRED';
my @files = <$name/*>; # a glob

    + one exception is if the contents are a simple scalar variable (not an element of a hash or array) that’s not a filehandle object, then it’s an indirect filehandle read
my $name = 'FRED';
my @lines = <$name>; # an indirect filehandle read of FRED handle

- directory handles, read directory handle with readdir, Another way to get a list of names from a given directory is with a directory handle

my $dir_to_process = '/etc';
opendir my $dh, $dir_to_process or die "Cannot open $dir_to_process: $!";
foreach $file (readdir $dh) {
print "one file in $dir_to_process is $file\n";
}
closedir $dh;

You can also use a bareword directory handle, just like you could with a filehandle, but this has the same problems:
opendir DIR, $dir_to_process
or die "Cannot open $dir_to_process: $!";
foreach $file (readdir DIR) {
print "one file in $dir_to_process is $file\n";
}
closedir DIR;

The filenames returned by the readdir operator have no pathname component. It’s just the name within the directory.

opendir my $somedir, $dirname or die "Cannot open $dirname: $!";
while (my $name = readdir $somedir) {
    next if $name =~ /^\./; # skip over dot files
    $name = catfile( $dirname, $name ); # patch up the path
    next unless -f $name and -r $name; # only readable files
    ...
}

- recursive directory listing Perl comes with a nice library called File::Find, which you can use for nifty recursive directory processing

If you are already using Unix find commands to get work done, you can convert them to Perl programs with the find2perl program that comes with Perl.

- manipulating files and directories 
    + remove file In Perl, you use the unlink operator with a list of the file that you want to remove:
unlink 'slate', 'bedrock', 'lava';
unlink qw(slate bedrock lava);

unlink glob '*.o';
This is similar to rm *.o at the shell,

The return value from unlink tells you how many files have been successfully deleted

When a particular unlink fails, Perl sets the $! variable to something related to the operating system error

- renaming files 
rename 'old', 'new';

- links and files 
That’s why you can use rename to move a file from one directory to another, but only if both directories are on the same filesystem (mounted volume).

    + a new and different kind of link: a symbolic link.† A symbolic link (also called a soft link to distinguish it from the true or hard links that we’ve been talking about up to now) is a special entry in a directory that tells the system to look elsewhere

symlink 'dodgson', 'carroll' 
    or warn "can't symlink dodgson to carroll: $!";

    + find out where a symbolic link is pointing, use the readlink function
my $where = readlink 'carroll'; # Gives "dodgson"
my $perl = readlink '/usr/local/bin/perl'; # Maybe tells where perl is

- making removing directories 
mkdir 'fred', 0755 or warn "Cannot make fred directory: $!";

    + To remove empty directories, use the rmdir function in a manner similar to the unlink function
rmdir $dir or warn "cannot rmdir $dir: $!\n";

    + modifying permissions, Perl has the chmod function to perform this task: 
chmod permission, list_of_files;
chmod 0755, 'fred', 'barney';

- chaning ownership 
    + both have to be the numeric user ID and group ID values
my $user = 1004;
my $group = 100;
chown $user, $group, glob '*.o';

    + Just call the getpwnam function to translate the name into a number, and the corresponding getgrnam* to translate the group name into its number:
defined(my $user = getpwnam 'merlyn') or die 'bad user';
defined(my $group = getgrnam 'users') or die 'bad group';
chown $user, $group, glob '/home/merlyn/*';

- changing timestamps 
use the utime function to fudge the books a bit. The first two arguments give the new access time and modification time

my $now = time;
my $ago = $now - 24 * 60 * 60; # seconds per day
utime $now, $ago, glob '*'; # set access to now, mod to a day ago


# strings and sorting 
- find substring from index, The character position returned is a zero-based
value. on. If index can’t find the substring at all, it returns –1 to indicate that.
$where = index($big, $small);

index str, substr, position;
rindex str, substr, position;

- manipulating a substring with substr
substr expr, offset, length, replacement;

- format data with sprintf
sprintf format, arg_list;

- interpreting non-decimal numbers, use hex(), oct()
hex('DEADBEEF') # 3_735_928_559 decimal
hex('OxDEADBEEF') # 3_735_928_559 decimal
oct('0377') # 255 decimal
oct('377') # 255 decimal

- advance sorting, custom compare function 
sub by_number {
    # a sort subroutine, expect $a and $b
    if ($a < $b) { –1 } elsif ($a > $b) { 1 } else { 0 }
}

To use the sort subroutine, just put its name (without an ampersand) between the
keyword sort and the list you’re sorting

my @result = sort by_number @some_numbers;

Many sort-subroutine names begin with by_ to describe how they sort.

    + use the spaceship operator (<=>).† This operator compares two numbers and returns –1, 0, or 1 as needed to sort them numerically. So you could write that sort subroutine better, like this:
sub by_number { $a <=> $b }

    + three-way string-comparison operator: cmp.
sub by_code_point { $a cmp $b }
my @strings = sort by_code_point @any_strings;

it's a default compare method like cmp 

    + a case-insensitive sort:
sub case_insensitive { "\L$a" cmp "\L$b" }

- sorting by a hash value 


# smart matching and given-when 
- switch to release version 5.010
- smart match operator, The smart match operator, ~~, looks at both of its operands and decides on its own how it should compare them.

before perl 5.010, you have to use loop to check the keys in a hash 
my $flag = 0;
foreach my $key ( keys %names ) {
next unless $key =~ /Fred/;
$flag = $key;
last;
}
print "I found a key matching 'Fred'. It was $flag\n" if $flag;

with smart matching you could 

use 5.010001;
say "I found a key matching 'Fred'" if %names ~~ /Fred/;

compare two arrays (limiting them to the same size just to make things simpler), you could go through the indices of one of the arrays and compare the corresponding elements in each of the arrays.
use 5.010001;
say "The arrays have the same elements!"
if @names1 ~~ @names2;

use 5.010001;
my @nums = qw( 1 2 3 27 42 );
my $result = max( @nums );
say "The result [$result] is one of the input values (@nums)"
    if @nums ~~ $result;

- smart match precedence 
Example                         Type of match
%a ~~ %b                        hash keys identical
%a ~~ @b or @a ~~ %b            at least one key in %a is in @b
%a ~~ /Fred/ or /Fred/ ~~ %b    at least one key matches pattern
'Fred' ~~ %a                    exists $a{Fred}
@a ~~ @b                        arrays are the same
@a ~~ /Fred/                    at least one element in @a matches pattern
$name ~~ undef                  $name is not defined
$name ~~ /Fred/                 pattern match
123 ~~ ’123.0’                  numeric equality with “numish” string
’Fred’ ~~ ’Fred’                string equality
123 ~~ 456                      numeric equality

- given statement The given-when control structure allows you to run a block of code when the argument to given satisfies a condition. equivalent to switch in C 

given ( $ARGV[0] ) {
when ( 'Fred' ) { say 'Name is Fred' }
when ( /fred/i ) { say 'Name has fred in it' }
when ( /\AFred/ ) { say 'Name starts with Fred' }
default { say "I don't see a Fred" }
}

a given-when can satisfy one condition and then try the others, too. Once an if-elsif-else satisfies a condition, it will only ever execute one block of code.

use 5.010001;
given ( $ARGV[0] ) {
    when ( $_ ~~ 'Fred' ) { say 'Name is Fred'; break }
    when ( $_ ~~ /fred/i ) { say 'Name has fred in it'; break }
    when ( $_ ~~ /\AFred/ ) { say 'Name starts with Fred'; break }
    default { say "I don't see a Fred"; break }
}

Putting a continue at the end of each when block means Perl tries every condition
    use 5.010001;
    given ( $ARGV[0] ) {
    when ( $_ ~~ 'Fred' ) { say 'Name is Fred'; continue } # OOPS!
    when ( $_ ~~ /fred/i ) { say 'Name has fred in it'; continue }
    when ( $_ ~~ /\AFred/ ) { say 'Name starts with Fred'; continue }
    default { say "I don't see a Fred" } # default block will also run 
}
That default block is really a when with a condition that is always true. If the when before the default has a continue, Perl goes on to the default, too.

- Dumb match, normal regular expression 
use 5.010001;
given ( $ARGV[0] ) {
    when ( 'Fred' ) { #smart
    say 'Name is Fred'; continue }
    when ( $_ =~ /\AFred/ ) { #dumb
    say 'Name starts with Fred'; continue }
    when ( /fred/i ) { #smart
    say 'Name has fred in it'; }
    default { say "I don't see a Fred" }
}

- using when with many items 

# Chapter 16, process management 
- system function, simplest way to launch a child process in Perl to run a program
system 'date';

system list;
system program list;

The return value of the system operator is based upon the exit status of the child command

!system 'rm -rf files_to_delete' or die 'something went wrong';

- environment variables, In Perl, the environment variables are available via the special %ENV hash

$ENV{'PATH'} = "/home/rootbeer/bin:$ENV{'PATH'}";
delete $ENV{'IFS'};

- the exec function 
The system function creates a child process, which then scurries off to perform the requested action while Perl naps. The exec function causes the Perl process itself to perform the requested action.

When you reach the exec operation, Perl locates bedrock and “jumps into it.” At that
point, there is no Perl process any more

chdir '/tmp' or die "Cannot chdir /tmp: $!";
exec 'bedrock', '-o', 'args1', @ARGV;

it doesn’t make any sense to have any Perl code following the exec, except for handling the error when the requested command cannot be started:

- Using Backquotes to Capture Output

capture system or exec function output by a string using backquotes instead of single or double quotes:
my $now = `date`; # grab the output of date
print "The time is now $now"; # newline already present

$about{$_} = `perldoc -t -f $_`;

    + generalized quoting operator, qx() that does the same thing:
foreach (@functions) {
    $about{$_} = qx(perldoc -t -f $_);
}

    + shell’s process ID variable $$ instead of Perl’s, you use qx'' to avoid the interpolation:
my $output = qx'echo $$';

use the shell’s normal “merge standard error to the current standard output,” which is spelled 2>&1 in the normal Unix shell
my $output_with_errors = `frobnitz -enable 2>&1`;

    + add a redirection from /dev/null for input, like this:
my $result = `some_questionable_command arg arg argh </dev/null`;

- using backquotes in a list context 
    + The scalar context use of backquotes returns the captured as a single long string

    + using the same backquoted string in a list context yields a list containing one line of output per element.

foreach (`who`) {
    my($user, $tty, $date) = /(\S+)\s+(\S+)\s+(.*)/;
    $ttys{$user} .= "$tty at $date\n";
}
    will place the each line of the output of the command who into the variable $_
    
- external process with IPC::System::Simple module, you have to get it from CPAN
    
    + in the previous you have to use 
    use IPC::System::Simple qw(system);
    my $tarfile = 'something*wicked.tar';
    my @dirs = qw(fred|flintstone <barney&rubble> betty );
    system 'tar', 'cvf', $tarfile, @dirs;
    
    + in the current with the module Simple 
    systemx 'tar', 'cvf', $tarfile, @dirs;
    
- processes as filehandles, run child processs and communicate with perl process 
    + lauching a concurrent child process is to put the command as the "filename" for an open call, connect stdout
    open DATE, 'date|' or die 'cannot pip from date: $!';
    
    Perl launches the command with its standard output connected to the DATE filehandle opened for reading
    
    The open fails if Perl can’t start the child process. If the command itself does not exist or exits erroneously, Perl will not see this as an error when opening the filehandle, but as an error when closing it.
    
    + connect with stdin 
    open MAIL, '|mail merly' or die 'cannot pipe to mail $!';
    
    
    + another way to control input output by -| read filehandle, |- write file handle 
    
    The pipe opens can also take more than three commands. The fourth and subsequent arguments become the arguments to the command
    open my $mail_fh, '|-', 'mail', 'merlyn'
    
    When you close a filehandle open for writing to a process, the process will see end-of-file.
    
    + read from file handle 
    So, to get data from a filehandle opened for reading, you read the filehandle normally:
my $now = <$date_fh>;

- getting down and dirty with fork, open child process 
    + higher level call 
    system 'date'
    
    + low-level system call 
    defined(my $pid = fork) or die "Cannot fork: $!";
    unless ($pid) {
    # Child process is here
    exec 'date';
    die "cannot exec date: $!";
    }
    # Parent process is here
    waitpid($pid, 0);
    
    + check more detail from the perlipc documentation
    
- sending and receiving signals, SIGINT meaning interrupt signal, from 1 to 16, 1 to 32 1 to 63 depending on your unix favor 

    + on unix get all of the running process by kill -l 
    
    kill 'INT', 4201 or die "cannot signal 4201 with SIGINT: $!";
    kill 2, 4201 or die "cannot signal 4201 with SIGINT: $!";
    kill INT => 4201 or die "cannot signal 4201 with SIGINT";

    + window doesn't have signal, uses message 
    + check process still alive by signal 0 
    unless(kill 0, $pid){
        warn "$pid has gone away!";
    }

    
# chapter 17 some advanced perl techniques 
- books for higher level 
Intermediate Perl 

- slices
    + one way to split input from stream is 
    while (<$fh>){
        chomp;
        my($name, $card_num, $addr, $home, $work, $count) = split /:/;
    }
    
    + If you use undef as an item in a list you’re assigning to, Perl simply ignores the corresponding element of the source list:
    my(undef, $card_num, undef, undef, undef, $count) = split /:/;
    
    + a list slice. Here, since the mtime is item 9 in the list returned by stat,
    my $mtime = (stat $some_file)[9];
    
    Those parentheses are required around the list of items
    my $mtime = stat($some_file)[9]; # Syntax error!
    my $card_num = (split /:/)[1];

    my($card_num, $count) = (split /:/)[1, 5]; #will pull out element 1 and 5 
    
    support negative index 
    
- array slice 
my number = @ary[index0, index1, ..]

it is equal to @names[ 2, 5 ] means the same list as ($names[2], $names[5])

assign to values 
@items[2, 3] = ($new_address, $new_home_phone);

    + the slice in one place where you can't use a list 
    my @names = qw{ zero one two three four five six seven eight nine };
    @items[2, 3] = ($new_address, $new_home_phone);
    print "Bedrock @names[ 9, 0, 2, 1, 0 ]\n";

- hash slice 
my @three_scores = ($score{"barney"}, $score{"fred"}, $score{"dino"});
my @three_scores = @score{ qw/ barney fred dino/ };

A slice is always a list, so the hash slice notation uses an at sign to indicate that.

In Perl, the dollar sign means there’s just one of something, but the at sign means there’s a list of items, and the percent sign means there’s an entire hash.
my @players = qw/ barney fred dino /;
my @bowling_scores = (195, 205, 30);
@score{ @players } = @bowling_scores;

- third book, mastering perl 
- trapping erros 
    + use eval, catch fatal errors by wrap the code in eval block, program. As soon as the eval encounters a normally fatal error, it stops the entire block and continues with the rest of the program.
eval { $barney = $fred / $dino };

my $result = eval {... }
If the eval caught a fatal error, it returns undef and puts the error message in the $@ special variable,

    + four kinds of error eval can't trap 
        * syntax error 
        * serious error which crash perl itself, such as out of memory, getting an untrapped signal 
        * eval block can't trap are warnings 
        to trap warning by __WARN__ pseudosignal
        
        * it is not a real error, but exit operator terminates the program at once 

    + eval interpolation string in perl, the string will be executed as normal perl code 
    my $operator = 'unlink';
    eval "$operator \@files;";
    
- more advanced error handling 
    + check the error information 
eval{
...
}
if($@ =~/unexpected/){
...
}
elsif($@ =~/denominator/){
...
}

    + use Try::Tiny module solves most of this problems 
use Try::Tiny;
try {
...; # some code that might throw errors
}
catch {
...; # some code to handle the error
}
finally {
...;
}

Instead of messing with $@, Try::Tiny puts the error message in $_.

- autodie, start from perl 5.10.1, perl support a pragma that gives you more contorl over how you handle errors in your program 
use autodie 

open my $fh, '>', $filename; #still dies on error 
    
    + You can control which operators you apply autodie to by specifying them in the import list
use autodie qw(open system :socket);

    when auto die throws an error, it puts an autodie::exception object in $@

- picking items from a list with grep, grep is a operator to act as a filter 
my @odd_numbers = grep { $_ % 2 } 1..1000;
gets a list of 500 odd numbers in one quick line of code 

my @matching_lines = grep { /\bfred\b/i } <$fh>;
select only the liens mentioning fred from a file 

my $line_count = grep /\bfred\b/i, <$fh>;
only get the match count of the lines 

- transforming items from a list with map 
my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);
my @formatted_data = map { &big_money($_) } @data;

map block/expr, list;
evalue the block or expression for each element of the list and return the list value composed of the results of each such evaluation. in scalar context, return the total number, in list context return a list may contain zero or more elements 

- fancier list utilities, list::util module comes with the standard library and provides high performance versions of common list processing utilities. implemented at c level, higher performance than grep 
    + use first subroutine from List::Util
use List::Util qw(first);
my $first_match = first {/bPebbles\b/i} @characters;

    + other support functions such as 
sum, 
max, 
maxstr, 
shuffle ( used to randomize the order of elements in a list), 

    + use List::MoreUtil
none, 
any, 
all, 
natatime(deal with list in groups of items, split the list into the given lenght or sub arrays)
    use List::MoreUtils qw(natatime);
    my $iterator = natatime 3, @array;
    while( my @triad = $iterator->() ) {
    print "Got @triad\n";
    }
    
mesh, used to combine two or more lists the first item is come from the first and second is come from the second and third come from the third. then the fourth will come from the first and so on. if some of the list is shorter than the others the value of the generated list will be set as undefined 
    use List::MoreUtils qw(mesh);
    my @abc = 'a' .. 'z';
    my @numbers = 1 .. 20;
    my @dinosaurs = qw( dino );
    my @large_array = mesh @abc, @numbers, @dinosaurs;

    output 
    a 1 dino b 2 c 3 ...


# Appendix b, beyong the liama 
- perltoc (table of contents) and perlfaq (frequently asked questions) sections.
- regular expression, perlre documentation (and its companion perlretut and perlrequick in newer versions of Perl).
- package
- write your own module, See the perlmod and perlmodlib documentation for more information.
- other operators and functions 

    + The tr/// operator looks like a regular expression, but it’s really for transliterating one group of characters into another. It can also efficiently count selected characters. See the perlop documentation.

    + here document  a useful form of multiline string quoting; 
    + mathematics 
    + advanced math functions, perlfunc 
    + imaginary and complex numbers, perl doesn't directly support them Math::Complex module 
    + large and high precision numbers, Math::BigInt and Math::BigFloat 

- list and arrays 
- networking and IPC, perl support it 
- system v ipc, The standard functions for System V IPC (interprocess communication) are all supported by Perl

perlfunc and the perlipc documentation.

- sockets, LWP module
- security, perlsec documentation.
- debugging, perldebug documentation 
- command-line options, perlrun 
- built-in variables, perlvar documentation 
- syntax extensions, check perlmod documentation 
- references similar to C pointers perlreftut and perlref documentation.
- complex data structures, perldsc (data-structures cookbook) and perllol (lists of lists) documentation.
- object-oriented programming, check perlobj and perlboot documentations 
- anonymous subroutines and closures Closures are a powerful concept that comes to Perl from the world of Lisp. A closure is (roughly speaking) an anonymous subroutine with its own private data.
- tied variables, perltie documentation 
- operator overloading, you can redefine operators like addition, concatenation, comparison or even the implicit string 
- dynamic loading 
- embedding, apache's mod_perl 
- converting other language to perl, check SWIG system 
- converting find command lines to perl, find2perl which comes with Perl, takes the same arguments that find does $_ will contain the item’s name.

$ find2perl /tmp -atime +14 -eval unlink >Perl-program
That command says to search in /tmp (and recursively in subdirectories) for items whose atime (last access time) is at least 14 days ago. For each item, the program should run the Perl code unlink, which will use $_ by default as the name of a file to remove. The output (redirected to go into the file Perl-program) is the program that does all of this

- command-line options in your programs, Getopt::Long and Getopt::Std modules 
- embedded documentation, pod(plain-old-documentation) format, check perldoc documentation
- more ways to open filehandles, perlopentut document
- threads and forking, check perlfork and perlthrtut document
- graphic user interface, tk, wx and others 

# Appendix C, a unicode primier 
- unicode character, UCS(unicode character set)
- getting everyone to agree 
- fancy characters 
- dealing with unicode in perl, You do that with the utf8 pragma, whose only job is to
tell perl how to interpret your source.
use utf8; 

- reading from or writing to STDOUT or STDERR 
    + use a particular encoding with a filehandle. The first one uses binmode:
binmode STDOUT, ':encoding(UTF-8)';
binmode $fh, ':encoding(UTF-16LE)';

    + You can also specify the encoding when you open the filehandle:
open my $fh, '>:encoding(UTF-8)', $filename;

    + you can do both in single line of code 
    use open IN => ":crlf", OUT => ":bytes";
    
    + both input and output, you can set them at the same time, either using IO or omitting it:
use open IO => ":encoding(iso−8859−1)";
use open ':encoding(UTF-8)';
    
    + Since the standard filehandles are already open, you can apply your previously stated encoding by using the :std subpragma:
use open ':std';

    + You can also set these on the command line with the -C switch, which will set the encodings on the standard filehandles according to the arguments you give to it:
I 1 STDIN is assumed to be in UTF−8
O 2 STDOUT will be in UTF−8
E 4 STDERR will be in UTF−8
S 7 I + O + E
i 8 UTF−8 is the default PerlIO layer for input streams
o 16 UTF−8 is the default PerlIO layer for output streams
D 24 i + o

- reading from and writing to files 
open my( $read_fh ), '<:encoding(UTF-8)', $filename;
open my( $write_fh ), '>:encoding(UTF-8)', $file_name;
open my( $append_fh ), '>>:encoding(UTF-8)', $file_name;

    + read the raw stream and get the encoding  perhaps with Encode::Guess. There are many gotchas there, though, and we won’t go into them here.

- dealing with command-line arguments 
use I18N::Langinfo qw(langinfo CODESET);
use Encode qw(decode);
my $codeset = langinfo(CODESET);
foreach my $arg ( @ARGV ) {
    push @new_ARGV, decode $codeset, $_;
}

- dealing with database Check its various drivers (e.g., DBD::mysql) to see which driver-specific settings you’ll need.

- unicode reference, http://www.unicode.org,




