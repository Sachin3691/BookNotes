Vim book op;Note=Erxin

# basic editing 
- before start 
    + unix 
    $ touch ~/.vimrc 
    tell vim that you want to use it in vim mode 
    
    + window will automatic create the _vimrc file 
    
- running vim for the first time 
$ givm file-path 

- the vim command 
    + gvim cause the editor to create a new window for editing 
    
- modes, vim is a modal editor, editor behaves differently depending on which mode you are in 

example, insert model then the editor will display --INSERT-- 

press esc to exist the current mode

- moving around 
h(left)
j(down)
k(up)
l(right)

moving the cursor is assign to the row under right hand 

- deleting characters, with x. this is a throwback old days of the typewriter when you deleted things by typing xxx over them 

- undo and redo 
type u to undo 
type ctrl-r to reverse the preceding command 
type U to undo line, which will undoes all the changes made on the last line 

- vi compatibility will disable most of the vim features 

- getting out
use the zz command to write the file and exit 
- discarding changes 
with :q! 

override command modifier (!) 
the colon(:) which tell the editor enter the command mode 

- other editing commands 

    + insert character at the end of a line 
    with a command 
    
    + deleteting a line, dd
    
    + opening up new lines, o 
    
    + help, :help [subject|command|index|shortcut]
    
    shortcut naming convension 
    mode_CTRL-KEY
    i_CTRL-H
    
    vim editor has a number of options that enable you to cnofigure and customize the editor. if you want help for an option you need to enclose it in single quotation marks 
    :help 'number'
    
    + help prefix
    what                                            prefix        exmaple 
    normal mode commands            nothing     :help x 
    control character                 CTRL-         :help CTRL-u
    visual mode commands            v                 :help v_u 
    insert mode commands            i 
    ex mode commands                    : 
    command line editing            c 
    vim command arguments         -
    options                                     '(both ends)        :help 'textwidth'
    
    angle brackets are used to present special keys, for example arrow key 
    :help <Up>
    
    appendix b the <> key names 
    
    + other way to get help by <F1>
    
- using a count to edit faster, repeat work #key, 9k to type kkkkkkkkk, use #command-name to tell a command to repeat times 

- vim tutorial 
$ vimtutor 


# Editing a little faster 
- word movement 
forward one word, w 
move back one word, b 

- moving to the start or end of a line, $ command move the cursor to the end of a line or <End>

use number prefix to move cursor move to next following lines, #$, 3$ next three line 

the command ^ to move first nonblank character of the line equal to <Home>

- searching along a single line, the command fx searches the line or the single chracter x 

use tx command works like the fx command t means (til) 

- moving to a specific line with g command, 3g will puts you on line 3 
- telling where you are in a file, turn on line number 
:set number 

turn off line nubmer 
:set nonumber 

- where am i, CTRL-G, displays a status line indicates where you are int he file 
- scrolling up and down CTRL-U, CTRL-D 
- deleting text, dw to delete a word, 3w commadn for example moves the cursor over three words d3w deeltes three words 

delete to the end of the line with d$ 
- where to put the count, 3dw will deletes one word three times, the command d3w deletes three words once.    

3d2w will deletes two words repeated three times, for total of six words 

- changing text, c command acts just like the d command except it leaves you in insert mode, cw changes a word 

- the . command is one of the most simple yet powerful commands, it repeats the last delete or change command. it means repeat last change 

- joining lines, J, 3J to join three lines, a space will be automatic added between each joined lines 
- replacing characters, rx command 

the r command treat <enter> in a special way, no matter how big the count is only one <enter> is inserted 

- changing case, ~ command 
- keyboard macros 
qcharacter command records keystrokes intot he register named character ( must between a and z) 
finish recording with a q command 

recall the macro by @macro-name 

    + example change file name list to #include "stdio.h"
    qa 
    ^
    i#include "<esc>
    $
    a"<esc>
    j
    q 
    
    to record a macro a 
    
    call the macro by @a 
    
- digraphs, some characters are not on the keyboard, find out what digraphs are using 
:digraphs 
it will display the keystroke to type the character by typing CTRL-KEYS


# Searching 
- simple forward seaches 
 /string command to search 
 
 the characters .*[]^%/\?~$ have special meanings, to search each of them need to put a \ infront of them 
 
find next by /<enter>

- search history 
/
use <up>, <down> to navigate between search histories 

- search options 
    + higlighting 
    :set hlsearch 
    
    :set nohlsearch 
    
    clear current highlighting use the following command 
    $ nohlsearch 
    
- incremental searches 
:set incsearch

the editor start searching as soon as you type the first character of the string 

:set noincsearch 

- searching backward 
?string the command n repeats the last search. n command will repeat the search 

- chaing direction, the N command repeat the search and reverse the search direction 
- basic regular expression, vim search use regular expression to search the content 


# Text blocks and multiple files 
- cut, paste and copy, when delete the character with d,x the text is saved you can past it back by using the p command 

    + character twiddling
    
    + more on putting, the p comamnd multiple times, it places the text after the cursor 
    
    + marks, vim enable you place marks in text, 26 marks(a to z)
    use m command to add mark, example ma to add mark a 
    
    go to mark with `mark will move cursor to the line and column 
    go to mark with 'mark will move cursor to the mark line 
    
    we could also delete to a mark by d'mark 
    
    + list all the marks 
    :marks [args]
    
    the list also include special marks such as ', ", [ and ]
    ', the last palce the cursor was 
    ", to fo the file when last closed it 
    [, the sart of the last insert 
    ], then end of last insert

    the args is the mark character 
    
- yanking, the y command with syntax ymotion, ti works just like d but save the text into buffer 

yy command will save the current line into the buffer 

y command with mark with yank the whole line 

first go to the aim line and use y command and then use p command to past the links 

- filtering !motion command takes a block of text and filters it through another program it runs the system command represents by command giving it the block of text represented by motion as input 

$ sort <input.txt> output.txt 

sort lines 1 through 10 of a file by putting the cursor on line1 and execute !10G 

the ! tell vim that you are performing a filter operation 10G tell vim go to line 10 

the cursor drops the bottom of the screen and a ! prompt displays 
!10Gsort<enter>

the !! command runs the current line through a filter, it is a good way to output system commands into a file 

another trick is to time stamp a change to get the current date time 
!!date 

- editing another file 
:vi file-name 
this will automatic close the current file and opens the new one 

if the current file is unsaved then use :write 

force discard current changes by :vi! file-name 

- the :view command, works just like the :vi command except the new file is opened in read-only mode 

- dealing with multiple files 
$ gvim file0 file1 ...

by default vim display the first file 

move to next file by 
:next 

save the current file by 
:write 

to achieve the workflow in one command 
:wnext 

ignore changes by 
:next! 

set the autowrite option on to let vim automatic save the changes when move to the next file 
:set autowrite 

:set noautowrite 

direct goto the third file by 
:2next 

- which file am i on 
:args 

list of the files currently being edited 

- going back a file 
:previous 
or 
:Next 

:wprevious 
:wNext 

- edtiing the first or last file 
:rewind 
:last 

- editing two files use CTRL-^ to switch between the two opened files 


# Windows 
- open a new window 
:split

CTRL-Ww to move the cursor to the top window or use CTRL-W CTRL-W 

go to the down a window by CTRL-Wj, CTRL-Wk to go up

clsoe a window 
:q or CTRL-W CTROL-C 

- opening another window with another file 
:split file 

the :split command also execute an initial command using the +command convention 
:split +/printf three.c 

- controlling window size 
- opens a new window three lines high and starts editing the file alhpa.c 
:3 splite alpha.c 
or 
:3splite alpha.c 

- the :new command start a new file in a new window 
- splite and view 
:sview acts like a combination of :splite and :view 

- changing window size 
use mouse or #CTRL-W+ increases the window size by count, #CTRL-W- decrease the window's size by count, #CTRL-W= to makes all the windows the same size 

the count is the line number 

- buffers, vim use term buffer to describe a file being edited 
use :hidden command to hide the current editing buffer and all the settings, marks and other suff are saved 

    + buffer states 
    active, appears on screen 
    hidden, a file is being edited 
    inactive, the file is not being edited but keep the information 
    
    when you edit another file the content of the current file is no longer needed so vim discards it. but informatino about marks in the fiel and some other things are still useful and are rememebered along with name of the file. also a file that was in cluded in the commadn with which you started vim but not edited will also be an inactive state 
    
    + list buffers 
    :buffers 
    
    the first column is the buffer number, second is a series of flags indicating the state of the buffer, the third is the name of the file associated with the buffer 
    inactive buffer, - 
    buffer is hidden, h 
    current buffer, % 
    alternate buffer, #
    file has been modified, + 
    
    + select a buffer 
    :buffer # 
    
    :buffer file-name 
    
    splite window and show the buffer 
    :sbuffer #|file-name 
    
    + other related commands include the following 
    :bnext, go to the next buffer 
    :# bnext, go to the next buffer count times 
    :# sbnext, short hand for :split followed by :count bnext 
    :# sbprevious, shorthand for :split and :count bprevious 
    :# bNext, Alias for :bprevious 
    :count sbNext, Alias for :sbprevious 
    :blast, go tot he last buffer in the list 
    :sblast, shorthand for :split and :blast 
    :brewind, go tot the first buffer in the list 
    :sbrewind, shorthand for :split and :rewind 
    :bmodified #, go to count modified buffer on the list 
    :sbmodified #, shorthand for :split and :bmodified 
    
    + buffer options, when the last window of a file is closed the buffer associated with the file become inactive. If the option hidden is set. files that leave the screen do not become inactive
    :set hidden 
    
    normally split/buffer related commands split the current window. if the "switch-buf" is set to "useopen" and there is a window displaying the buffer you want to display already on the screen. the vim will just make that window the current one 
    :set switchbuf=useopen
    other options are "(input nothing)", "split", "useopen" and "split,useopen"
    
    
# Basic visual mode 
- visual mode allow highlight a block of text and then execute a command on it
- enter visual mode 
use v command, highlight only full lines in this mode 

get help on the commands that operate in visual mode use v_command 

use CTRL-V to highlight a rectangle on the screen, you can highlight a column and delete it using the d command 

- leaving visual mode 
use <esc> or CTRL-C, use CTRL-\CTRL-N command to go to normal mode without the beep sound when double click the <esc> in normal model. 

- editing with visual mode 
the d command delete the highlight text 
the D command deletes the highlight lines 

- yanking text, the y commands places the highlighted text into a register, Y command place the lines into a register 

- switching modes, suppose you are in character mode(started by v) and you realize you want to t be in block mode, you can switch to block mode by just pressing CTRL-V 

- changing text, the c command deletes the highlighted text and starts insert mode, the C command for line 

- joining lines, use J command, it will add addtional space for each line. use gJ command to join line without adding spaces 

- commands for programmers, the > command indents the selected lines by one "shift width", < command. 
The command = indents the text. the CTRL-] command will jump to definition of the function highlighted 

- keyword lookup, K command is designed to look up the selected text usign the "man" comman. it works just liek normal-mode K comamdn except that it uses the highlighted text as the keyword

- visual block mode, CTRL-V. it is used to define a rectangle on the screen 

    + the command Istring <esc> inserts the text on each line starting at the left side of the visual block 

    if the string contain a newline the I acts like a normal mode insert i command, which will only change the first line 
    
    + changing text, the visual block c command deletes the block and then throws you into insert mode to enable you to type in a string. the string will inserted on each line in the block 
    
    the C command deletes text from the left edge of the block to the end of line 
    
    the short lines which not included in the block will be excluded 
    
    + append text with A command it will effect the short line 

    + replacing, r command will applies all the selected characters with a single character 
    
    + shifting >, < will remove one shift whitespace, if not enough whitespaces then it removes what it can 
    
    + visual block help 
    :help v_b_r 
    
    
# Commands for programmers 
- syntax coloring 
:syntax on 

- syntax coloring problems
find out background value option use 
:set background?

set bakcground with 
:set background=light 

for non-standard file extension 
:set filetype=c 

make setting automatically by 
:help new-filetype 

running the color test 
:edit $VIMRUNTIME/sytnax/colortest.vim 
:source % 

- shift command 
>>, << shift current line one shift width to the left 

:set shfitwidth=4 

- automatic indentation
cindent, works for c-style program such as c, c++, java 
smartindent, vim indents each line the same amount as the preceding one , adding an extra level of indentation if the line contains a left curly brace.
autoindent, new lines are indented the same as the previous line 

:set cindent

automatic swtich on cindent option by add exe liens in your .vimrc(unix) or _vimrc(windows) 
:filetype on 
:autocmd FileType c, cpp :set cindent

:set smartindent 

:set autoindent 

- the = command, the =motion command idents the sleected text using vim's internal formatting program
 
example =% means go to matching {} to indent a block of code 

- locating items in a program 
[CTRL-I], search for a word under the cursor in the current file and any brought in by #include directives 
gd, gD, search for definition of a variable 
]CTRL-D, [CTRL-D, jump to a macro definition 
]d, [d, ]D, ]D, display macro definitions 

- instant word searches including #include files 
[CTRL-I command jumps to the word under the cursor, search

- jumping to a variable definition(gd, gD)
the gd command searches for the local declaration of the variable under the cursor. this search is not perfrect because vim has a limited understanding of c and c++

- jump to marcro definition, [CTRL-D, ]CTRL-D 
- displaying marcro definition, [d, ]d, [D, ]D 
[d, displays the first definition of the macro 
]d starts looking from the current cursor position 
]D, [D display all the definitions 

- matching paires, the % command is designed to match paires of (), {} or [], % will also automatic match c comments, #if #else etc 

- shifting a block of text enclosed in {} 
>% this shifts the text right to where the motion takes you, % takes you to the matching {} 

shift the text in the {}, then you need to do 
    + position the cursor on the first {
    + execute the command >i{
    this hift right command > shifts the selected text to the right one shift width. in this case the selection command that follows is i{ which is inner {} block command 
    
- indenting a block using visual mode 
    + position the cursor on the left or right curly brace 
    + start visual mode with the v command 
    + select the inner {} block with the command i} 
    + indent the text with > 
    
- finding man page 
the K command runs a Unix man command using the word under the cursor as a subject, on window the K command performing a :help on the owrd under the cursor 

    + the format of man command 
    $ man [section] subject 
    
the K command consider a word is defiend by the isKeyword option 

- tags
the location of function definitions is stored in a table of contents file generated by the program ctags which come from vim 
$ ctags *.c 
to generate named tags 

in vim to go to a function definition by
:tag function  command 

the CTRL-] jump to the tag of the word that is under the cursor 

the command tags to shows the list of tags that you hvae traversed 
:tags 

go back with command CTRL-T command 

prefix a count 
:#tag 

- help and tags 
    + execute a hyperlink jump, press CTRL-], jump to tag 
    
- windows and tags 
    + split window and view a tag 
    :split tag 
    
- finding a procedure when you only know part of the name such as find window api or unix api 
:tag command to find a procedure by name or search for a regular expression 

:tag /regex 

to get a list of the return tags with 
:tselect {name} 
the result will contain several columns 
the first is the number of tag 
second is the priority column combines three letters
    + F, full match 
    + S, static tag, if missing, a global tag 
    + C, tag in the current file 
    
select only one item by 
:tjump , the gCTRL-] command does a :tjump on the word under the cursor 
:#tnext 
:#tprevious 
:#tNext 
:#trewind 
:#tlast 

- shorthand command 
:stselect does the same thing as :tselect except that it splits the window first, :stjump same as :split and a :tjump 

- the care and feeding of makefiles 
    + use list mode to display tab and space
    tab will show as ^I
    end of line will add $ 
    
    :set list 

    + use the expandtab option to let vim inserts spaces instead of tab character 
    :set expandtab 
    
    insert a real tab no matter the option are by CTRL-V<tab> in insert mode, the CTRL-V tell the vim don't change the following character 
    
- sort a list of files
    + go the start position add mark ma 
    + go to the bottom of a list 
    + run block through the external program sort using the command !'a sort 
    
- sorting a list in visual mode 
    + move to the top 
    + start line visual mode with v 
    + move to bottom of the text 
    + execute the command !sort. the ! tell vim to pipe the selected text through a command 
    
- making a program, vim editor has a set of commands it calls the quick-fix mode. these commands enable you to compile a program from within vim and then go through the errors generated fixing them 
:make 

:make arguments 

after call the make program, editor will automatic move cursor to error line 

go to next error 
:cnext 

    + for visual c++ micrsoft supplied nmake, you might need to customize vim using the makeprg option 
    
:cprevious or :cNext to go previous errors 
:clast, :cnfile goes to the first error message for the next file 

check current error 
:cc 

check list of error 
:clist 

check a range of list error 
:clist start,end 

vim will suppress all infromation message to tell vim show everything by 
:clist! 
the ! override option tell vim to not suppress anything 

if you have already run make and generated your own error file you can tell vim about it by using the :cfile error-file 

exit vim with error code 1
:cquit 

- the errorfile option, define the default filename used for the :clist command as well as the -q command line option 
:set errorfile=error.list 

- searching for a given string 
:grep -w ground_point *.c 

use :cnext, :cprevious and :cc command to page through the list of matches, :crewind goes to the first error and :clast to the last. finally following command goes to the first error in the next file. :cnfile 

- other interesting commands 
vim editor can use different options for different types of files through the use of the :autocommand 

customize your options on a per-file basis by putting something called a modeline in each file 


# Basic abbreviations keyboard mapping and initialization files 
- abbreviations is a short word that takes the place of a long one. define abbreviation 
:abbreviate ad advertisement 

- list your aabreviations 
:abbreviate 

- mapping, bind a set of vim commands to a single key, the normal text should be surround in {}
:map key commands 

exampele 
:map <F5>i{<Esc>ea}<Esc

- list mappings 
:map 

- fixing the way delete works, switch backspace and delete function 
:fixdel 

this modify the internal vim definitions for backspace(t_kb) and delete (t_kD)
 
- controlling what the backspace key does 
:set backspace=indent 
tells vim to allow backspacing over autoindents 

:set backspace=eol 
allow backspace over end of line 

:set backspace=start 
allow backspace over start of line 

:set backspace=indent,eol,start 

- saving your setting 
:mkvimrc 
writes all your settings to a file 
:mkvimrc file 

read the setting by 
:source file 

    + uring startup vim looks for an initialization file 
        * unix 
        $home/.vimrc 
        $home/_vimrc 
        $home/.exrc 
        $home/_exrc 
        
        * on window also search the vim install location 

- locating the initialization files with :version 
the command :mkexrc commands writes the mappings to the .exrc file 

- my .vimrc file 
:syntax on
:autocmd FileType * set formatoptions=tcql
\ nocindent comments&
:autocmd FileType c,cpp set formatoptions=croql
\ cindent comments=sr:/*,mb:*,ex:*/,://
:set autoindent
:set autowrite
:ab #d #define
:ab #i #include
:ab #b /****************************************
:ab #e <Space>****************************************/
:ab #l /*-------------------------------------------- */
:ab #j Jack Benny Show
:set shiftwidth=4
:set hlsearch
:set incsearch
:set textwidth=70

the file start with a command to turn syntax coloring on 
:syntax on 

use fancy searching 
:set hlsearch 
:incsearch 


# Basic command-mode commands 
- vim is based on vi the vi is based on ex. 
- in ex each command that begins with a colon is consider an ex-style command 
- entering command line mode use colon (:)

    + switch to command mode with ex command 
    :ex 
    
    + return to normal by :visual 
    
- print command 
    + a simple range can be print like 
    : 1,5 print 
    
    the last line number use $ 
    entire file by % 
    current line, . 
    specify line pattern 
    :#, /pattern/ print 
    the first # is the start line position 
    
    the pattern ?pattern? specifies the first previous line with pattern in it 
    
- marks 
m[a-z]

use mark '[a-z]

print also support use mark to set the start end postion 
'a,'z print 

- visual mode range specification
    + enter visual mode 
    + select the lines you want 
    + enter the command mode such as print then vim will automatic generate the selection range for the command 
    
- substitute command to preform string replacements 
:range substitute /from/to/flags 

example 
:% substitute /Professor/Teacher/
replace all occurrences of professor to teacher with following command 

by default substitute command only change the first occurrent word for each lines 

change every occurrence on the line, add g flag 
:% substitute /Professor/Teacher/g 

    + Other flags 
    p, print cause command print out each line 
    c, confirm tells to confirm 
    
- how to change last, first to first, last 
substitute command support regex replace 

- reading and writing files 
:read filename 

short form :r and insert into current line 

:write filename 
if you exit using the emergency abort command :q! the file reverts to the last written version 

:write command will not overwrite file by default, use ! option to overwrite existing files 

- the :shell command takes you to command prompt, use exit to return to vim 


# Basic GUI usage 
- the vim editor works well inside a windowing environment 
- start vim in gui mode 
$ gvim file 

- mouse usage 
    + make mose behave like xterm 
    :behave xterm 
    
    + make mouse behave like window 
    :behave window 
    
- tear-off menus, select and drag the first dot line of menu could drag drop the menu to other place 


# Dealing with text files 
- automatic text wrapping 
    + during programming line break will not be automatic added 
    + use textwidth option to let vim automatic inserts line break 
    :set textwidth=30 
    this is useful when creating document 
    
    :set wrapmargin=10 
    textwidth option overrules wrapmargin
    
    to keep text shape when deleting first line of text select the text and execute gq command to format the paragraph 
    
    another way to format a paragraph is to use the gqmotion command. 
    gq4j 
    tell gq to format this line and the next 4-5 lines total 
    
    the move forward paragraph command } 
    
    format current paragraph gqip, ip command  selects the inner paragrahp 

- text formatting command 
:range center width 

:1,5 center 30 

:range left margin 

- justifying text, vim editor has no built-in way to justify text. there is a neat macro package that does the job 

:source $VIMRUNTIME/marcros/justify.vim 

this macro file defines a new visual command _j to justify a block of text, highlight the text in visual mode and then execute _j 

- fine-tuning the formatting 

    + joinspaces option 
    the J command joins two lines putting in one space to separate them 
    
    :set joinspaces
    
    + formatoptions, controls how vim performs automatic wrapping 
    :set formatoptions=characters 
    
    t automatically wrap text 
    c automaticall wrap comments 
    r insert comment leader 
    o insert comment leader in a comment 
    q allow gq to format comments 
    2 format based on the indent of the second line 
    v do old style vi text wrapping 
    b wrap only on blanks you type 
    l do not break line insert mode 
    
- using an external formatting program 
    + on unix use fmt, it will instead the built-in gq command 
    :set formatprg=fmt 
    
    to run a paragraph through the program fmt 

- file formats 
    + back in the early days the old teletype machines took two character times to do a newline. if you sent a character to the machine while it was moving the carriage back to the first position, it tried to print it on-the-fly, leaving a smudge in the middle of the page 
    
    The solution was to make the newline tow characters, <return> to move the carriage to column 1 and <line feed> to move the pager up 
    
    when computer came out 
    unix choose use <line feed>, mac choose <return> and ms-dos folks decides to keep th old <return> and <line feed>
    
    + change vim default formats 
    :set fileformats=unix,dos 
    
    check current fileformat 
    :set fileformat?
    
    + convert a fileformat from one system to another 
        * open the file 
        $ vim file-name 
        
        * change the fileformat by set 
        :set fileformat=os-name
        
    + in old vi editor, the <return> character will be displayed as ^M 
    
- changing how the last line ends, vim assume line in the file ends in a <EOL> character. sometimes you will encounter a strange file that contains a incomplete line 

vim assume that the last line in the file ends in a <EOL> character. 

if a file contain incomplete line. when vim encounter this kinds of file. it sets the noendofline option else it will set endofline option 

    + change a file ends in a <EOL> 
    :set endofline 
    
    :set noendofline  
 
- troff related movement
the ) command moves forwards one sentence. the ( move back one sentance 

troff program was the standard unix word processor 

- encrypting with rot13. if you want to encrypt a block of text with the rot13 algorithm, use the g?motion command 

rot13 encryption is an extremely weak encryption scheme designed to obscure text 


# Automatic completion 
- type first part of the word and press ctrl+p, if you type ctrl-p again, vim will search again for a next word that matches the header text

- how vim searchs for words, for example for *.c 

    + current file 
    + files in other windows 
    + other file in the currently loaded buffers 
    + files in the unloaded buffers 
    + the current "tags" list 
    + all files #included by the current file 
    
- customization of completion
    + set ignore case 
    :set ignorecase 
    
    + tell vim insert the match words with the case of the typped
    :set infercase 
    
- automatic completion details 

    + the complete option controls where vim searches for words. the form of this options is as 
    :set complete=key,key,key
    
    the key is a letter. the possible key values are as follows 
    current file, . 
    files in loaded buffer, not in a window, b 
    definitions in the current file and in files included by a #include directive, d 
    files included by the current file through the use of a #include directive, i 
    the file defined by the 'dictionary' option, k 
    the file named {file}, kfile 
    the "tags" file, t 
    unloaded buffers, u 
    files in other windows, w 
    
- include path, vim uses the 'path' option to tell it where to look for files that were included in the current file 

'path' option also sued for other commands, such as :find 

- specify a dictionary 
:set dictionary=file,file,...

also could put the dictionary file after the k keyword in complete option 
:set complete=k<file-path>

- controlling what is search for , ctrl-p and ctrl-n enable you to performa a wide variety of searches 
ctrl-d, macro definitions 
ctrl-f, filenames 
ctrl-k, dictionary 
ctrl-i, current file and #includes file 
ctrl-L, whole lines 
ctrl-l, tags 
ctrl-p, same sas ctrl-P without the ctrl-x(find previous match)
ctrl-n, same as ctrl-N without the ctrl-x(find previous match)

- tag search, a tag is a c function definition. the program ctags generates a list of c function definitoin, and stores them in the tags file 
$ ctags *.c *.h 

now we enter ctrl-x, ctrl-l in insert mode we get 

by default vim will displays the name along. execute the command to show full tag
:set showfulltag 

- finding filenames, ctrl-x, ctrl-f to match a filename, it scans current directory for iles and display each one that matches 

- line mode, ctrl-x, ctrl-l command works on lines. 

use ctrl-n and ctrl-p to go up and down lines 

- adjusting the screen, there are two more ctrl-x commands which suprisingly don't do completion. 

after typing ctrl-x, you can move the screen up and down a little. 
ctrl-y command scrolls down, 
ctrl-e scroll up 


# Autocommands 
- autocommand is a command executed automatically in response to some event 
    + train vim to edit compress files, define an autocommand that uncompress the file on read and another one to compress file on write 
    
- basic autocommand 

put a date stamp on the end of a file every time it is written 

:funciton DateInsert()
:   $read !date         "insert the date at the end 
:                       "of file 
:endfunction

call the defined function 
:call DateInsert() 

map the call to a key by 
:map <F12> :call DateInsert()<CR> \| :write <CR>

this is still can't make sure the time stamp is added when file is saved 

use autocommand
:autocmd FileWritePre *:call DateInsert()<CR>
this command cause :callDateInsert() to be executed for all files(*). just before writing the file. 

    + autocmd syntax 
    :autocmd [group] events file_pattern nested command 
    
    file_pattern is a file name which support wildcards 
    nested flag allows for nesting of autocommand 
    command is the command to be executed 
    
- groups, :augroup commands starts the definition of a group of autocommands. The group name is jsut a convenient way to refer to the set of autocommands

:augroup cprograms 
:   autocmd FileReadPost *.c :set cindent 
:   autocmd FileReadPost *.cpp :set cindent 
:autogroup END 

to add a single command into this gropu by add the group name into the autocmd 
:autocmd cprograms FileReadPost *.h :set cindent 

tell vim to go through

    + :doautocmd syntax 
    :doautocmd group event file_name 
    
    + supported events 
    BufNewFile, triggered when editing a file that does not exist 
    BufReadPre/BufReadPost 
    BufFilePre/BufFilePost, changing name of a buffer 
    FileReadPre/FileReadPost
    FilterReadPre/FilterReadPost, reading a file with a filter 
    FileType, when file type is set 
    Syntax, when syntax option is set 
    StdinReadPre/StdReadPost, reading from the standard input 
    BufWritePre/BufWritePost, before after writint the entire buffer 
    BufWrite 
    FileWritePre/FileWritePost 
    FileAppendPre/FileAppendAfter 
    FilterWritePre/FilterWriteAfter
    FileChangedShell, when vim runs a shell command and then notices that the modification time of the file has changed 
    
    FocusGained/FocusLost
    CursorHold, occurs after the user pauses typing 
    BufEnter/BufLeave
    BufUnlaod
    BufCreate/BufDelete 
    WinEnter/WinLeave 
    GuiEnter 
    VimEnter, vim editor just started and the initilization files have been read 
    VimLeavePre
    VimLeave, vim editor is exiting 
    FileEncoding 
    TermChanged, the term option is changed 
    User, not a real event, but used as a fake event for use with :doautocmd
    
    + when writing a file, vim triggers only one paire of the following events 
    BufWritePre/BufWritePost 
    FilterWritePre/FilterWritePost 
    FileAppendPre/FileAppendPost 
    FileWritePre, FileWritePost 
    
    + when reading a file, one of the following set of events will be triggered 
    BufNewFile 
    BufReadPre/BufReadPost 
    FilterReadPre/FilterReadPost 
    FileReadPre/FileReadPost 
    
- file patterns, the filename pattern matching uses the UNIX standard system. 
- nesting, generally commands executed as the result of an autocommand will not trigger any new events. to follow trigger new event by add nested keyword 
:autocmd FileChangedShell *.c nested e! 

- listing all the autocmd 
:autocmd 

- removing commands , the commadn :autocmd! removes autocommands, remove all autocommand by 
:autocmd! 

remove for a specific group 
:autocmd! group-name event pattern 

also support group pattern, use * to match all events 

- ignoring events, 
:set eventignore=WinEnter,WinLeave 

to ignore all events, use the following command 
:set eventignore=all 


# File recovery and command line arguments 
- command line argument, mose usefule is --help 
$vim --help 

vim -vi improved 

- find out vim version 
$ vim --version 

- edit in read only mode 
$ vim -R file-name 

by default vim will open the file as read only in most of the system 

- encryption, -x argumetn tell vim to encrypt the file. 
$ vim -x secret.txt 
    
- switching between encrypted and unencrypted modes 
:set key=<encryption key> 

if the encryption key is empty then it means turn off encryption 

use :X command to create the key prevent anyone shoulder can read your password 

- limits on encryption, the encryption algorithm used by VIM is weak. the swap file is not encrypted. so during your editing, people with superuser priviledges can read the unencrypted text from this file 

with -n argument to prevent use swap file, vim puts everything in memory. with -n then file recovery is impossible 

- executing vim in a script or batch file, vim editor does a superb job as a screen-oriented editor when started in normal mode. the ex mode make things easy to to put into a batch file 

:%s/search-string/replace-string/g 
:write 
:quit 

you put these commands in the file change.vim. now to run the editor in batch mode by 
$ vim -es aim-text-file <change.vim 

this runs the vim editor in ex mode (-e flag). the -s flag tells vim to operate in silent mode 
- additional command-line arguments 
open for read only, -R 
modifications are not allowed, -m 
restricted mode, -Z 

the other arguments enable you to choose which initialization files you read, -u file use file rather than .vimrc for initialization. -U file use file rather than .gvimrc for initialization. -i file use file rather than the .viminfo file 

- in unix, vim editor have several different names link to different modes 
vim, console mode 
gvim, gui mode 
ex, ex mode 
view, in normal view mode 
gview, gui read only 
rvim, console restricted 
rview, read only restricted 
rgvim, gui mode restricted 
rgview, gui mode read only restricted 
vi, linux only alias for vim 

    + command line arguments to set initial mode 
    gui mode, -g 
    visual mode, -v 
    ex mode, -e 
    terminal type, -t 
    
- compatibility arguments 
non compatible mode, -N 
compatible, -C 
lisp mode, -l 
    
    + classified any other way 
    amiga only, -d device 
    binary mode, -b 
    
- foreign language 
farsi, -F 
hebrew, -H 

- backup files 
:set backup 

the backup file is the original file with a "~" added to the end. change extension by 
:set backupext=string 

    + change backup file location 
    :set backupdir=~/tmp/ 
    
    + use 'pathmode' option then backup file will add to the same name but with pathmode string appended to it 
    :set pathmode=string 
    
- controlling how the file is written 
- basic file recovery
$ gvim sample.txt 

eidtor will create a swap file, any unnormal exit the swap file will be remain 
- recovering from the command line 
$ vim -r commands.c 

    + get a list of recoverable editor sessions with 
    $ vim -r 
    
- advanced swap file management 
the first name of a swap file is .file.txt.swp 
the next swap file is called .file.txt.swo, ..., .file.text.swn and so on 

recover from a specific swap 
$ vim -r file.txt.sw?

find out the current swap file 
:swapname 

- control when the swap file is written 
:set updatetime=23000
23 seconds 

:set updatecount=40 
change the number of characters you have to two before vim writes stuff to swap file 

:set swapfile 
enable swapfile 

:set noswapfile 

:set swapsync 
force write to disk without to memory buffer on linux or unix 

- control where the swap file is written 
:set directory=/tmp 

- saving your wrok 
:write 

:preserve 
writes all the edits to the swap file, the orginal file remain unchanged 

- recover file 
:recover file-name 

equal to 

$ vim -r file.txt 

discard any changes to a file 
:recover! file-name 

- ms-dos filenames 
:set shortname 

- readonly and modified options, modified flag is set if the buffer has been modified 


# Miscellaneous commands 
- printing the character 
:ascii or ga command prints the number of the character under the cursor 

- going to a specific character inthe file 
with go command 
:goto offset 

gg command acts much like the G command. it goes to the line specified by its count 

- redraw 
ctrl-l 

- sleep, does nothing for specified number of seconds 
:sleep time 

- terminal control, ctrl-s command stop output, to restart by ctrl-q, should not use these in :map command due to conflict 

- suspending the editor, ctrl-z, use shell command fg to continue on unix, equal to :suspend command 

- general help 
:help 

- window size 
z height <cr> command resizes the current window to height

- viewing the introduction screen 
:intro 

- open mode, not support in vim compare to vi 


# Cookbook 
- character twiddling, during fast typing people may type 'teh' instead of 'the', to swap the two character by put cursor on e and type xp 
x, delete a character 
p, paste it after the cursor 

- replacing one word with another using one command 
:1,$s/idiots/managers/g 

the colon indicates that you are going to execute an ex type command 
all ex commands begin with range of numbers on which the command operates. 
:s abbreviation for substitute 
s/search/replace/flag 

- interactively replacing one word with another 
1g to go to the top of document 
execute find the with /search-pattern 
issue the command cwmanager<esc> 
change the word to maanger 
use the n command to repeat the last search 
execute the . command to repeat the last edit 

- alternate methods 
- copying a block of text from one file to another with traditional vi-style commands
ctrl-w p to go to the previous window 
ma to mark a position 
ya to yank(copy the text) to mark 
use ctrl-w p to go to the file that will receive the text 
issue the p command to put the text above the current line 

- two window suing visual mode 
:split 
ctrl-w p 
issue v command to start visual mode 
go to the end of the text to copy which will be highlighted 
execute y command to copy to default register 
ctrl-w p to go the file 
use p command 

- two different vim programs 
    + edit the first file 
    + start another vim program to edit the second file 
    + go to the window with the first file in it 
    + go tto the start of the text to be copied 
    + issue the v command to start visual mode 
    + go to the end of the text to be copied, the seelcted text will be highlighted 
    + use "*y command to yank into clickboard register "*
    + change to the other editing command 
    + go to the line 
    + issue the command "*p to put the text in the system clipboard register "*
    
- sorting a section 
    + mark the start 
    + move to bottom 
    + execute the command !'asort command the ! commands tells vim to run the text through a unix command 
    ! execute a command 
    'a tells the editor that the text to be worked on stats at the current line and ends at mark a 
    
- finding a procedure in a c program 
    + generate a table of contens of all the c program by 
    $ ctags *.c 
    
    $ ctags *.cpp 
    
    $ gvim -t procedure-name 
    during editing, if you want to jump to another procedure then use ctrl+], vim will jump to the definition of this procedure 
    
- drawing comment boxes 
    + vim abbreviations command use to define a set of abbreviations 
    :ab #b /****************************************
    :ab #e  ****************************************/

    + use abbreviation
    #b<enter> 
    
- reading a unix man page 
$ man date|ul -i|vim 

another way is 
:%s/.\b//g 
this will remove all characters followed by the backspace(\b), rendering the file readable 

- trimming the blanks off an end of line 


# topics not covered 
- interfaces to other applications 
    + cscope command is designed to examine a set of C or C++ programs and produce a database containing information about the location of funtions and variables in the programs 
    
    :help cscope 
    
    + cscope related command reference 
    :cs arguments 
    :cscope argument, handle various activities associated with the cscope program 
    :cstag procedure, go tot hte tag in the cscope database named procedure 
    :set csprg=program 
    :set nocscopetag, if se this option causes the command that do tag navigation 
    :set cst 
    :set csto=flag 
    
- OLE, is a method by which programs running under microsoft windows 
$ help ole-interface 

- perl 
: help perl 

- perl interface command reference 
:pe command 
:perl commadn 
:rangeperld command 
:rangeperldo command 

- python 
:help python 

- python interface command reference 
:rangepy statement 
:rangepython statement 
:rangepyf file 
:rangepyfile file 

- sniff+, is a commercial programming environment the vim editor enables you to inteface with this program 

:help sniff 

- tcl 

- foreign language 
    + toggle between left to right and right to left modes 
    :set rl 
    :set rightleft 
    :set norl 
    :set orightleft 
    
    :set ari 
    :set allowrevins 
    
- chinese 
:set fe=encoding 
:set fileencoding=encoding 

- farsi 
$ vim --F file.txt 

:help farsi 

- binary files, edinting binary files using a text editor is tricky at best and suicidal at worst 

:set bin 
:set binary 
:set nobin 
:set nobinary 

- modeless editing, if you enable the insert mode option insert mode is the default you want to switch to normal. ctrl-o command to execute a normal mode command this option is for people who do not like modes and are willing to deal with the confusing setting it 
:set  im 
: set insertmode 
:set noim 
:set noinsertmode 

- operating system file modes 
:set osf=type 
:set osfiletype
:set st=type 
:set shelltype=type 


# The details 
## Complete basic editing 
- word movement,
w 

ge moves backward to the end of the preceding word 

- defining what a word is 
vim editor does a good job of defining a sane answer to this question 

    + define what below to a word 
    :set iskeyword=specification 
    
    list programmer consider abc-def is a single word but c programming will not 
    
    + the @ character represents all characters where the c function isalpha() return true. 
    
    to exclude a character or set of character, precede it with a circumflex(^). 
    
    :set iskeyword=@,^q 
    
- other teyps of word 
isfname, filenames 
isident, identifiers 
isprint, printing characters 

- there are "words" and then there are "WORDS". WORD means any sequence of non-whitespace characters 
- begin of line ^ 
- repeating single character search the fx command use ; command 

- moving lines up and down, + command move to the gin of the next next, the _ command moves to the first non-blank character of the line 
- cursor movement command 
H, move to the top of the screen 
1H moves to the top line 
2H the second line and so on 
M command moves to the middle of the screen 

- jumping around 
1G, go to line 1 
10G, go to line 10 
20G, go to line 20 

ctrl-o command jumps back one line 
ctrl-i or <tab> command moves you to the next jump in the list 

- controlling some commands 
- scroll up 
ctrl-u, scrolls up half a screen 

:set scroll=10 

ctrl-y command multipled by an argument 
ctrl-b scrolls up and entire screen at a time 
- scrolling down 
ctrl-d, move down 
ctrl-e, move down one line 
ctrl-f, move down one screen of data 

- define how much to scroll 
:set scrolljump=5 

- adjusting the view 
z<enter> 

- delete to the end of the line 
D command 

- the C command delete text from cursor to the end of the line thenputs the editor in insert mode 

- s command deletes a single character and put editor in insert mode 
- S delete aline 
- insert I comamnd, insert start at the begining of line 
- aritmetic, vim can perform simple arithmetic on text, ctrl-A increments the number under the cursor 

ctrl-X command decrement the number 

- joining lines with spaces, J command, gJ command to join line without spaces 
- replace mode, R command. each character you type replace the one under the cursor 
3Rmess<exc> 

- virtual replace mode , gR enters virtual replace mode. if the real character under the cursor is part of a tab, only the space representing the tab jumped over is replaced 

- digraphs, define your own digraphs by using 
:digraphs character1 character2 number 

- changing case 
:set notildeop 

:set tildeop 

~fq command changes of all the character up to and including the first q  on the line 

the g~motion command changes the case of the indicated characters 

- other case-changing comamnds, gUmotion makes the text from cursor to motion 

guu and gugu act just like gU 

- undo level 
:set undolevels=5000 

- getting out, ZQ command is an alias for :q! or :quit!
:xit command acts much like :wq only if the buffer has been modified 


# advanced searching using regular expression 
- ignorecase 
:set ignorecase

- search wrapping 
:set nowrpscan 

- interrupting searches 
ctrl-break 
ctrl-c 

- instant word searches 
* command search for the word under the cursor 

pressing * moves the cursor to the next occurrence of the word 

the # or $ comamnd does an instance word search 

- search offset 
/const/offset 

e offset indicates an offset from the end of the match 
/pattern/e-3 

- specifying offsets 
- completing regular expression 
:set hlsearch 

- beginning (\<) and end (\>) of a word 
\<for\>

only match the word for 

- complete regular expressions 
    + tell vim highlight the matched text by 
    :set hlsearch 
    
- modifiers and grouping 
- repeat modifiers 
\{minimum, maximum}

- repeating as littel as possible 
a\{-3, 5}

- grouping 
specify a group by enclosing it in a \( and \)

- the or operator (\|)
/procedure\|function 

- matic option, if set nomagic then *, ., [, and ] characters are not treated as special characters 
- offset specification 
[num]
+[num]
-[num]
e 
e[num]
b 
s, start of match 
b[num]

- regular expression reference 


# Advanced text blocks and multiple files 
- 





    













    
    
    
    
    
    
    
    
    
    
    








































    
    
    











