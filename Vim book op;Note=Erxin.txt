Vim book op;Note=Erxin

# basic editing 
- before start 
    + unix 
    $ touch ~/.vimrc 
    tell vim that you want to use it in vim mode 
    
    + window will automatic create the _vimrc file 
    
- running vim for the first time 
$ givm file-path 

- the vim command 
    + gvim cause the editor to create a new window for editing 
    
- modes, vim is a modal editor, editor behaves differently depending on which mode you are in 

example, insert model then the editor will display --INSERT-- 

press esc to exist the current mode

- moving around 
h(left)
j(down)
k(up)
l(right)

moving the cursor is assign to the row under right hand 

- deleting characters, with x. this is a throwback old days of the typewriter when you deleted things by typing xxx over them 

- undo and redo 
type u to undo 
type ctrl-r to reverse the preceding command 
type U to undo line, which will undoes all the changes made on the last line 

- vi compatibility will disable most of the vim features 

- getting out
use the zz command to write the file and exit 
- discarding changes 
with :q! 

override command modifier (!) 
the colon(:) which tell the editor enter the command mode 

- other editing commands 

    + insert character at the end of a line 
    with a command 
    
    + deleteting a line, dd
    
    + opening up new lines, o 
    
    + help, :help [subject|command|index|shortcut]
    
    shortcut naming convension 
    mode_CTRL-KEY
    i_CTRL-H
    
    vim editor has a number of options that enable you to cnofigure and customize the editor. if you want help for an option you need to enclose it in single quotation marks 
    :help 'number'
    
    + help prefix
    what                                            prefix        exmaple 
    normal mode commands            nothing     :help x 
    control character                 CTRL-         :help CTRL-u
    visual mode commands            v                 :help v_u 
    insert mode commands            i 
    ex mode commands                    : 
    command line editing            c 
    vim command arguments         -
    options                                     '(both ends)        :help 'textwidth'
    
    angle brackets are used to present special keys, for example arrow key 
    :help <Up>
    
    appendix b the <> key names 
    
    + other way to get help by <F1>
    
- using a count to edit faster, repeat work #key, 9k to type kkkkkkkkk, use #command-name to tell a command to repeat times 

- vim tutorial 
$ vimtutor 


# Editing a little faster 
- word movement 
forward one word, w 
move back one word, b 

- moving to the start or end of a line, $ command move the cursor to the end of a line or <End>

use number prefix to move cursor move to next following lines, #$, 3$ next three line 

the command ^ to move first nonblank character of the line equal to <Home>

- searching along a single line, the command fx searches the line or the single chracter x 

use tx command works like the fx command t means (til) 

- moving to a specific line with g command, 3g will puts you on line 3 
- telling where you are in a file, turn on line number 
:set number 

turn off line nubmer 
:set nonumber 

- where am i, CTRL-G, displays a status line indicates where you are int he file 
- scrolling up and down CTRL-U, CTRL-D 
- deleting text, dw to delete a word, 3w commadn for example moves the cursor over three words d3w deeltes three words 

delete to the end of the line with d$ 
- where to put the count, 3dw will deletes one word three times, the command d3w deletes three words once.    

3d2w will deletes two words repeated three times, for total of six words 

- changing text, c command acts just like the d command except it leaves you in insert mode, cw changes a word 

- the . command is one of the most simple yet powerful commands, it repeats the last delete or change command. it means repeat last change 

- joining lines, J, 3J to join three lines, a space will be automatic added between each joined lines 
- replacing characters, rx command 

the r command treat <enter> in a special way, no matter how big the count is only one <enter> is inserted 

- changing case, ~ command 
- keyboard macros 
qcharacter command records keystrokes intot he register named character ( must between a and z) 
finish recording with a q command 

recall the macro by @macro-name 

    + example change file name list to #include "stdio.h"
    qa 
    ^
    i#include "<esc>
    $
    a"<esc>
    j
    q 
    
    to record a macro a 
    
    call the macro by @a 
    
- digraphs, some characters are not on the keyboard, find out what digraphs are using 
:digraphs 
it will display the keystroke to type the character by typing CTRL-KEYS


# Searching 
- simple forward seaches 
 /string command to search 
 
 the characters .*[]^%/\?~$ have special meanings, to search each of them need to put a \ infront of them 
 
find next by /<enter>

- search history 
/
use <up>, <down> to navigate between search histories 

- search options 
    + higlighting 
    :set hlsearch 
    
    :set nohlsearch 
    
    clear current highlighting use the following command 
    $ nohlsearch 
    
- incremental searches 
:set incsearch

the editor start searching as soon as you type the first character of the string 

:set noincsearch 

- searching backward 
?string the command n repeats the last search. n command will repeat the search 

- chaing direction, the N command repeat the search and reverse the search direction 
- basic regular expression, vim search use regular expression to search the content 


# Text blocks and multiple files 
- cut, paste and copy, when delete the character with d,x the text is saved you can past it back by using the p command 

    + character twiddling
    
    + more on putting, the p comamnd multiple times, it places the text after the cursor 
    
    + marks, vim enable you place marks in text, 26 marks(a to z)
    use m command to add mark, example ma to add mark a 
    
    go to mark with `mark will move cursor to the line and column 
    go to mark with 'mark will move cursor to the mark line 
    
    we could also delete to a mark by d'mark 
    
    + list all the marks 
    :marks [args]
    
    the list also include special marks such as ', ", [ and ]
    ', the last palce the cursor was 
    ", to fo the file when last closed it 
    [, the sart of the last insert 
    ], then end of last insert

    the args is the mark character 
    
- yanking, the y command with syntax ymotion, ti works just like d but save the text into buffer 

yy command will save the current line into the buffer 

y command with mark with yank the whole line 

first go to the aim line and use y command and then use p command to past the links 

- filtering !motion command takes a block of text and filters it through another program it runs the system command represents by command giving it the block of text represented by motion as input 

$ sort <input.txt> output.txt 

sort lines 1 through 10 of a file by putting the cursor on line1 and execute !10G 

the ! tell vim that you are performing a filter operation 10G tell vim go to line 10 

the cursor drops the bottom of the screen and a ! prompt displays 
!10Gsort<enter>

the !! command runs the current line through a filter, it is a good way to output system commands into a file 

another trick is to time stamp a change to get the current date time 
!!date 

- editing another file 
:vi file-name 
this will automatic close the current file and opens the new one 

if the current file is unsaved then use :write 

force discard current changes by :vi! file-name 

- the :view command, works just like the :vi command except the new file is opened in read-only mode 

- dealing with multiple files 
$ gvim file0 file1 ...

by default vim display the first file 

move to next file by 
:next 

save the current file by 
:write 

to achieve the workflow in one command 
:wnext 

ignore changes by 
:next! 

set the autowrite option on to let vim automatic save the changes when move to the next file 
:set autowrite 

:set noautowrite 

direct goto the third file by 
:2next 

- which file am i on 
:args 

list of the files currently being edited 

- going back a file 
:previous 
or 
:Next 

:wprevious 
:wNext 

- edtiing the first or last file 
:rewind 
:last 

- editing two files use CTRL-^ to switch between the two opened files 


# Windows 
- open a new window 
:split

CTRL-Ww to move the cursor to the top window or use CTRL-W CTRL-W 

go to the down a window by CTRL-Wj, CTRL-Wk to go up

clsoe a window 
:q or CTRL-W CTROL-C 

- opening another window with another file 
:split file 

the :split command also execute an initial command using the +command convention 
:split +/printf three.c 

- controlling window size 
- opens a new window three lines high and starts editing the file alhpa.c 
:3 splite alpha.c 
or 
:3splite alpha.c 

- the :new command start a new file in a new window 
- splite and view 
:sview acts like a combination of :splite and :view 

- changing window size 
use mouse or #CTRL-W+ increases the window size by count, #CTRL-W- decrease the window's size by count, #CTRL-W= to makes all the windows the same size 

the count is the line number 

- buffers, vim use term buffer to describe a file being edited 
use :hidden command to hide the current editing buffer and all the settings, marks and other suff are saved 

    + buffer states 
    active, appears on screen 
    hidden, a file is being edited 
    inactive, the file is not being edited but keep the information 
    
    when you edit another file the content of the current file is no longer needed so vim discards it. but informatino about marks in the fiel and some other things are still useful and are rememebered along with name of the file. also a file that was in cluded in the commadn with which you started vim but not edited will also be an inactive state 
    
    + list buffers 
    :buffers 
    
    the first column is the buffer number, second is a series of flags indicating the state of the buffer, the third is the name of the file associated with the buffer 
    inactive buffer, - 
    buffer is hidden, h 
    current buffer, % 
    alternate buffer, #
    file has been modified, + 
    
    + select a buffer 
    :buffer # 
    
    :buffer file-name 
    
    splite window and show the buffer 
    :sbuffer #|file-name 
    
    + other related commands include the following 
    :bnext, go to the next buffer 
    :# bnext, go to the next buffer count times 
    :# sbnext, short hand for :split followed by :count bnext 
    :# sbprevious, shorthand for :split and :count bprevious 
    :# bNext, Alias for :bprevious 
    :count sbNext, Alias for :sbprevious 
    :blast, go tot he last buffer in the list 
    :sblast, shorthand for :split and :blast 
    :brewind, go tot the first buffer in the list 
    :sbrewind, shorthand for :split and :rewind 
    :bmodified #, go to count modified buffer on the list 
    :sbmodified #, shorthand for :split and :bmodified 
    
    + buffer options, when the last window of a file is closed the buffer associated with the file become inactive. If the option hidden is set. files that leave the screen do not become inactive
    :set hidden 
    
    normally split/buffer related commands split the current window. if the "switch-buf" is set to "useopen" and there is a window displaying the buffer you want to display already on the screen. the vim will just make that window the current one 
    :set switchbuf=useopen
    other options are "(input nothing)", "split", "useopen" and "split,useopen"
    
    
# Basic visual mode 
- visual mode allow highlight a block of text and then execute a command on it
- enter visual mode 
use v command, highlight only full lines in this mode 

get help on the commands that operate in visual mode use v_command 

use CTRL-V to highlight a rectangle on the screen, you can highlight a column and delete it using the d command 

- leaving visual mode 
use <esc> or CTRL-C, use CTRL-\CTRL-N command to go to normal mode without the beep sound when double click the <esc> in normal model. 

- editing with visual mode 
the d command delete the highlight text 
the D command deletes the highlight lines 

- yanking text, the y commands places the highlighted text into a register, Y command place the lines into a register 

- switching modes, suppose you are in character mode(started by v) and you realize you want to t be in block mode, you can switch to block mode by just pressing CTRL-V 

- changing text, the c command deletes the highlighted text and starts insert mode, the C command for line 

- joining lines, use J command, it will add addtional space for each line. use gJ command to join line without adding spaces 

- commands for programmers, the > command indents the selected lines by one "shift width", < command. 
The command = indents the text. the CTRL-] command will jump to definition of the function highlighted 

- keyword lookup, K command is designed to look up the selected text usign the "man" comman. it works just liek normal-mode K comamdn except that it uses the highlighted text as the keyword

- visual block mode, CTRL-V. it is used to define a rectangle on the screen 

    + the command Istring <esc> inserts the text on each line starting at the left side of the visual block 

    if the string contain a newline the I acts like a normal mode insert i command, which will only change the first line 
    
    + changing text, the visual block c command deletes the block and then throws you into insert mode to enable you to type in a string. the string will inserted on each line in the block 
    
    the C command deletes text from the left edge of the block to the end of line 
    
    the short lines which not included in the block will be excluded 
    
    + append text with A command it will effect the short line 

    + replacing, r command will applies all the selected characters with a single character 
    
    + shifting >, < will remove one shift whitespace, if not enough whitespaces then it removes what it can 
    
    + visual block help 
    :help v_b_r 
    
    
# Commands for programmers 
- syntax coloring 
:syntax on 

- syntax coloring problems
find out background value option use 
:set background?

set bakcground with 
:set background=light 

for non-standard file extension 
:set filetype=c 

make setting automatically by 
:help new-filetype 

running the color test 
:edit $VIMRUNTIME/sytnax/colortest.vim 
:source % 

- shift command 
>>, << shift current line one shift width to the left 

:set shfitwidth=4 

- automatic indentation
cindent, works for c-style program such as c, c++, java 
smartindent, vim indents each line the same amount as the preceding one , adding an extra level of indentation if the line contains a left curly brace.
autoindent, new lines are indented the same as the previous line 

:set cindent

automatic swtich on cindent option by add exe liens in your .vimrc(unix) or _vimrc(windows) 
:filetype on 
:autocmd FileType c, cpp :set cindent

:set smartindent 

:set autoindent 

- the = command, the =motion command idents the sleected text using vim's internal formatting program
 
example =% means go to matching {} to indent a block of code 

- locating items in a program 
[CTRL-I], search for a word under the cursor in the current file and any brought in by #include directives 
gd, gD, search for definition of a variable 
]CTRL-D, [CTRL-D, jump to a macro definition 
]d, [d, ]D, ]D, display macro definitions 

- instant word searches including #include files 
[CTRL-I command jumps to the word under the cursor, search

- jumping to a variable definition(gd, gD)
the gd command searches for the local declaration of the variable under the cursor. this search is not perfrect because vim has a limited understanding of c and c++

- jump to marcro definition, [CTRL-D, ]CTRL-D 
- displaying marcro definition, [d, ]d, [D, ]D 
[d, displays the first definition of the macro 
]d starts looking from the current cursor position 
]D, [D display all the definitions 

- matching paires, the % command is designed to match paires of (), {} or [], % will also automatic match c comments, #if #else etc 

- shifting a block of text enclosed in {} 
>% this shifts the text right to where the motion takes you, % takes you to the matching {} 

shift the text in the {}, then you need to do 
    + position the cursor on the first {
    + execute the command >i{
    this hift right command > shifts the selected text to the right one shift width. in this case the selection command that follows is i{ which is inner {} block command 
    
- indenting a block using visual mode 
    + position the cursor on the left or right curly brace 
    + start visual mode with the v command 
    + select the inner {} block with the command i} 
    + indent the text with > 
    
- finding man page 
the K command runs a Unix man command using the word under the cursor as a subject, on window the K command performing a :help on the owrd under the cursor 

    + the format of man command 
    $ man [section] subject 
    
the K command consider a word is defiend by the isKeyword option 

- tags
the location of function definitions is stored in a table of contents file generated by the program ctags which come from vim 
$ ctags *.c 
to generate named tags 

in vim to go to a function definition by
:tag function  command 

the CTRL-] jump to the tag of the word that is under the cursor 

the command tags to shows the list of tags that you hvae traversed 
:tags 

go back with command CTRL-T command 

prefix a count 
:#tag 

- help and tags 
    + execute a hyperlink jump, press CTRL-], jump to tag 
    
- windows and tags 
    + split window and view a tag 
    :split tag 
    
- finding a procedure when you only know part of the name such as find window api or unix api 
:tag command to find a procedure by name or search for a regular expression 

:tag /regex 

to get a list of the return tags with 
:tselect {name} 
the result will contain several columns 
the first is the number of tag 
second is the priority column combines three letters
    + F, full match 
    + S, static tag, if missing, a global tag 
    + C, tag in the current file 
    
select only one item by 
:tjump , the gCTRL-] command does a :tjump on the word under the cursor 
:#tnext 
:#tprevious 
:#tNext 
:#trewind 
:#tlast 

- shorthand command 
:stselect does the same thing as :tselect except that it splits the window first, :stjump same as :split and a :tjump 

- the care and feeding of makefiles 
    + use list mode to display tab and space
    tab will show as ^I
    end of line will add $ 
    
    :set list 

    + use the expandtab option to let vim inserts spaces instead of tab character 
    :set expandtab 
    
    insert a real tab no matter the option are by CTRL-V<tab> in insert mode, the CTRL-V tell the vim don't change the following character 
    
- sort a list of files
    + go the start position add mark ma 
    + go to the bottom of a list 
    + run block through the external program sort using the command !'a sort 
    
- sorting a list in visual mode 
    + move to the top 
    + start line visual mode with v 
    + move to bottom of the text 
    + execute the command !sort. the ! tell vim to pipe the selected text through a command 
    
- making a program, vim editor has a set of commands it calls the quick-fix mode. these commands enable you to compile a program from within vim and then go through the errors generated fixing them 
:make 

:make arguments 

after call the make program, editor will automatic move cursor to error line 

go to next error 
:cnext 

    + for visual c++ micrsoft supplied nmake, you might need to customize vim using the makeprg option 
    
:cprevious or :cNext to go previous errors 
:clast, :cnfile goes to the first error message for the next file 

check current error 
:cc 

check list of error 
:clist 

check a range of list error 
:clist start,end 

vim will suppress all infromation message to tell vim show everything by 
:clist! 
the ! override option tell vim to not suppress anything 

if you have already run make and generated your own error file you can tell vim about it by using the :cfile error-file 

exit vim with error code 1
:cquit 

- the errorfile option, define the default filename used for the :clist command as well as the -q command line option 
:set errorfile=error.list 

- searching for a given string 
:grep -w ground_point *.c 

use :cnext, :cprevious and :cc command to page through the list of matches, :crewind goes to the first error and :clast to the last. finally following command goes to the first error in the next file. :cnfile 

- other interesting commands 
vim editor can use different options for different types of files through the use of the :autocommand 

customize your options on a per-file basis by putting something called a modeline in each file 


# Basic abbreviations keyboard mapping and initialization files 
- abbreviations is a short word that takes the place of a long one. define abbreviation 
:abbreviate ad advertisement 

- list your aabreviations 
:abbreviate 

- mapping, bind a set of vim commands to a single key, the normal text should be surround in {}
:map key commands 

exampele 
:map <F5>i{<Esc>ea}<Esc

- list mappings 
:map 

- fixing the way delete works, switch backspace and delete function 
:fixdel 

this modify the internal vim definitions for backspace(t_kb) and delete (t_kD)
 
- controlling what the backspace key does 
:set backspace=indent 
tells vim to allow backspacing over autoindents 

:set backspace=eol 
allow backspace over end of line 

:set backspace=start 
allow backspace over start of line 

:set backspace=indent,eol,start 

- saving your setting 
:mkvimrc 
writes all your settings to a file 
:mkvimrc file 

read the setting by 
:source file 

    + uring startup vim looks for an initialization file 
        * unix 
        $home/.vimrc 
        $home/_vimrc 
        $home/.exrc 
        $home/_exrc 
        
        * on window also search the vim install location 

- locating the initialization files with :version 
the command :mkexrc commands writes the mappings to the .exrc file 

- my .vimrc file 
:syntax on
:autocmd FileType * set formatoptions=tcql
\ nocindent comments&
:autocmd FileType c,cpp set formatoptions=croql
\ cindent comments=sr:/*,mb:*,ex:*/,://
:set autoindent
:set autowrite
:ab #d #define
:ab #i #include
:ab #b /****************************************
:ab #e <Space>****************************************/
:ab #l /*-------------------------------------------- */
:ab #j Jack Benny Show
:set shiftwidth=4
:set hlsearch
:set incsearch
:set textwidth=70

the file start with a command to turn syntax coloring on 
:syntax on 

use fancy searching 
:set hlsearch 
:incsearch 


# Basic command-mode commands 
- vim is based on vi the vi is based on ex. 
- in ex each command that begins with a colon is consider an ex-style command 
- entering command line mode use colon (:)

    + switch to command mode with ex command 
    :ex 
    
    + return to normal by :visual 
    
- print command 
    + a simple range can be print like 
    : 1,5 print 
    
    the last line number use $ 
    entire file by % 
    current line, . 
    specify line pattern 
    :#, /pattern/ print 
    the first # is the start line position 
    
    the pattern ?pattern? specifies the first previous line with pattern in it 
    
- marks 
m[a-z]

use mark '[a-z]

print also support use mark to set the start end postion 
'a,'z print 

- visual mode range specification
    + enter visual mode 
    + select the lines you want 
    + enter the command mode such as print then vim will automatic generate the selection range for the command 
    
- substitute command to preform string replacements 
:range substitute /from/to/flags 

example 
:% substitute /Professor/Teacher/
replace all occurrences of professor to teacher with following command 

by default substitute command only change the first occurrent word for each lines 

change every occurrence on the line, add g flag 
:% substitute /Professor/Teacher/g 

    + Other flags 
    p, print cause command print out each line 
    c, confirm tells to confirm 
    
- how to change last, first to first, last 
substitute command support regex replace 

- reading and writing files 
:read filename 

short form :r and insert into current line 

:write filename 
if you exit using the emergency abort command :q! the file reverts to the last written version 

:write command will not overwrite file by default, use ! option to overwrite existing files 

- the :shell command takes you to command prompt, use exit to return to vim 


# Basic GUI usage 
- the vim editor works well inside a windowing environment 
- start vim in gui mode 
$ gvim file 

- mouse usage 
    + make mose behave like xterm 
    :behave xterm 
    
    + make mouse behave like window 
    :behave window 
    
- tear-off menus, select and drag the first dot line of menu could drag drop the menu to other place 


# Dealing with text files 
- automatic text wrapping 
    + during programming line break will not be automatic added 
    + use textwidth option to let vim automatic inserts line break 
    :set textwidth=30 
    this is useful when creating document 
    
    :set wrapmargin=10 
    textwidth option overrules wrapmargin
    
    to keep text shape when deleting first line of text select the text and execute gq command to format the paragraph 
    
    another way to format a paragraph is to use the gqmotion command. 
    gq4j 
    tell gq to format this line and the next 4-5 lines total 
    
    the move forward paragraph command } 
    
    format current paragraph gqip, ip command  selects the inner paragrahp 

- text formatting command 
:range center width 

:1,5 center 30 

:range left margin 

- justifying text, vim editor has no built-in way to justify text. there is a neat macro package that does the job 

:source $VIMRUNTIME/marcros/justify.vim 

this macro file defines a new visual command _j to justify a block of text, highlight the text in visual mode and then execute _j 

- fine-tuning the formatting 

    + joinspaces option 
    the J command joins two lines putting in one space to separate them 
    
    :set joinspaces
    
    + formatoptions, controls how vim performs automatic wrapping 
    :set formatoptions=characters 
    
    t automatically wrap text 
    c automaticall wrap comments 
    r insert comment leader 
    o insert comment leader in a comment 
    q allow gq to format comments 
    2 format based on the indent of the second line 
    v do old style vi text wrapping 
    b wrap only on blanks you type 
    l do not break line insert mode 
    
- using an external formatting program 
    + on unix use fmt, it will instead the built-in gq command 
    :set formatprg=fmt 
    
    to run a paragraph through the program fmt 

- file formats 



 











































    
    
    











