Groovy Online Document;Note=Erxin

# Reference 
http://groovy-lang.org/syntax.html

# Sytax
- comments 
// 

/**/

- Shebang line, provided you have installed the Groovy distribution and the groovy command is available on the PATH
#!/usr/bin/env groovy 

- keywords 
as, assert, break, case, catch, class, const, continue, def, default, do, else, enum, extends, false, finally, for, goto, if, implements, import, in, instanceof, interface, new, null, pacakge, return, super, switch, this, throw, throws, trait, true, try, while

- identifiers 
def name
def item3
def with_underscore
def $dollarStart

    + quoted identifiers 
person.name, person.'name', person."name"

map."an identifier with a space and double quotes" = "ALLOWED"

- string
java.lang.String objects, as well as GStrings (groovy.lang.GString) 

Double-quoted strings are plain java.lang.String

no interpolated expression, but are groovy.lang.GString instances if interpolation is present
- tripple string 
'''string'''

def name = 'Groovy'
def template = """
    Dear Mr ${name},

    You're the winner of the lottery!

    Yours sincerly,

    Dave
"""

assert template.toString().contains('Groovy')

- escaping special characters 
'an escaped escape character: \\ needs a double backslash'

- string interpolation 
def name = 'Guillaume' // a plain string
def greeting = "Hello ${name}"

assert greeting.toString() == 'Hello Guillaume'

- closure expression. When the placeholder contains an arrow, ${→}, the expression is actually a closure expression

def sParameterLessClosure = "1 + 2 == ${-> 3}" 
assert sParameterLessClosure == '1 + 2 == 3'

def sOneParamClosure = "1 + 2 == ${ w -> w << 3}" 
assert sOneParamClosure == '1 + 2 == 3'

//closure can accept parameters, append content with the << leftShift operator.

//compare to expression, closures are lazy evaluated 

def number = 1 
def eagerGString = "value == ${number}"
def lazyGString = "value == ${ -> number }"

assert eagerGString == "value == 1" 
assert lazyGString ==  "value == 1" 

number = 2 
assert eagerGString == "value == 1" 
assert lazyGString ==  "value == 2" 

- Interoperability with Java. Even for the same resulting string, GStrings and Strings don’t have the same hashCode. When a method (whether implemented in Java or Groovy) expects a java.lang.String, but we pass a groovy.lang.GString instance, the toString() will automatic convert it. 

assert "one: ${1}".hashCode() != "one: 1".hashCode()

def key = "a"
def m = ["${key}": "letter ${key}"]     

assert m["a"] == null  

- slashy string, Groovy offers slashy strings, which use / as the opening and closing delimiter. another way to define GString

def fooPattern = /.*foo.*/
assert fooPattern == '.*foo.*'

def color = 'blue'
def interpolatedSlashy = /a ${color} car/

assert interpolatedSlashy == 'a blue car'

assert '' == //

- Dollar slashy strings are multiline GStrings delimited with an opening $/ and and a closing /$. The escaping character is the dollar sign, and it can escape another dollar, or a forward slash.

def name = "Guillaume"
def date = "April, 1st"

def dollarSlashy = $/
    Hello $name,
    today we're ${date}.

    $ dollar sign
    $$ escaped dollar sign
    \ backslash
    / forward slash
    $/ escaped forward slash
    $$$/ escaped opening dollar slashy
    $/$$ escaped closing dollar slashy
/$

assert [
    'Guillaume',
    'April, 1st',
    '$ dollar sign',
    '$ escaped dollar sign',
    '\\ backslash',
    '/ forward slash',
    '/ escaped forward slash',
    '$/ escaped opening dollar slashy',
    '/$ escaped closing dollar slashy'
].every { dollarSlashy.contains(it) }

use doller to escape character 

- characters 
char c1 = 'A' 
assert c1 instanceof Character

def c2 = 'B' as char 
assert c2 instanceof Character

def c3 = (char)'C' 
assert c3 instanceof Character

- numbers 
byte 
char 
short 
int 
long 
java.lang.BigInteger 


// primitive types
byte  b = 1
char  c = 2
short s = 3
int   i = 4
long  l = 5

// infinite precision
BigInteger bi =  6

def a = 1
assert a instanceof Integer

// Integer.MAX_VALUE
def b = 2147483647
assert b instanceof Integer

// Integer.MAX_VALUE + 1
def c = 2147483648
assert c instanceof Long

// Long.MAX_VALUE
def d = 9223372036854775807
assert d instanceof Long

// Long.MAX_VALUE + 1
def e = 9223372036854775808
assert e instanceof BigInteger

- non-based 10 reprenstations 
    + binary literal 
int xInt = 0b10101111
assert xInt == 175

short xShort = 0b11001001
assert xShort == 201 as short

byte xByte = 0b11
assert xByte == 3 as byte

long xLong = 0b101101101101
assert xLong == 2925l

BigInteger xBigInteger = 0b111100100001
assert xBigInteger == 3873g

int xNegativeInt = -0b10101111
assert xNegativeInt == -175

    + Octal literal
int xInt = 077
assert xInt == 63

short xShort = 011
assert xShort == 9 as short

    + hex literal 
nt xInt = 0x77
assert xInt == 119

short xShort = 0xaa
assert xShort == 170 as short

byte xByte = 0x3a
assert xByte == 58 as byte
    + decimal literals 
// primitive types
float  f = 1.234
double d = 2.345

// infinite precision
BigDecimal bd =  3.456

- underscore in literals =,  eye to figure out how some numbers are grouped together
long creditCardNumber = 1234_5678_9012_3456L
long socialSecurityNumbers = 999_99_9999L
double monetaryAmount = 12_345_132.12
long hexBytes = 0xFF_EC_DE_5E
long hexWords = 0xFFEC_DE5E
long maxLong = 0x7fff_ffff_ffff_ffffL
long alsoMaxLong = 9_223_372_036_854_775_807L
long bytes = 0b11010010_01101001_10010100_10010010

- number of type suffixes 

Type	Suffix
BigInteger

G or g

Long

L or l

Integer

I or i

BigDecimal

G or g

Double

D or d

Float

F or f

- match operations 
- booleans 
def blFlag = true = false 

- list, Use the << leftShift operator to append an element at the end of the list
def numbers [1,2,3]

def heterogeneous = [1, "a", true]
def arrayList = [1, 2, 3]
assert arrayList instanceof java.util.ArrayList

def linkedList = [2, 3, 4] as LinkedList    
assert linkedList instanceof java.util.LinkedLis

- arrays need to explicity define type 
String[] arrStr = ['Ananas', 'Banana', 'Kiwi']  

assert arrStr instanceof String[]    
assert !(arrStr instanceof List)

def numArr = [1, 2, 3] as int[]      

assert numArr instanceof int[]       
assert numArr.size() == 3

- maps, . Maps associate keys to values, separating keys and values with colons, and each key/value pairs with commas, and the whole keys and values surrounded by square brackets.
def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF'] 

assert colors['red'] == '#FF0000'    
assert colors.green  == '#00FF00'    

colors['pink'] = '#FF00FF'           
colors.yellow  = '#FFFF00'   

def key = 'name'
def person = [key: 'Guillaume']      

assert !person.containsKey('name')   
assert person.containsKey('key')  

Groovy creates maps that are actually instances of java.util.LinkedHashMap.


# Operators 
- arithmetic 






