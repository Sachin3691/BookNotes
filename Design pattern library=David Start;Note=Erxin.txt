Design pattern library=David Start;Note=Erxin

# in this module
- what they are 
general and reusable solutions to common problems in software design
- patterns are not concerned with
	+ algorithms
	+ specific implementations or classes
- Christopher Alexander, architect write a book A Pattern Language: Towns, Buildings Construction, 1977
  Gang of four, Erich Gamma, Richard Helm,...
- Pattern Organization
	+ create patterns
	abstract factory
	builder
	factory method
	prototype
	singleton
	lazy instantiation
	utility pattern
	+ classifications
	creational
	structural
	behavioural
	security
	concurrency
	sql
	user interface
	relational
	social
	distribute
- criticisms
	+ unnecessary duplication
	+ week points in language, pattern are work around for missing language features
	+ same as other abstractions
- pluralsight design pattern library implement using .net genuine and practical content

# adapter pattern
- common knows as wrappers to make reference old class to fit for new requirement
- intent to convert a class interface to another
- related patterns
	+ repository
	+ strategy
	+ facade, both are wrapper it will wrap many class into only interface
- reference
design patterns, gang of four
design pattern explained
design pattern in c#
head first design patterns
	
# bridge pattern, John Sonmez
- decouple an abstraction from its implementation, GOF
- decouple interface/abstract class from its implementation to make the subclass could change the implementation easily
- such as persistence providers

# Builder Pattern
- overview
Separates the construction of a complex object from its representation so that the same construction process can create different representations
separate logic and data
- too many constructors and have many parameters, this will make the constructors coupling together, to decouple the constructors by this step to make a builder pattern
	+ remove the multiple field and change most of them to property to let them assign value after build the object
	+ separate the assign property into multiple sub method to separate the build process
	+ abstract the create process into a maker class which is a bridge pattern to decouple the implementation from the abstract process
	+ the build force the object structure|steps and the maker control the build process 
	+ variations, such stringBuilder, it's make the builder easy to use with, it's a little bit diff between the builder pattern

# Chain of responsibility
- chain of responsibility traints
	+ sender is aware of only receiver
	+ each receiver is only aware of the next receiver
	+ receivers process the message or send it down the chain
	+ the first receivers to handler the message and terminates the chain
	+ the order of the receiver list matters
- traditional usage
client->IMessageHandler->ConcreteHandler,...
impelment:
client->handler0->handler1->...
- Motivating Example, expense report
- ex. Poker ranking
- it's could dynamicly control the responsible chain, the end of chain behavior can be define base on the business appropriately
- responsible of chain use case
	+ more than on message handler for a message
	+ the approriate handler is not explicitly known by the sender
	+ the set of handler could be dynamic define
- benefits
	+ decoupling
	+ dynamic manage the message handler
	+ end of chain behavior can be defined appropriatly
	
# Command Pattern
- a command-line order management systems
- decouple the client that execute the command from the details and dependences of the command object
- enable delayed execution
- represent an action as object
- implement of undo
- enforce logging
- support validation
- support undo

# Composite Pattern
- integrate collection to handle trees
- compose objects into tree structures to represent part-whole hierachies. Composite lets clients treat individual objects and compositions objects uniformly
	
# Decorator
- Add additional functions to the original classes to prevent mass the function
- It's also could prevent class explosion
- It's alternative to add a sub class
- Flexible design
- Support Open Closed Principle, class should open for extension but close for modification
- applicability
	+ legacy systems
	+ add functionality to controls
	+ sealed classes
- it's could mix use with component pattern
- it's wrap the aim object
- decouple the different class options which could prevent class explosion, 
- inherit the decorated object and save the object in the private field, implement the relative functions and then add the additional functions
- Consequences
	+ original object is unaware of any decorations
	+ no one big feature-laden class with all the options in it
	+ decorations can be composed together in a mix-and-match fashion
	+ can increase complexity of code, may cause hard to learn the system and debug the code
- Relative pattern, it's a structure design pattern
adapter, bridge, composite fa√ßade, flyweight, proxy
	
# Event Aggregate
- Use to synchronize multiple screen to display the same data whenever the data changed in a screen
- Intent
	+ simplify event registration by providing a single centralize store
	+ decouple the publisher and subscribers
	+ reduce friction for introducing new events
	+ reduce memory management issues related eventing
	+ if the subscribers don't subscribe the events it will cause memory leaks
- Applicability
	+ you are building a composite application
	+ you have complex screens
	+ you have many publisher and subscribers
	+ you have many events
	+ new events are added frequently
	+ static events are red flag
- Event Aggregation is a mid layer between subscriber and publisher, make the publisher only known the event aggregation
- How it get used
- The event aggregation may used in multiple thread
	private read-only lock = new object;
- use the weak reference method to reference the subscriber object to make sure the subscriber could be release the 
- The decoupling make the project easy to test 
- Known uses / variations 
	+ storyteller , http://storyteller.trigrist.org, IOC container 
	+ MVVM light, mvvmlight.codeplex.com
	+ Prim, microsoft.com/prism
- related patterns 
	+ pub/sub http://en.wikipedia.org/wiki/publish/subscribe
	+ observer http://en.wikipedia.org/wiki/ observer_pattern
	+ http://martinflowler.com/eaadev/eventAggregator.html
	+ http://codebetter.com
	
# Facade Pattern
- intent 
	+ provide a simple purpose-built interface to a larger, more complex body of code or interfaces 
	+ make a complex body of code simpler to consume and use 
	+ expose a set of complex object interactions with a single interface 
	+ wrap a poorly design api in a better design one 
- consequences
	+ use of the existing api is simple 
	+ the facade will need to be updated (or a new one created )to expose more functionality from the sub-system 
	+ the full capability of the underlying apis will offend not be available through the facade 
- sometimes the facade class may need a helper class to help create the apis 
- known uses
	+ data access 
	+ file and stream io 
- relative pattern 
adapter, flyweight, mediator 

# Factory patterns 
- a very simple factory 
- factory method
- abstract factory 
- motivating example 
	+ unsure which concrete implementation of an interface want to return 
	+ creation should be separate from representation of an object 
	+ lots of if/else blocks when deciding which concrete class to create 
	+ switch statements when deciding which concrete class to create 
- intent
	+ separate object creation from the decision of which object to create 
	+ add new classes and functionality without breaking OCP
		* factory products objects 
		* factory themselves 
	+ store which object to create outside of the program 
		* in a database 
		* in configuration 
- simple factory 
	+ encapsulate object creation 
	+ allows for late-bound decisions regarding instantion 
		* configuration 
		* other persistent storage 
		* input or other dynamic data 
	+ caller class knows what concrete factory it needs 
	+ implementation detail in .net
		* use the refractory feature to pull all the interface which is implement the specify interface 
		Dictionary<string, Type> autos;
		Types[] typesInThisAssembly = Assembly.GetExecutingAssembly().GetType();
		foreach(Type type in typesInThisAssembly)
		{
			if(type.GetInterface(typeof(IAuto).ToString())!=null)
			{
				autos.Add(type.Name.ToLower(), type);
			}
		}
		* use the Activator to create the instance of the specify type
		foreach(var auto in autos)
		{
			if(auto.Key.Contains(carName))
			{
				return autos[auto.Key];
			}
			return null
		}
- factory method, define a interface for creating an object, but let the subclass decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses
	+ Adds a interface to the factory from simple factory example
	+ defers object creation to multiple factories that share an interface
	+ derived class implement or override the factory method
- .net app setting
	+ add the name value parent in the app property's setting page
	+ use the Properties.Setting.Default.KeyName to reference the settings
- conclusion
	+ advantage
		* eliminate reference to concrete classes
		factories, objects created by factories
		* factories can be inherited to provide even more specialized object creation
		* rules for object initialization is centralized
	+ disadvantage
		* may need to create a factory just to get concrete class delivered
		* the inheritance hierarchy get deeper with coupling between concrete factories and created classes
- Abstract Factory for creating families of related or dependent objects without specify their concrete classes
	+ factories create different type concrete object(products)
	+ a factory now represent a family of objects that it can create
	+ factories may have more than one factory method
- Other relational patterns
	+ singleton
	+ builder
	+ object pool
	+ prototype
- related subjects
	+ nullObject
	+ open close principle
	
# Flyweight Pattern
- introduction
	+ reduce storage costs for large number of objects
	+ share objects to be used in multiple contexts simultaneously
	+ retain object oriented granularity and flexibility
- motivating example
	+ interiors design application
	+ tiles
- use a pool to manage the created object
- add a flyweight factory to check the specify type is already created or not.
- real world example, .net string class, String.Intern method returns fly weight
- related pattern 
	+ composite
	+ strategy
	+ state
	
# interpreter pattern, John Sonmez, http://simpleprogrammer.com, joh.sonmez@gmail.com
- Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences with the language
- barcode, how bar codes work
    + <UPC>::=<Manufacture ID><ItemNumber><Check Digit>
    + <Manufacture ID::=<Digit><Digit><Digit><Digit><Digit><Digit>
    + <ItemNumber>::=<Digit><Digit><Digit><Digit><Digit><Digit>
    + <Check Digit>::=<Digit>
    + <Digit>::=0|1|2|3|4|5|6|7|8|9
- UPC language
- BNF notation, define the common language useage 
    + http://cui.unige.ch/db-research/Enseignement/analyseinfo/AboutBNF.html
    + http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form
    + http://en.wikipedia.org/wiki/Universal_Product_Code
    + square barcode, http://en.wikipedia.org/wiki/Square_barcode
- Formal definition
    client->context
            abstract expression -> terminal expression
                                   nonterminal expression
                                   
# Iterator pattern
- want to traverse various kinds of collections without knowing about their internal structures
- SRP, single response principle
- Abstract the same logic from the multiple kinds of class
- Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation
- iterator pattern define a interface to iterator through the collection
- How it used
    + Each collection type requires two implementations
        * aggregate interface is implemented on the collection itself providing a way to get a iterator (a example of abstract factory method)
        * The iterator interface must be implemented for the collection type in question
    + client get a iterator from the collection
    + client use the iterator to traverse the collection
- Iterators in c# and .net
    + aggregate interface IEnumerable
    + iterator interface IEnumerator
    + could be used with 
        * foreach
        * linq
    + relative interface IQueriable
    + c# yield keyword
- Consequences
    + each iterator implement may traverse the aggregate in a different fashion
    + simplify the interface
    + more than one traversal can occur at the same time
- .net implement the iterator pattern
    + collection implement the IEnumerable<t>, IEnumerator
    + add a iterator class for the collection type and implement the IEnumerator<T> and IEnumerator
- Related patterns
    + factory, iterator are typically via factory methods
    + composite, can be used to recursively traverse
- References
    + design patterns, http://amzn.to/95q9ux
    + design pattern in c#, http://amzn.to/bqJgdU
    + head first design patterns, http://amzn.to/aA4RS6
    + http://stevesmithblog.com/common-design-patterns-resource
    
# Lazy load pattern
- Motivating example
    + loaded from persistent store
    + want to avoid loading portions of the object's state that you don't necessary need
    + don't want the client code to know if or when it needs to load additional state
- intent, only load the necessary needed data and leaving a maker in the object structure so that if the data is needed it can be loaded only when it is used
- variants, lazy initialization, virtual proxy, value holder, ghost
- Applicability, use the lazy load pattern when
    + fetching an object requires an extra call for the data
    + avoid using it unless or until you need it, use it as a tuning mechanism
    + balance amount of data being fetched with number of data request being made
- Lazy Initialization
    + every property checks to see if its backing field has been initialized
    + requires all access to the value to go through the property
    + requires knowledge of whether the fields has been calculated
- list of unit test framework
http://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#C.2B.2B
- .net 4.0 contain a Lazy<T> type for init a lazy load property, it's design as thread safe
    public classConstructor()
    {
        _fieldName = new Lazy<FieldType>(()=>new FieldType);
    }
    private FieldType _fieldName;
    public FieldType PropertyName
    {
        get
        {
            return _fieldName.Value;
        }
    }
- Virtual Proxy
    + proxy just like the real object
    + the proxy pattern may introduce identity problems, overwrite the equals function to by pass this
    + proxy isn't the object
    + may need to create many virtual proxies
        * best done via some kind of code generation
        * many OR/M tools create dynamic proxies
    + Virtual proxy consequences
        * managing identity can present challenges
        * need to create many virtual proxies, one for each class that is proxied
        * These problems are not present for collections
        collections are value objects do not have an identity
        typically there are fewer collections than objects
        collections typically provide largest performance benefit from lazy loading
- Value holder
    + provides lazy load functionality without encapsulation
    + calling code knows it is working with a value holder type
    + requires creating several new types
    valueHolder, IValueLoader, Factory or Mapper classes
    + Value Holder uses IValueLoader via Strategy pattern to load value when accessed
    + .net 4.0 use the Lazy<T> type to support the lazy load function
- Ghost
    + a ghost is a real object in a partial state
    + initially the ghost only contains its id
    + whenever any property is accessed, the ghost class loads all of its state from the persistence
    + essentially, the objects its own virtual proxy
    this violates the single responsibility principle
    + avoids identity concerns of virtual proxy technique
- Entity framework is implement with lazy load
- Consequences
    + improve performance by eliminating unnecessary calls to data source
    + Keeping domain objects ignorant of mapping and persistence may require significant code and complexity
    + tune app to load the data it needs when it need it, with a few requests
- Relative patterns 
Proxy, strategy, template
- References
    * Patterns of enterprise application architecture, http://amzon.to/MFPoEAA
    * http://www.martinfowler.com/eaaCatalog/lazyLoad.html
                                   
# Mediator pattern
- motivating example
    + many objects have similar type that need to communicate with each other
    + the communicate between object is complex
- Definition, define an object encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other  explicitly, and it lets you vary their interaction independently
- Components
    + individual components that need to communicate with each other
    + implement same base type(abstract class or interface)
    + have knowledge of the mediator component
    + the components knows the mediator
- Mediator
    + The centralized component that managed communication between the colleague components
    + Implement an abstraction that is used by the colleague components
- The real world example is the window app communicate with the message
- Advantage & Disadvantages
    + Advantages
    hides all coordination between colleagues
    decoupled colleagues
    mediator's one-to-many relationship with colleagues is preferred to colleagues relating to many-to-many fashion
    + disadvantages
    the mediator can become very large and very complicated as more colleagues are handled
	
# Memento design pattern
- Motivating example, be useful to rollback one or more objects within your application to previous state (for example, to implement undo) 
- Providing undo functionality in one class will violate the SRP
- providing full access object's internal state violate the encapsulation principle
- the memento pattern describe a way to capture object's internal state without violating encapsulation or SRP
- Intent
    + without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state latter
    + the memento pattern involves two objects: the originator and the caretaker, originator is the object be track, caretaker performs operations and be able undo the operations
- How it get used
    + memento itself simply holds the state of the originator
        * ideally, only the originator should have access to the internal details of its state within the memeto
        * caretaker's interface to memento should not allow it to access the internal state of originator
    + undo/redo stack
- consequences
    + memeto shield other objects from potentially complex
    + keep the originator simpler
    + creating and retoring state may be expensive
    + may be difficult to ensure only the originator can access memento's state
    + caretaker is responsible for managing memento
    + iterative memento
- related patterns
    + command
    + iterator
- references
    + design pattern, gan of 4
    + design pattern in c#
    
# Model view presenter(MVP)
- motivating example, splite the present and back logic
- intent
    + clear separation between
        * data to show
        * business logic
        * display of data
    + ensure each collaborator in the pattern has a single responsibility
        * model
        * view
        * presenter
    + facilitate isolated testing of each collaborator in the pattern
- Variations on MVP
    + Martin Fowler's take on it
    MVP pattern retirement note
    http://bit.ly/MdQie
    + Supervising controller
    http://bit.ly/HvqVA
    + Passive view
    http://bit.ly/lpMdr
    + MVP Variations on MSDN
    http://bit.ly/geEfUF
- Structure
View -> Presenter -> Mode
    <-
         ^
         |
Domain layer -> Data Acess
View and model know nothing of each other
    + model not must be the data entity from the database, it may reform the data
    + model is a special purpose view of data just for by the view
    + there are two ways two use the data mode from the view
        * the presenter push all the data to the view and let the view pick what they want, the bad side is the view will compose of many code logic decide by the mode
        * set the pick data logic into the presenter and let the presenter pick the view's need
    + explicitly define the view interface for using by both the presenter and the view
- Collaboration
    + model, holds data destined to be surface by the view
    + view
        * instantiates the presenter
        * request that the presenter to do work 
        * may have a reference to the model
        * may rely on the presenter to set data on the view using data model
    + presenter
        * response to view requests
        * may knows when data is updated
        * updates the view with data from the model
- each class is testable in isolation of each other
    + clear separation of concerns
    * each collaborator has a single responsibility
    + far more readable and maintainable than finding business logic
- MVP frameworks for .net
    + claymore
    + MVC# framework
    + web client software factory
    + evolution .net mvp framework
    + asp.net webforms model-views-presenter

# Model-view-viewmodel(MVVM)
- introduction
    + history martin fowler - presentation model(PM)
    + John Gossman unveiled the MVVM pattern
        * variation of MVP
    + John changes his mind
        * identical to PM pattern
        * dependent on WPF/Silverlight
- intent
    + separate the concerns
    view, view's state and behavior, data
    + unit testing & UI testing
    + maintenance
    + extensibility
    + enables the designer/developer workflow
    + take advantage of WPF/Silverlight data binding
- structure
    + view
        * may or may not have a reference to the viewModel
        * does not have a reference to the model
    + viewModel
        * has a reference to the model
        * may or may not have a reference to the view
    + model, has no reference to the view or viewModel
- The mode
    + implement INotifyPropertyChanged, IDataErrorInfo
- The view model
    + implement INotifyPropertyChanged
- View
    + don't have the responsible to update the mode, business rules, or validation, retrieving data
    + responsible to display data, collect data from users
    + binding
- binding the view to the view model
    + declare view model in xaml as resource
    drawback, can't control the initialization of view mode
    + imperatively in code, view model locator, data template, inversion of control, factory pattern with inversion of control
- communication between view and view mode
    + event
    + commands, likes event, also trace if it's available, the UI associate will disable when no event handler
        * execute
        * canExecute
- Consequences
    + pro
    reduce code-behind
    model doesn't need to change to support a view
    designers design, coders code
    + con
    create more files
    lack of standardization
    specify to wpf and silverlight platforms
- many frameworks
    + mvvm light toolkit
    + caliburn, cinch, onyx, mvvm foundation, and more...
    
# null object pattern, Davide Start
- make codes clean and easy to use
- motivating example
    + I call it my billion-dollar mistake. It was the invention of the null reference in 1965, Sir Hoare, QCON, Sir Charles Antony Richard Hoare
        * inventor of quickSort
        * Turing award winner
        * Microsoft principal researcher
- a empty set, collection is a replace for null reference
- intent 
    + rid program logic of null checks where possible
    + provide a non-functional object in place of a null reference
    + allow methods to be called on null objects, unlike a null reference
- applicability
    + when handling of null should be abstracted from the client
    + when an object requires a collaborator
    + example
        * implementing a null strategy object we don't want work to actually 
        * implement a null command and the execute do nothing
- also known as 
stub, active nothing, active null
- could be a special case for 
strategy pattern, command pattern, state pattern, others
- structure, in .net could implement the null class in the abstract base class  and use it define a static NULL property in the abstract class
- consequences
    + cleaner code
    + fewer null check
    + unless developer knows the other developer make keep using the null check
- implement notes
    + null object is often a singleton
        * no behaviour or state to vary over instances
        + multiple instances would be identical anyway
    + do nothing code in null object is centralized for all callers
    + can be difficult to implement if all callers don't agree to "do nothing behaviour"
    + sometimes, caller code DOES to know it has a null objects

# Observer pattern
- motivating example
    + when one object is dependent on another object
    + when changing one object requires to a change to many others
    + when changes to an object should allow notification to others without any knowledge of them
- introduction to the observer
    + adopt the principle of separation of concerns
    + allows multiple observers to react to changes to a single subject
    + subject provides a way to register, unregister, notify
    + observer provide a way to update
- traditional
    + abstractSubject
    register, unregister, notify
    + abstractObserver
    update
- Consequences
    + multiple subjects for each observer
    + triggering the update when multiple properties are involved
    + dispose subjects & observers can hold reference to each other
    + mapping of subjects to their observers
    + unexpected updates
    + observing different properties separately
- events and delegates
is .net built in to support the observer pattern
- IObservable<T>, IObserver<T> c# interface
    + IObservable
    Subscribe(IObserver), Notify()
    + IObserver
    OnComplete, OnError, OnNext
    + the observer is a responsible chain 
- Push versus pull
Data -> IEnumerable->pull->External Environment ->Push-> IObservable
- Real world examples
- pitfalls to avoid

# The Prototype pattern
- introduction
    + overview 
    + problem1, construction is expensive
    + problem2, state is important
    + problem3, Hiding the constructor
    + prototype design
- prototype
specify the kinds of objects to create using a prototypical instance, and create new object by copying this prototype
- the clone method is used to implement the prototype pattern
    MemberwiseClone();
- .net implement the ICloneable interface
- hide the complicate constructors and public several initialized object and provide a clone method to let the user to clone the object
    
# Proxy design pattern
- provide a surrogate or placeholder for another object to control access to it
- surrogate pattern
- motivating example
    + you need a placeholder for an actual object that is expensive to create
    example: create a placeholder for image while the image is loading
    + you need to provide a local object that stands in place of a remote object and acts as a intermediary
- applicability
    + remote proxy, acts as a local representative of a remote object
    + virtual proxy, creates expensive object on demand
    + protection proxy, used to control access to an object base on authentication
- structure
    + the proxy and the real object implement a common interface and the proxy will call the real object on demand, this also could help with lazy loading
    + alternative structure is the proxy derived from the real object and call the base class method on demand
- how it gets used
    + clients work with proxy as if it were the actual object
    + control access
    + used to 
        * improve performance
        * simplify interactions with real object
        * defer expensive calls until needed
- lazy loading
    + objects stored in database many span many tables and rows
    + Lazy<T> in .net 4
- Consequences
    + client codes does not need to be changed to work with a proxy
        * proxy must be kept synchronized with real object, such as wcf service reference will support automatic update
    + proxy is used to optimize performance without touch existing class
    + client code may make incorrect assumptions about behaviour of real real object
        * interface may use many small calls rather than few, large calls
        * chatty versus chunky interface
        * client access to lazy-load object may result more database calls
- implementation example
    + normal lazy<T>
    + wcf, dto, data transfer object, add service reference
    + cached proxy, repository pattern
    MemoryCache class in .net to cache object in memory
    earlier version HttpRuntime.Cache reference system.net  
- relative patterns
    + adapter
    + decorator
    
# Repository pattern
- why?
    + separate business code from data access
        * separate of concerns
        * testability
- intent
    + encapsulate data access
    all the business logic access with the entityRepository, the repository pattern isolate the low level data access logic to the higher level business logic
- define a entity repository interface 
    + common interface are
    add, remove, update, getSpecialSetOfEntity, implement IQueryable to support linq, find
    + the interface parameters type is the generalize the better
    IEnumerable<Type> > IList<Type> > List<Type>
- define a generic Repository<T>
    public interface IRepository<T>
    {
        void Add(T newEntity);
        void Remove(T entity);
        IQuerable<T> Find(Expression<Func<T, bool>> predicate);
    }
- with define the generic Repository we could make some fake repository and let it instead the real repository in the unit test
    + Mock framework
    + Manually build a fake repository
- Applicability
    + any time you need data persistence 
    sql database, webservice, filesystem
- Consequence
    + increase level of abstraction
    more classes, less duplicated code, maintainability, flexibility, testability
    + Further away from data
    shield from infrastructure, harder to optimize
- Relative patterns
    + unit of work
    responsibility is used to track multiple repositories' operations into one single transaction 
    + specification pattern
    when you need build up complex 
    + identity map, force the object identity with the database identity with the same id
    + decorator
    such as add cache repository
    
# Singleton pattern
- motivation example
    + some class should have exactly one instance
    + ex.
        * access to computer's filesystem
        * access to network's printer spooler
        * access to operation system's window manager
    + commonly singletons should only be created when they are first needed(e.g. lazy construction)
- intent 
    + ensure class have only one instance
    + make the class itself responsible for keeping track its sole instance
    + there can be only one
- applicability
    + must be only one instance
    + can be access from the client
    + should not require parameters as part of construction
    + when creating instance is expensive
- structure
    + attributes
    + operations
        * instance
        * other business operations
        * private singleton constructor
    + ex. code in c#, not thread save
    public class Singleton
    {
        private static Singleton _instance;
        private Singleton(){}
        public static Singleton Instance
        {
            get
            {
                if(_instance == null)
                {
                    _instance = new Singleton();
                }
                return _instance;
            }
        }
    }
    + ex. thread save and fast
    public class LazySingleton
    {
        private LazySingleton()
        {
            public static LazySingleton Instance
            {
                get {return Nested.instance;}
            }
        }
        
        private class Nested
        {
            static Nested(){}
            internal static readonly LazySingleton instance = new LazySingleton();
        }
    }
- how it get used
    ins = Singleton.Instance();
    ins.DoStuff();
- Collaboration
    + classes that need to interact directly with a singleton must refer to its instance property (or method)
    + alternately classes can depend on an interface or parameter of singleton's type
- Consequences
    + singleton introduce tight coupling among collaborating classes
    + singleton are notoriously difficult to test
    commonly regarded as an anti-pattern
    + using an ioc container it is straightforward to avoid the coupling and testability issues
- single responsibility
    + manage of object lifetime is a separate responsibility
    + adding this responsibility to a class with other responsibility violates the SRP
    + using an IOC container a separate class can be responsible for managing object lifttimes
- implement example
    + logging to a common file
    using separate instance
    introducing locking, double check lock
    lazy instantiation via statics
    introducing lazy instantiation via statics
    + execution modes
    single-thread, multi-thread(in parallel)
- IOC containers to make the class behave like singleton
    + microsoft unity IOC container
    microsoft.practices.unity
    + structure mapping
    + neijact
    + ex. use unity
    _container.RegistType<IInterface, Class>(new ContainerControlledLifetimeManager);
    _container.Resolve<IInterface>(); 
    this make the container return the same instance whenever client ask for a instance of the specify interface
    + when singleton instance is created it will keep alive until the app process over, which make it hard to test when it open a expensive resource which could only be access in one time
- relative pattern
builder, abstract factory
    
# Service locator
- service locator is a creater pattern in the enterprise library
- creational pattern
    + gang of four
    abstract factory, builder, factory method, prototype, singleton
    + core j2ee buisiness tier
    session facade, service locator, value list handler
    + inversion of control containers
    spring.net, structureMap, ninject, castle windsor
    + implementation method
    service locator, dependency injection, factory pattern
- motivating example
    + logging
    used throughout the application
    independent of any particular business function
    easy to implement for each application for simple needs
    often is changed based on environment or deployment needs
- the service locator is the mid layer of app and other tide coupled services such as logging. it could make the coupled services decouple and could changed the service provider easily
- intent 
    + abstract the application from the services it uses
    + play the middleman
    + change the service without recompilation
    + identify the service through configuration
    + non-programmers adjust app configuration
- real word example
    + 114
    + DNS server
- Log provider libraries
    + Log4net
    + NLOG
    + Enterprise Application Block
- Advance service locator structure
app->service locator-> service adapter -> service provider
- benefits
solid principles, single responsibility, open/closed principle,  interface segregation, liskov substitution, dependency inversion service dependent only on the interface
- consequences
    + global
    + availability
- related patterns
observer design pattern, locate new service when they become avaliable
proxy design pattern, match implementation
adapter design pattern
dependency injection, pass the service when we create client
- ioc container

# state pattern
- behaviour design patterns
- let the app change the behaviour base on the object's state
- motivating example
    + work item tracking
    + features
    + CMMI
    + agile
- issues with the simple approach
    + mixed concern
    + no extensibility
    + difficult to unit test
- intent of the state pattern
    + change behaviour of the object with each state
    + encapsulate the logic of each state into a single object
    + allow for dynamic state discovery
    + make unity easier
- structure
    + set a base state class
    + the object contain the commands to change or set the state
- the command pattern should use the dependency injection pattern and mix used with the state pattern
    
# Strategy pattern
- motivating example
    + an order shipping
    + calculator must determine shipping cost depending on the customer chosen
- intent
    + encapsulate a family of related algorithms
    + let the algorithm vary and evolve separate from the class using it
    + allow a class to maintain a single purpose
    + separate the calculation from the delivery of its results
- applicability
    + switch statements are a red flag
    + adding a new calculation will cause a class file to be modified
- implementation example
    + create classes for each calculation (strategies)
    + use a common interface for each strategy
- consequence
    + strategies may not use members of the containing class
    + tests may now be written for individual concrete strategies
    + adding a new strategy does not modify the context class
- known uses
    + delegates in .net 3.5 and greater
    + service pass to constructor for 
    asp.net mvc controllers
- variations
    + func or delegate in .net
    + property injection
    + pass strategy on method rather than constructor
	
# template pattern
- model a process or algorithm of several steps
- allow variation of the detail of each step, while enforcing the structure and order of the steps themselves
- for instance a game engine might dictate certain steps making up a variety of games
- intent
    + encapsulate and enforce the workflow or process that is not variable
    + allow subclass to alter specific behaviour
    + redefine class or algorithm step without 
- applicability
    + two or more classes should follow the same common algorithm or workflow
    + workflow is invariant. subclass may redefine certain steps, but may not change the algorithm's  structure
    + some workflow steps may be encapsulate in the base class with a default implementation and only overridden iff necessary, allowing code reuse
- how it get used
    + clients call children of base implementation
    + child type customize individual step behaviour
    + effect way to achieve open/close principle
- consequences
    + algorithm steps must be known and relatively inflexible at the time the pattern is applied
    + relies on inheritance, rather than composition, which can be a limitation
        * strategy pattern is a fix pattern
    + single inheritance make it difficult to merge two child algorithms into one
        * decorator pattern for a possible solution for this problem
- Hooks
    + hooks are methods declared in the abstract class that have no implementation
    + allow sub-class to hook into the behaviour of the algorithm at various points or ignore the hook entirely 
- the hollywood principle 
    + not call us, we'll call you
    + high level components should not depend on low level components
    + base class with template method is high level component-clients should depend on this class
    + subclass are the low-level implementation, they don't call anything themselves, and are only called by the high-level template method
- implementation example
    + asp.net web forms
    page life cycle
    + order processing
    customizing steps in the order
- related patterns
strategy, decorator, factory method
    
# unit of work
- why
    + effective data access
    + manage the concurrency problems
    + mange transactions
    + ex.
    var employee = repository.FindEmployById(id);
    employee.Name = newName;
    unityOfWork.Commit();
- intent
    + logic transactions
    multiple components contribute work
- already exist .net module which are already implement the unit of work pattern
    + ado.net
    using(var connection = new SqlConnection(_connectionString))
    {
        connection.Open();
        var adapter = new SqlDataAdapter("select * from employees", connection);
        var employeeTable = new DataTable("Employee");
        adapter.Fill(employeeTable);
        
        AddEmployee(employeeTable);
        ModifyEmployee(employeeTable);
        
        adapter.Update(employeeTable);
    }
    private void ModifyEmployee(DataTable employeeTable)
    {
        var firstEmployee = employee.Rows[0];
        firstEmployee["Name"] = "Scott";
    }
- .net 4 entity framework 
    + define datamode for the app and set the mapping to the database table
    + create object collection and use the linq to finish the query
    + ex.
    var context = new ObjectContext(_connectionString);
    context.CreateObjectSet<Employee>()
           .OrderByDesending(e=>e.HireDate)
           .First();
    //do some changes
    context.SaveChanges();
- applicability
    + anytime you need data persistence
    + commonly implemented by persistence frameworks
    ORMs(NHibernate, entity framework)
    ADO.net(Dataset & DataAdapter)
- Consequences
    + beware of lifetime issues
    singleton unity of work is deadly in app lifetime cycle, it's more reasonable to set it in a form or request lifetime cycle
- related patterns
    + repository
    + identity map
    
# visitor pattern, john sonmez
- represent an operation to be performed on the elements of an object structure. visitor let you define a new operation without changing the classes of the elements on which it operates
- visitor selling(MLM, multiple level marketing)
- define a common visitor interface and this visitor is encapsulate the data operation for all the data models, different logic could be added by added a new visitor type
- structure
    + data mode class
    class dataMode0
    {
        //other data structure define
        
        //accept the visitor 
        accept(ivisitor){...};
    }
    ...
    class dataModeCollection
    {
        dataModelCollections;
        accept(ivisitor){...} //iterator all the contained dataMode
    }
    visitor interface 
    {
        visit(dataModel0);
        visit(dataModel1);
        ...
    }
    dataMode interface
    {
        accept(ivisitor); //make the datamode could accept a specify visitor
    }
    + all the business logic could be add by adding a new visitor without changing the data model class
    
# Rules pattern, Steve Smith, twitter@ardailis
- Motivating example
    + growing complexity in particulate area in our application
    + additional changes of the same nature are likely
    + examples
        * customer discount calculations
        * social gamification rules(badges/points)
        * credit/insurance rating
- visual studio 2012 have a plug in "code matrix" to show the code complexity of each method and the maintainability for the method
- the problem of if/else copy paste code method problems
    + growing complexity, use the code matrix to get the complexity number should below 10 in normal
    http://bit.ly/ieyeRy, more on cyclomatic complexity
    + duplicate code
- intent
    + separate individual rules from rules processing logic
    + allow new rules to be added without the need for changes in the rest of the system, Open/Close principle
- applicability
    + consider using the rules pattern when
        * a system is suffering from conditional complexity and additional changes of the same nature are anticiplated
        * a system has commingled the concerns of choosing which action(s) are applicable, and executing these actions
        * a system needs to support user-created logic for determing when and how to apply actions
    + rules pattern could be seen as a special case of command pattern
- structure
evaluator contains multiple rules, rules execute and isMatch methods, each concreteRule will implement the irule interface
- Rule Considerations
    + read only? dependencies
    + explicit order run the rules or set rule priority
    + persistence and provide a user interface to let the user change the rules
- Business rules engines
    + software systems designed to encapsulate business rules
    + typically support authoring of rules by business users
    + rules stored in a database or file system
    + many commercial and open source options
    + .net 3+ include a ruels engine in system.workflow
    http://bit.ly/aetfj0
- practice, the greed game kata
    + write a greed game scoring method using the rules in the kata
    http://nimblepros.com/media/36619/greed%20kata.pdf
- references
    + SOLID principle of object oriented design, http://bit.ly/rKbR9a
    + online
    soft coding, http://thedailywtf.com/articles/soft_coding.aspx
    should you use a rule engine, http://www.jessrules.com/guidelines.shtml
    simple.net rules engine discussion(stackoverflow), http://bit.ly/fDH8r
    business rule engine, http://en.wikipedia.org/wiki/Buisiness_rules_engine
    intro to WF rules Engine, http://bit.ly/aetfj0
    
    
    
    
    
    
	
	
	
	